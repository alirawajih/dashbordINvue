{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nrequire(\"core-js/modules/es.array.unshift.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/web.immediate.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * @module common/util\n */\nconst projectify_1 = require(\"@google-cloud/projectify\");\nconst duplexify = require(\"duplexify\");\nconst ent = require(\"ent\");\nconst extend = require(\"extend\");\nconst google_auth_library_1 = require(\"google-auth-library\");\nconst retryRequest = require(\"retry-request\");\nconst stream_1 = require(\"stream\");\nconst requestDefaults = {\n  timeout: 60000,\n  gzip: true,\n  forever: true,\n  pool: {\n    maxSockets: Infinity\n  }\n};\n/**\n * Custom error type for API errors.\n *\n * @param {object} errorBody - Error object.\n */\nclass ApiError extends Error {\n  constructor(errorBodyOrMessage) {\n    super();\n    if (typeof errorBodyOrMessage !== 'object') {\n      this.message = errorBodyOrMessage || '';\n      return;\n    }\n    const errorBody = errorBodyOrMessage;\n    this.code = errorBody.code;\n    this.errors = errorBody.errors;\n    this.response = errorBody.response;\n    try {\n      this.errors = JSON.parse(this.response.body).error.errors;\n    } catch (e) {\n      this.errors = errorBody.errors;\n    }\n    this.message = ApiError.createMultiErrorMessage(errorBody, this.errors);\n  }\n  /**\n   * Pieces together an error message by combining all unique error messages\n   * returned from a single GoogleError\n   *\n   * @private\n   *\n   * @param {GoogleErrorBody} err The original error.\n   * @param {GoogleInnerError[]} [errors] Inner errors, if any.\n   * @returns {string}\n   */\n  static createMultiErrorMessage(err, errors) {\n    const messages = new Set();\n    if (err.message) {\n      messages.add(err.message);\n    }\n    if (errors && errors.length) {\n      errors.forEach(({\n        message\n      }) => messages.add(message));\n    } else if (err.response && err.response.body) {\n      messages.add(ent.decode(err.response.body.toString()));\n    } else if (!err.message) {\n      messages.add('A failure occurred during this request.');\n    }\n    let messageArr = Array.from(messages);\n    if (messageArr.length > 1) {\n      messageArr = messageArr.map((message, i) => `    ${i + 1}. ${message}`);\n      messageArr.unshift('Multiple errors occurred during the request. Please see the `errors` array for complete details.\\n');\n      messageArr.push('\\n');\n    }\n    return messageArr.join('\\n');\n  }\n}\nexports.ApiError = ApiError;\n/**\n * Custom error type for partial errors returned from the API.\n *\n * @param {object} b - Error object.\n */\nclass PartialFailureError extends Error {\n  constructor(b) {\n    super();\n    const errorObject = b;\n    this.errors = errorObject.errors;\n    this.name = 'PartialFailureError';\n    this.response = errorObject.response;\n    this.message = ApiError.createMultiErrorMessage(errorObject, this.errors);\n  }\n}\nexports.PartialFailureError = PartialFailureError;\nclass Util {\n  constructor() {\n    this.ApiError = ApiError;\n    this.PartialFailureError = PartialFailureError;\n  }\n  /**\n   * No op.\n   *\n   * @example\n   * function doSomething(callback) {\n   *   callback = callback || noop;\n   * }\n   */\n  noop() {}\n  /**\n   * Uniformly process an API response.\n   *\n   * @param {*} err - Error value.\n   * @param {*} resp - Response value.\n   * @param {*} body - Body value.\n   * @param {function} callback - The callback function.\n   */\n  handleResp(err, resp, body, callback) {\n    callback = callback || util.noop;\n    const parsedResp = extend(true, {\n      err: err || null\n    }, resp && util.parseHttpRespMessage(resp), body && util.parseHttpRespBody(body));\n    // Assign the parsed body to resp.body, even if { json: false } was passed\n    // as a request option.\n    // We assume that nobody uses the previously unparsed value of resp.body.\n    if (!parsedResp.err && resp && typeof parsedResp.body === 'object') {\n      parsedResp.resp.body = parsedResp.body;\n    }\n    callback(parsedResp.err, parsedResp.body, parsedResp.resp);\n  }\n  /**\n   * Sniff an incoming HTTP response message for errors.\n   *\n   * @param {object} httpRespMessage - An incoming HTTP response message from `request`.\n   * @return {object} parsedHttpRespMessage - The parsed response.\n   * @param {?error} parsedHttpRespMessage.err - An error detected.\n   * @param {object} parsedHttpRespMessage.resp - The original response object.\n   */\n  parseHttpRespMessage(httpRespMessage) {\n    const parsedHttpRespMessage = {\n      resp: httpRespMessage\n    };\n    if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) {\n      // Unknown error. Format according to ApiError standard.\n      parsedHttpRespMessage.err = new ApiError({\n        errors: new Array(),\n        code: httpRespMessage.statusCode,\n        message: httpRespMessage.statusMessage,\n        response: httpRespMessage\n      });\n    }\n    return parsedHttpRespMessage;\n  }\n  /**\n   * Parse the response body from an HTTP request.\n   *\n   * @param {object} body - The response body.\n   * @return {object} parsedHttpRespMessage - The parsed response.\n   * @param {?error} parsedHttpRespMessage.err - An error detected.\n   * @param {object} parsedHttpRespMessage.body - The original body value provided\n   *     will try to be JSON.parse'd. If it's successful, the parsed value will\n   * be returned here, otherwise the original value.\n   */\n  parseHttpRespBody(body) {\n    const parsedHttpRespBody = {\n      body\n    };\n    if (typeof body === 'string') {\n      try {\n        parsedHttpRespBody.body = JSON.parse(body);\n      } catch (err) {\n        parsedHttpRespBody.err = new ApiError('Cannot parse JSON response');\n      }\n    }\n    if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) {\n      // Error from JSON API.\n      parsedHttpRespBody.err = new ApiError(parsedHttpRespBody.body.error);\n    }\n    return parsedHttpRespBody;\n  }\n  /**\n   * Take a Duplexify stream, fetch an authenticated connection header, and\n   * create an outgoing writable stream.\n   *\n   * @param {Duplexify} dup - Duplexify stream.\n   * @param {object} options - Configuration object.\n   * @param {module:common/connection} options.connection - A connection instance used to get a token with and send the request through.\n   * @param {object} options.metadata - Metadata to send at the head of the request.\n   * @param {object} options.request - Request object, in the format of a standard Node.js http.request() object.\n   * @param {string=} options.request.method - Default: \"POST\".\n   * @param {string=} options.request.qs.uploadType - Default: \"multipart\".\n   * @param {string=} options.streamContentType - Default: \"application/octet-stream\".\n   * @param {function} onComplete - Callback, executed after the writable Request stream has completed.\n   */\n  makeWritableStream(dup, options, onComplete) {\n    onComplete = onComplete || util.noop;\n    const writeStream = new stream_1.PassThrough();\n    dup.setWritable(writeStream);\n    const defaultReqOpts = {\n      method: 'POST',\n      qs: {\n        uploadType: 'multipart'\n      },\n      timeout: 0,\n      maxRetries: 0\n    };\n    const metadata = options.metadata || {};\n    const reqOpts = extend(true, defaultReqOpts, options.request, {\n      multipart: [{\n        'Content-Type': 'application/json',\n        body: JSON.stringify(metadata)\n      }, {\n        'Content-Type': metadata.contentType || 'application/octet-stream',\n        body: writeStream\n      }]\n    });\n    options.makeAuthenticatedRequest(reqOpts, {\n      onAuthenticated(err, authenticatedReqOpts) {\n        if (err) {\n          dup.destroy(err);\n          return;\n        }\n        const request = options.requestModule.defaults(requestDefaults);\n        request(authenticatedReqOpts, (err, resp, body) => {\n          util.handleResp(err, resp, body, (err, data) => {\n            if (err) {\n              dup.destroy(err);\n              return;\n            }\n            dup.emit('response', resp);\n            onComplete(data);\n          });\n        });\n      }\n    });\n  }\n  /**\n   * Returns true if the API request should be retried, given the error that was\n   * given the first time the request was attempted. This is used for rate limit\n   * related errors as well as intermittent server errors.\n   *\n   * @param {error} err - The API error to check if it is appropriate to retry.\n   * @return {boolean} True if the API request should be retried, false otherwise.\n   */\n  shouldRetryRequest(err) {\n    if (err) {\n      if ([429, 500, 502, 503].indexOf(err.code) !== -1) {\n        return true;\n      }\n      if (err.errors) {\n        for (const e of err.errors) {\n          const reason = e.reason;\n          if (reason === 'rateLimitExceeded') {\n            return true;\n          }\n          if (reason === 'userRateLimitExceeded') {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Get a function for making authenticated requests.\n   *\n   * @param {object} config - Configuration object.\n   * @param {boolean=} config.autoRetry - Automatically retry requests if the\n   *     response is related to rate limits or certain intermittent server\n   * errors. We will exponentially backoff subsequent requests by default.\n   * (default: true)\n   * @param {object=} config.credentials - Credentials object.\n   * @param {boolean=} config.customEndpoint - If true, just return the provided request options. Default: false.\n   * @param {string=} config.email - Account email address, required for PEM/P12 usage.\n   * @param {number=} config.maxRetries - Maximum number of automatic retries attempted before returning the error. (default: 3)\n   * @param {string=} config.keyFile - Path to a .json, .pem, or .p12 keyfile.\n   * @param {array} config.scopes - Array of scopes required for the API.\n   */\n  makeAuthenticatedRequestFactory(config) {\n    const googleAutoAuthConfig = extend({}, config);\n    if (googleAutoAuthConfig.projectId === '{{projectId}}') {\n      delete googleAutoAuthConfig.projectId;\n    }\n    const authClient = googleAutoAuthConfig.authClient || new google_auth_library_1.GoogleAuth(googleAutoAuthConfig);\n    function makeAuthenticatedRequest(reqOpts, optionsOrCallback) {\n      let stream;\n      const reqConfig = extend({}, config);\n      let activeRequest_;\n      if (!optionsOrCallback) {\n        stream = duplexify();\n        reqConfig.stream = stream;\n      }\n      const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : undefined;\n      const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : undefined;\n      const onAuthenticated = (err, authenticatedReqOpts) => {\n        const autoAuthFailed = err && err.message.indexOf('Could not load the default credentials') > -1;\n        if (autoAuthFailed) {\n          // Even though authentication failed, the API might not actually\n          // care.\n          authenticatedReqOpts = reqOpts;\n        }\n        if (!err || autoAuthFailed) {\n          // tslint:disable-next-line:no-any\n          let projectId = authClient._cachedProjectId;\n          if (config.projectId && config.projectId !== '{{projectId}}') {\n            projectId = config.projectId;\n          }\n          try {\n            authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);\n            err = null;\n          } catch (e) {\n            // A projectId was required, but we don't have one.\n            // Re-use the \"Could not load the default credentials error\" if\n            // auto auth failed.\n            err = err || e;\n          }\n        }\n        if (err) {\n          if (stream) {\n            stream.destroy(err);\n          } else {\n            const fn = options && options.onAuthenticated ? options.onAuthenticated : callback;\n            fn(err);\n          }\n          return;\n        }\n        if (options && options.onAuthenticated) {\n          options.onAuthenticated(null, authenticatedReqOpts);\n        } else {\n          activeRequest_ = util.makeRequest(authenticatedReqOpts, reqConfig, callback);\n        }\n      };\n      if (reqConfig.customEndpoint) {\n        // Using a custom API override. Do not use `google-auth-library` for\n        // authentication. (ex: connecting to a local Datastore server)\n        onAuthenticated(null, reqOpts);\n      } else {\n        authClient.authorizeRequest(reqOpts).then(res => {\n          const opts = extend(true, {}, reqOpts, res);\n          onAuthenticated(null, opts);\n        }, err => {\n          onAuthenticated(err);\n        });\n      }\n      if (stream) {\n        return stream;\n      }\n      return {\n        abort() {\n          setImmediate(() => {\n            if (activeRequest_) {\n              activeRequest_.abort();\n              activeRequest_ = null;\n            }\n          });\n        }\n      };\n    }\n    const mar = makeAuthenticatedRequest;\n    mar.getCredentials = authClient.getCredentials.bind(authClient);\n    mar.authClient = authClient;\n    return mar;\n  }\n  /**\n   * Make a request through the `retryRequest` module with built-in error\n   * handling and exponential back off.\n   *\n   * @param {object} reqOpts - Request options in the format `request` expects.\n   * @param {object=} config - Configuration object.\n   * @param {boolean=} config.autoRetry - Automatically retry requests if the\n   *     response is related to rate limits or certain intermittent server\n   * errors. We will exponentially backoff subsequent requests by default.\n   * (default: true)\n   * @param {number=} config.maxRetries - Maximum number of automatic retries\n   *     attempted before returning the error. (default: 3)\n   * @param {object=} config.request - HTTP module for request calls.\n   * @param {function} callback - The callback function.\n   */\n  makeRequest(reqOpts, config, callback) {\n    const options = {\n      request: config.request.defaults(requestDefaults),\n      retries: config.autoRetry !== false ? config.maxRetries || 3 : 0,\n      shouldRetryFn(httpRespMessage) {\n        const err = util.parseHttpRespMessage(httpRespMessage).err;\n        return err && util.shouldRetryRequest(err);\n      }\n    };\n    if (typeof reqOpts.maxRetries === 'number') {\n      options.retries = reqOpts.maxRetries;\n    }\n    if (!config.stream) {\n      return retryRequest(reqOpts, options, (err, response, body) => {\n        util.handleResp(err, response, body, callback);\n      });\n    }\n    const dup = config.stream;\n    // tslint:disable-next-line:no-any\n    let requestStream;\n    const isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';\n    if (isGetRequest) {\n      requestStream = retryRequest(reqOpts, options);\n      dup.setReadable(requestStream);\n    } else {\n      // Streaming writable HTTP requests cannot be retried.\n      requestStream = options.request(reqOpts);\n      dup.setWritable(requestStream);\n    }\n    // Replay the Request events back to the stream.\n    requestStream.on('error', dup.destroy.bind(dup)).on('response', dup.emit.bind(dup, 'response')).on('complete', dup.emit.bind(dup, 'complete'));\n    dup.abort = requestStream.abort;\n    return dup;\n  }\n  /**\n   * Decorate the options about to be made in a request.\n   *\n   * @param {object} reqOpts - The options to be passed to `request`.\n   * @param {string} projectId - The project ID.\n   * @return {object} reqOpts - The decorated reqOpts.\n   */\n  decorateRequest(reqOpts, projectId) {\n    delete reqOpts.autoPaginate;\n    delete reqOpts.autoPaginateVal;\n    delete reqOpts.objectMode;\n    if (reqOpts.qs !== null && typeof reqOpts.qs === 'object') {\n      delete reqOpts.qs.autoPaginate;\n      delete reqOpts.qs.autoPaginateVal;\n      reqOpts.qs = projectify_1.replaceProjectIdToken(reqOpts.qs, projectId);\n    }\n    if (Array.isArray(reqOpts.multipart)) {\n      reqOpts.multipart = reqOpts.multipart.map(part => {\n        return projectify_1.replaceProjectIdToken(part, projectId);\n      });\n    }\n    if (reqOpts.json !== null && typeof reqOpts.json === 'object') {\n      delete reqOpts.json.autoPaginate;\n      delete reqOpts.json.autoPaginateVal;\n      reqOpts.json = projectify_1.replaceProjectIdToken(reqOpts.json, projectId);\n    }\n    reqOpts.uri = projectify_1.replaceProjectIdToken(reqOpts.uri, projectId);\n    return reqOpts;\n  }\n  // tslint:disable-next-line:no-any\n  isCustomType(unknown, module) {\n    function getConstructorName(obj) {\n      return obj.constructor && obj.constructor.name.toLowerCase();\n    }\n    const moduleNameParts = module.split('/');\n    const parentModuleName = moduleNameParts[0] && moduleNameParts[0].toLowerCase();\n    const subModuleName = moduleNameParts[1] && moduleNameParts[1].toLowerCase();\n    if (subModuleName && getConstructorName(unknown) !== subModuleName) {\n      return false;\n    }\n    let walkingModule = unknown;\n    while (true) {\n      if (getConstructorName(walkingModule) === parentModuleName) {\n        return true;\n      }\n      walkingModule = walkingModule.parent;\n      if (!walkingModule) {\n        return false;\n      }\n    }\n  }\n  /**\n   * Create a properly-formatted User-Agent string from a package.json file.\n   *\n   * @param {object} packageJson - A module's package.json file.\n   * @return {string} userAgent - The formatted User-Agent string.\n   */\n  getUserAgentFromPackageJson(packageJson) {\n    const hyphenatedPackageName = packageJson.name.replace('@google-cloud', 'gcloud-node') // For legacy purposes.\n    .replace('/', '-'); // For UA spec-compliance purposes.\n    return hyphenatedPackageName + '/' + packageJson.version;\n  }\n  /**\n   * Given two parameters, figure out if this is either:\n   *  - Just a callback function\n   *  - An options object, and then a callback function\n   * @param optionsOrCallback An options object or callback.\n   * @param cb A potentially undefined callback.\n   */\n  maybeOptionsOrCallback(optionsOrCallback, cb) {\n    return typeof optionsOrCallback === 'function' ? [{}, optionsOrCallback] : [optionsOrCallback, cb];\n  }\n}\nexports.Util = Util;\nconst util = new Util();\nexports.util = util;","map":{"version":3,"names":["require","Object","defineProperty","exports","value","projectify_1","duplexify","ent","extend","google_auth_library_1","retryRequest","stream_1","requestDefaults","timeout","gzip","forever","pool","maxSockets","Infinity","ApiError","Error","constructor","errorBodyOrMessage","message","errorBody","code","errors","response","JSON","parse","body","error","e","createMultiErrorMessage","err","messages","Set","add","length","forEach","decode","toString","messageArr","Array","from","map","i","unshift","push","join","PartialFailureError","b","errorObject","name","Util","noop","handleResp","resp","callback","util","parsedResp","parseHttpRespMessage","parseHttpRespBody","httpRespMessage","parsedHttpRespMessage","statusCode","statusMessage","parsedHttpRespBody","makeWritableStream","dup","options","onComplete","writeStream","PassThrough","setWritable","defaultReqOpts","method","qs","uploadType","maxRetries","metadata","reqOpts","request","multipart","stringify","contentType","makeAuthenticatedRequest","onAuthenticated","authenticatedReqOpts","destroy","requestModule","defaults","data","emit","shouldRetryRequest","indexOf","reason","makeAuthenticatedRequestFactory","config","googleAutoAuthConfig","projectId","authClient","GoogleAuth","optionsOrCallback","stream","reqConfig","activeRequest_","undefined","autoAuthFailed","_cachedProjectId","decorateRequest","fn","makeRequest","customEndpoint","authorizeRequest","then","res","opts","abort","setImmediate","mar","getCredentials","bind","retries","autoRetry","shouldRetryFn","requestStream","isGetRequest","toUpperCase","setReadable","on","autoPaginate","autoPaginateVal","objectMode","replaceProjectIdToken","isArray","part","json","uri","isCustomType","unknown","module","getConstructorName","obj","toLowerCase","moduleNameParts","split","parentModuleName","subModuleName","walkingModule","parent","getUserAgentFromPackageJson","packageJson","hyphenatedPackageName","replace","version","maybeOptionsOrCallback","cb"],"sources":["/var/www/html/project/Dash_Vuexy-master/node_modules/@google-cloud/common/build/src/util.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*!\n * @module common/util\n */\nconst projectify_1 = require(\"@google-cloud/projectify\");\nconst duplexify = require(\"duplexify\");\nconst ent = require(\"ent\");\nconst extend = require(\"extend\");\nconst google_auth_library_1 = require(\"google-auth-library\");\nconst retryRequest = require(\"retry-request\");\nconst stream_1 = require(\"stream\");\nconst requestDefaults = {\n    timeout: 60000,\n    gzip: true,\n    forever: true,\n    pool: {\n        maxSockets: Infinity,\n    },\n};\n/**\n * Custom error type for API errors.\n *\n * @param {object} errorBody - Error object.\n */\nclass ApiError extends Error {\n    constructor(errorBodyOrMessage) {\n        super();\n        if (typeof errorBodyOrMessage !== 'object') {\n            this.message = errorBodyOrMessage || '';\n            return;\n        }\n        const errorBody = errorBodyOrMessage;\n        this.code = errorBody.code;\n        this.errors = errorBody.errors;\n        this.response = errorBody.response;\n        try {\n            this.errors = JSON.parse(this.response.body).error.errors;\n        }\n        catch (e) {\n            this.errors = errorBody.errors;\n        }\n        this.message = ApiError.createMultiErrorMessage(errorBody, this.errors);\n    }\n    /**\n     * Pieces together an error message by combining all unique error messages\n     * returned from a single GoogleError\n     *\n     * @private\n     *\n     * @param {GoogleErrorBody} err The original error.\n     * @param {GoogleInnerError[]} [errors] Inner errors, if any.\n     * @returns {string}\n     */\n    static createMultiErrorMessage(err, errors) {\n        const messages = new Set();\n        if (err.message) {\n            messages.add(err.message);\n        }\n        if (errors && errors.length) {\n            errors.forEach(({ message }) => messages.add(message));\n        }\n        else if (err.response && err.response.body) {\n            messages.add(ent.decode(err.response.body.toString()));\n        }\n        else if (!err.message) {\n            messages.add('A failure occurred during this request.');\n        }\n        let messageArr = Array.from(messages);\n        if (messageArr.length > 1) {\n            messageArr = messageArr.map((message, i) => `    ${i + 1}. ${message}`);\n            messageArr.unshift('Multiple errors occurred during the request. Please see the `errors` array for complete details.\\n');\n            messageArr.push('\\n');\n        }\n        return messageArr.join('\\n');\n    }\n}\nexports.ApiError = ApiError;\n/**\n * Custom error type for partial errors returned from the API.\n *\n * @param {object} b - Error object.\n */\nclass PartialFailureError extends Error {\n    constructor(b) {\n        super();\n        const errorObject = b;\n        this.errors = errorObject.errors;\n        this.name = 'PartialFailureError';\n        this.response = errorObject.response;\n        this.message = ApiError.createMultiErrorMessage(errorObject, this.errors);\n    }\n}\nexports.PartialFailureError = PartialFailureError;\nclass Util {\n    constructor() {\n        this.ApiError = ApiError;\n        this.PartialFailureError = PartialFailureError;\n    }\n    /**\n     * No op.\n     *\n     * @example\n     * function doSomething(callback) {\n     *   callback = callback || noop;\n     * }\n     */\n    noop() { }\n    /**\n     * Uniformly process an API response.\n     *\n     * @param {*} err - Error value.\n     * @param {*} resp - Response value.\n     * @param {*} body - Body value.\n     * @param {function} callback - The callback function.\n     */\n    handleResp(err, resp, body, callback) {\n        callback = callback || util.noop;\n        const parsedResp = extend(true, { err: err || null }, resp && util.parseHttpRespMessage(resp), body && util.parseHttpRespBody(body));\n        // Assign the parsed body to resp.body, even if { json: false } was passed\n        // as a request option.\n        // We assume that nobody uses the previously unparsed value of resp.body.\n        if (!parsedResp.err && resp && typeof parsedResp.body === 'object') {\n            parsedResp.resp.body = parsedResp.body;\n        }\n        callback(parsedResp.err, parsedResp.body, parsedResp.resp);\n    }\n    /**\n     * Sniff an incoming HTTP response message for errors.\n     *\n     * @param {object} httpRespMessage - An incoming HTTP response message from `request`.\n     * @return {object} parsedHttpRespMessage - The parsed response.\n     * @param {?error} parsedHttpRespMessage.err - An error detected.\n     * @param {object} parsedHttpRespMessage.resp - The original response object.\n     */\n    parseHttpRespMessage(httpRespMessage) {\n        const parsedHttpRespMessage = {\n            resp: httpRespMessage,\n        };\n        if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) {\n            // Unknown error. Format according to ApiError standard.\n            parsedHttpRespMessage.err = new ApiError({\n                errors: new Array(),\n                code: httpRespMessage.statusCode,\n                message: httpRespMessage.statusMessage,\n                response: httpRespMessage,\n            });\n        }\n        return parsedHttpRespMessage;\n    }\n    /**\n     * Parse the response body from an HTTP request.\n     *\n     * @param {object} body - The response body.\n     * @return {object} parsedHttpRespMessage - The parsed response.\n     * @param {?error} parsedHttpRespMessage.err - An error detected.\n     * @param {object} parsedHttpRespMessage.body - The original body value provided\n     *     will try to be JSON.parse'd. If it's successful, the parsed value will\n     * be returned here, otherwise the original value.\n     */\n    parseHttpRespBody(body) {\n        const parsedHttpRespBody = {\n            body,\n        };\n        if (typeof body === 'string') {\n            try {\n                parsedHttpRespBody.body = JSON.parse(body);\n            }\n            catch (err) {\n                parsedHttpRespBody.err = new ApiError('Cannot parse JSON response');\n            }\n        }\n        if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) {\n            // Error from JSON API.\n            parsedHttpRespBody.err = new ApiError(parsedHttpRespBody.body.error);\n        }\n        return parsedHttpRespBody;\n    }\n    /**\n     * Take a Duplexify stream, fetch an authenticated connection header, and\n     * create an outgoing writable stream.\n     *\n     * @param {Duplexify} dup - Duplexify stream.\n     * @param {object} options - Configuration object.\n     * @param {module:common/connection} options.connection - A connection instance used to get a token with and send the request through.\n     * @param {object} options.metadata - Metadata to send at the head of the request.\n     * @param {object} options.request - Request object, in the format of a standard Node.js http.request() object.\n     * @param {string=} options.request.method - Default: \"POST\".\n     * @param {string=} options.request.qs.uploadType - Default: \"multipart\".\n     * @param {string=} options.streamContentType - Default: \"application/octet-stream\".\n     * @param {function} onComplete - Callback, executed after the writable Request stream has completed.\n     */\n    makeWritableStream(dup, options, onComplete) {\n        onComplete = onComplete || util.noop;\n        const writeStream = new stream_1.PassThrough();\n        dup.setWritable(writeStream);\n        const defaultReqOpts = {\n            method: 'POST',\n            qs: {\n                uploadType: 'multipart',\n            },\n            timeout: 0,\n            maxRetries: 0,\n        };\n        const metadata = options.metadata || {};\n        const reqOpts = extend(true, defaultReqOpts, options.request, {\n            multipart: [\n                {\n                    'Content-Type': 'application/json',\n                    body: JSON.stringify(metadata),\n                },\n                {\n                    'Content-Type': metadata.contentType ||\n                        'application/octet-stream',\n                    body: writeStream,\n                },\n            ],\n        });\n        options.makeAuthenticatedRequest(reqOpts, {\n            onAuthenticated(err, authenticatedReqOpts) {\n                if (err) {\n                    dup.destroy(err);\n                    return;\n                }\n                const request = options.requestModule.defaults(requestDefaults);\n                request(authenticatedReqOpts, (err, resp, body) => {\n                    util.handleResp(err, resp, body, (err, data) => {\n                        if (err) {\n                            dup.destroy(err);\n                            return;\n                        }\n                        dup.emit('response', resp);\n                        onComplete(data);\n                    });\n                });\n            },\n        });\n    }\n    /**\n     * Returns true if the API request should be retried, given the error that was\n     * given the first time the request was attempted. This is used for rate limit\n     * related errors as well as intermittent server errors.\n     *\n     * @param {error} err - The API error to check if it is appropriate to retry.\n     * @return {boolean} True if the API request should be retried, false otherwise.\n     */\n    shouldRetryRequest(err) {\n        if (err) {\n            if ([429, 500, 502, 503].indexOf(err.code) !== -1) {\n                return true;\n            }\n            if (err.errors) {\n                for (const e of err.errors) {\n                    const reason = e.reason;\n                    if (reason === 'rateLimitExceeded') {\n                        return true;\n                    }\n                    if (reason === 'userRateLimitExceeded') {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Get a function for making authenticated requests.\n     *\n     * @param {object} config - Configuration object.\n     * @param {boolean=} config.autoRetry - Automatically retry requests if the\n     *     response is related to rate limits or certain intermittent server\n     * errors. We will exponentially backoff subsequent requests by default.\n     * (default: true)\n     * @param {object=} config.credentials - Credentials object.\n     * @param {boolean=} config.customEndpoint - If true, just return the provided request options. Default: false.\n     * @param {string=} config.email - Account email address, required for PEM/P12 usage.\n     * @param {number=} config.maxRetries - Maximum number of automatic retries attempted before returning the error. (default: 3)\n     * @param {string=} config.keyFile - Path to a .json, .pem, or .p12 keyfile.\n     * @param {array} config.scopes - Array of scopes required for the API.\n     */\n    makeAuthenticatedRequestFactory(config) {\n        const googleAutoAuthConfig = extend({}, config);\n        if (googleAutoAuthConfig.projectId === '{{projectId}}') {\n            delete googleAutoAuthConfig.projectId;\n        }\n        const authClient = googleAutoAuthConfig.authClient || new google_auth_library_1.GoogleAuth(googleAutoAuthConfig);\n        function makeAuthenticatedRequest(reqOpts, optionsOrCallback) {\n            let stream;\n            const reqConfig = extend({}, config);\n            let activeRequest_;\n            if (!optionsOrCallback) {\n                stream = duplexify();\n                reqConfig.stream = stream;\n            }\n            const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : undefined;\n            const callback = typeof optionsOrCallback === 'function' ?\n                optionsOrCallback :\n                undefined;\n            const onAuthenticated = (err, authenticatedReqOpts) => {\n                const autoAuthFailed = err &&\n                    err.message.indexOf('Could not load the default credentials') >\n                        -1;\n                if (autoAuthFailed) {\n                    // Even though authentication failed, the API might not actually\n                    // care.\n                    authenticatedReqOpts = reqOpts;\n                }\n                if (!err || autoAuthFailed) {\n                    // tslint:disable-next-line:no-any\n                    let projectId = authClient._cachedProjectId;\n                    if (config.projectId && config.projectId !== '{{projectId}}') {\n                        projectId = config.projectId;\n                    }\n                    try {\n                        authenticatedReqOpts =\n                            util.decorateRequest(authenticatedReqOpts, projectId);\n                        err = null;\n                    }\n                    catch (e) {\n                        // A projectId was required, but we don't have one.\n                        // Re-use the \"Could not load the default credentials error\" if\n                        // auto auth failed.\n                        err = err || e;\n                    }\n                }\n                if (err) {\n                    if (stream) {\n                        stream.destroy(err);\n                    }\n                    else {\n                        const fn = options && options.onAuthenticated ?\n                            options.onAuthenticated :\n                            callback;\n                        fn(err);\n                    }\n                    return;\n                }\n                if (options && options.onAuthenticated) {\n                    options.onAuthenticated(null, authenticatedReqOpts);\n                }\n                else {\n                    activeRequest_ =\n                        util.makeRequest(authenticatedReqOpts, reqConfig, callback);\n                }\n            };\n            if (reqConfig.customEndpoint) {\n                // Using a custom API override. Do not use `google-auth-library` for\n                // authentication. (ex: connecting to a local Datastore server)\n                onAuthenticated(null, reqOpts);\n            }\n            else {\n                authClient.authorizeRequest(reqOpts).then(res => {\n                    const opts = extend(true, {}, reqOpts, res);\n                    onAuthenticated(null, opts);\n                }, err => {\n                    onAuthenticated(err);\n                });\n            }\n            if (stream) {\n                return stream;\n            }\n            return {\n                abort() {\n                    setImmediate(() => {\n                        if (activeRequest_) {\n                            activeRequest_.abort();\n                            activeRequest_ = null;\n                        }\n                    });\n                },\n            };\n        }\n        const mar = makeAuthenticatedRequest;\n        mar.getCredentials = authClient.getCredentials.bind(authClient);\n        mar.authClient = authClient;\n        return mar;\n    }\n    /**\n     * Make a request through the `retryRequest` module with built-in error\n     * handling and exponential back off.\n     *\n     * @param {object} reqOpts - Request options in the format `request` expects.\n     * @param {object=} config - Configuration object.\n     * @param {boolean=} config.autoRetry - Automatically retry requests if the\n     *     response is related to rate limits or certain intermittent server\n     * errors. We will exponentially backoff subsequent requests by default.\n     * (default: true)\n     * @param {number=} config.maxRetries - Maximum number of automatic retries\n     *     attempted before returning the error. (default: 3)\n     * @param {object=} config.request - HTTP module for request calls.\n     * @param {function} callback - The callback function.\n     */\n    makeRequest(reqOpts, config, callback) {\n        const options = {\n            request: config.request.defaults(requestDefaults),\n            retries: config.autoRetry !== false ? config.maxRetries || 3 : 0,\n            shouldRetryFn(httpRespMessage) {\n                const err = util.parseHttpRespMessage(httpRespMessage).err;\n                return err && util.shouldRetryRequest(err);\n            },\n        };\n        if (typeof reqOpts.maxRetries === 'number') {\n            options.retries = reqOpts.maxRetries;\n        }\n        if (!config.stream) {\n            return retryRequest(reqOpts, options, (err, response, body) => {\n                util.handleResp(err, response, body, callback);\n            });\n        }\n        const dup = config.stream;\n        // tslint:disable-next-line:no-any\n        let requestStream;\n        const isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';\n        if (isGetRequest) {\n            requestStream = retryRequest(reqOpts, options);\n            dup.setReadable(requestStream);\n        }\n        else {\n            // Streaming writable HTTP requests cannot be retried.\n            requestStream = options.request(reqOpts);\n            dup.setWritable(requestStream);\n        }\n        // Replay the Request events back to the stream.\n        requestStream.on('error', dup.destroy.bind(dup))\n            .on('response', dup.emit.bind(dup, 'response'))\n            .on('complete', dup.emit.bind(dup, 'complete'));\n        dup.abort = requestStream.abort;\n        return dup;\n    }\n    /**\n     * Decorate the options about to be made in a request.\n     *\n     * @param {object} reqOpts - The options to be passed to `request`.\n     * @param {string} projectId - The project ID.\n     * @return {object} reqOpts - The decorated reqOpts.\n     */\n    decorateRequest(reqOpts, projectId) {\n        delete reqOpts.autoPaginate;\n        delete reqOpts.autoPaginateVal;\n        delete reqOpts.objectMode;\n        if (reqOpts.qs !== null && typeof reqOpts.qs === 'object') {\n            delete reqOpts.qs.autoPaginate;\n            delete reqOpts.qs.autoPaginateVal;\n            reqOpts.qs = projectify_1.replaceProjectIdToken(reqOpts.qs, projectId);\n        }\n        if (Array.isArray(reqOpts.multipart)) {\n            reqOpts.multipart = reqOpts.multipart.map(part => {\n                return projectify_1.replaceProjectIdToken(part, projectId);\n            });\n        }\n        if (reqOpts.json !== null && typeof reqOpts.json === 'object') {\n            delete reqOpts.json.autoPaginate;\n            delete reqOpts.json.autoPaginateVal;\n            reqOpts.json = projectify_1.replaceProjectIdToken(reqOpts.json, projectId);\n        }\n        reqOpts.uri = projectify_1.replaceProjectIdToken(reqOpts.uri, projectId);\n        return reqOpts;\n    }\n    // tslint:disable-next-line:no-any\n    isCustomType(unknown, module) {\n        function getConstructorName(obj) {\n            return obj.constructor && obj.constructor.name.toLowerCase();\n        }\n        const moduleNameParts = module.split('/');\n        const parentModuleName = moduleNameParts[0] && moduleNameParts[0].toLowerCase();\n        const subModuleName = moduleNameParts[1] && moduleNameParts[1].toLowerCase();\n        if (subModuleName && getConstructorName(unknown) !== subModuleName) {\n            return false;\n        }\n        let walkingModule = unknown;\n        while (true) {\n            if (getConstructorName(walkingModule) === parentModuleName) {\n                return true;\n            }\n            walkingModule = walkingModule.parent;\n            if (!walkingModule) {\n                return false;\n            }\n        }\n    }\n    /**\n     * Create a properly-formatted User-Agent string from a package.json file.\n     *\n     * @param {object} packageJson - A module's package.json file.\n     * @return {string} userAgent - The formatted User-Agent string.\n     */\n    getUserAgentFromPackageJson(packageJson) {\n        const hyphenatedPackageName = packageJson.name\n            .replace('@google-cloud', 'gcloud-node') // For legacy purposes.\n            .replace('/', '-'); // For UA spec-compliance purposes.\n        return hyphenatedPackageName + '/' + packageJson.version;\n    }\n    /**\n     * Given two parameters, figure out if this is either:\n     *  - Just a callback function\n     *  - An options object, and then a callback function\n     * @param optionsOrCallback An options object or callback.\n     * @param cb A potentially undefined callback.\n     */\n    maybeOptionsOrCallback(optionsOrCallback, cb) {\n        return typeof optionsOrCallback === 'function' ?\n            [{}, optionsOrCallback] :\n            [optionsOrCallback, cb];\n    }\n}\nexports.Util = Util;\nconst util = new Util();\nexports.util = util;\n//# sourceMappingURL=util.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}