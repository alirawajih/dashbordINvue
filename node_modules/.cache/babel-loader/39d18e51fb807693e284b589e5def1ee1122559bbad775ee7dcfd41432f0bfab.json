{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst grpc = require(\"grpc\");\nconst channel_ref_1 = require(\"./channel_ref\");\nconst CLIENT_CHANNEL_ID = 'grpc_gcp.client_channel.id';\n/**\n * A channel management factory that implements grpc.Channel APIs.\n */\nclass GcpChannelFactory {\n  /**\n   * @param address The address of the server to connect to.\n   * @param credentials Channel credentials to use when connecting\n   * @param options A map of channel options.\n   */\n  constructor(address, credentials,\n  // tslint:disable-next-line:no-any options can be any object\n  options) {\n    this.methodToAffinity = {};\n    this.affinityKeyToChannelRef = {};\n    this.channelRefs = [];\n    if (!options) {\n      options = {};\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('Channel options must be an object with string keys and integer or string values');\n    }\n    this.maxSize = 10;\n    this.maxConcurrentStreamsLowWatermark = 100;\n    const gcpApiConfig = options.gcpApiConfig;\n    if (gcpApiConfig) {\n      if (gcpApiConfig.channelPool) {\n        const channelPool = gcpApiConfig.channelPool;\n        if (channelPool.maxSize) this.maxSize = channelPool.maxSize;\n        if (channelPool.maxConcurrentStreamsLowWatermark) {\n          this.maxConcurrentStreamsLowWatermark = channelPool.maxConcurrentStreamsLowWatermark;\n        }\n      }\n      this.initMethodToAffinityMap(gcpApiConfig);\n    }\n    delete options.gcpApiConfig;\n    this.options = options;\n    this.target = address;\n    this.credentials = credentials;\n    // Initialize channel in the pool to avoid empty pool.\n    this.getChannelRef();\n  }\n  initMethodToAffinityMap(gcpApiConfig) {\n    const methodList = gcpApiConfig.method;\n    if (methodList) {\n      for (let i = 0; i < methodList.length; i++) {\n        const method = methodList[i];\n        const nameList = method.name;\n        if (nameList) {\n          for (let j = 0; j < nameList.length; j++) {\n            const methodName = nameList[j];\n            if (method.affinity) {\n              this.methodToAffinity[methodName] = method.affinity;\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Picks a grpc channel from the pool and wraps it with ChannelRef.\n   * @param affinityKey Affinity key to get the bound channel.\n   * @return Wrapper containing the grpc channel.\n   */\n  getChannelRef(affinityKey) {\n    if (affinityKey && this.affinityKeyToChannelRef[affinityKey]) {\n      // Chose an bound channel if affinityKey is specified.\n      return this.affinityKeyToChannelRef[affinityKey];\n    }\n    // Sort channel refs by active streams count.\n    this.channelRefs.sort((ref1, ref2) => {\n      return ref1.getActiveStreamsCount() - ref2.getActiveStreamsCount();\n    });\n    const size = this.channelRefs.length;\n    // Chose the channelRef that has the least busy channel.\n    if (size > 0 && this.channelRefs[0].getActiveStreamsCount() < this.maxConcurrentStreamsLowWatermark) {\n      return this.channelRefs[0];\n    }\n    // If all existing channels are busy, and channel pool still has capacity,\n    // create a new channel in the pool.\n    if (size < this.maxSize) {\n      const channelOptions = Object.assign({\n        [CLIENT_CHANNEL_ID]: size\n      }, this.options);\n      const grpcChannel = new grpc.Channel(this.target, this.credentials, channelOptions);\n      const channelRef = new channel_ref_1.ChannelRef(grpcChannel, size);\n      this.channelRefs.push(channelRef);\n      return channelRef;\n    } else {\n      return this.channelRefs[0];\n    }\n  }\n  /**\n   * Get AffinityConfig associated with a certain method.\n   * @param methodName Method name of the request.\n   */\n  getAffinityConfig(methodName) {\n    return this.methodToAffinity[methodName];\n  }\n  /**\n   * Bind channel with affinity key.\n   * @param channelRef ChannelRef instance that contains the grpc channel.\n   * @param affinityKey The affinity key used for binding the channel.\n   */\n  bind(channelRef, affinityKey) {\n    if (!affinityKey || !channelRef) return;\n    const existingChannelRef = this.affinityKeyToChannelRef[affinityKey];\n    if (!existingChannelRef) {\n      this.affinityKeyToChannelRef[affinityKey] = channelRef;\n    }\n    this.affinityKeyToChannelRef[affinityKey].affinityCountIncr();\n  }\n  /**\n   * Unbind channel with affinity key.\n   * @param boundKey Affinity key bound to a channel.\n   */\n  unbind(boundKey) {\n    if (!boundKey) return;\n    const boundChannelRef = this.affinityKeyToChannelRef[boundKey];\n    if (boundChannelRef) {\n      boundChannelRef.affinityCountDecr();\n      if (boundChannelRef.getAffinityCount() <= 0) {\n        delete this.affinityKeyToChannelRef[boundKey];\n      }\n    }\n  }\n  /**\n   * Close all channels in the channel pool.\n   */\n  close() {\n    this.channelRefs.forEach(ref => {\n      ref.getChannel().close();\n    });\n  }\n  getTarget() {\n    return this.target;\n  }\n  /**\n   * Get the current connectivity state of the channel pool.\n   * @param tryToConnect If true, the channel will start connecting if it is\n   *     idle. Otherwise, idle channels will only start connecting when a\n   *     call starts.\n   * @return connectivity state of channel pool.\n   */\n  getConnectivityState(tryToConnect) {\n    let ready = 0;\n    let idle = 0;\n    let connecting = 0;\n    let transientFailure = 0;\n    let shutdown = 0;\n    for (let i = 0; i < this.channelRefs.length; i++) {\n      const grpcChannel = this.channelRefs[i].getChannel();\n      const state = grpcChannel.getConnectivityState(tryToConnect);\n      switch (state) {\n        case grpc.connectivityState.READY:\n          ready++;\n          break;\n        case grpc.connectivityState.SHUTDOWN:\n          shutdown++;\n          break;\n        case grpc.connectivityState.TRANSIENT_FAILURE:\n          transientFailure++;\n          break;\n        case grpc.connectivityState.CONNECTING:\n          connecting++;\n          break;\n        case grpc.connectivityState.IDLE:\n          idle++;\n          break;\n        default:\n          break;\n      }\n    }\n    if (ready > 0) {\n      return grpc.connectivityState.READY;\n    } else if (connecting > 0) {\n      return grpc.connectivityState.CONNECTING;\n    } else if (transientFailure > 0) {\n      return grpc.connectivityState.TRANSIENT_FAILURE;\n    } else if (idle > 0) {\n      return grpc.connectivityState.IDLE;\n    } else if (shutdown > 0) {\n      return grpc.connectivityState.SHUTDOWN;\n    }\n    throw new Error('Cannot get connectivity state because no channel provides valid state.');\n  }\n  /**\n   * Watch for connectivity state changes. Currently This function will throw\n   * not implemented error because the implementation requires lot of work but\n   * has little use cases.\n   * @param currentState The state to watch for transitions from. This should\n   *     always be populated by calling getConnectivityState immediately before.\n   * @param deadline A deadline for waiting for a state change\n   * @param callback Called with no error when the state changes, or with an\n   *     error if the deadline passes without a state change\n   */\n  watchConnectivityState(currentState, deadline, callback) {\n    throw new Error('Function watchConnectivityState not implemented!');\n  }\n  /**\n   * Create a call object. This function will not be called when using\n   * grpc.Client class. But since it's a public function of grpc.Channel,\n   * It needs to be implemented for potential use cases.\n   * @param method The full method string to request.\n   * @param deadline The call deadline.\n   * @param host A host string override for making the request.\n   * @param parentCall A server call to propagate some information from.\n   * @param propagateFlags A bitwise combination of elements of\n   *     {@link grpc.propagate} that indicates what information to propagate\n   *     from parentCall.\n   * @return a grpc call object.\n   */\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    const grpcChannel = this.getChannelRef().getChannel();\n    return grpcChannel.createCall(method, deadline, host, parentCall, propagateFlags);\n  }\n}\nexports.GcpChannelFactory = GcpChannelFactory;","map":{"version":3,"names":["require","grpc","channel_ref_1","CLIENT_CHANNEL_ID","GcpChannelFactory","constructor","address","credentials","options","methodToAffinity","affinityKeyToChannelRef","channelRefs","TypeError","maxSize","maxConcurrentStreamsLowWatermark","gcpApiConfig","channelPool","initMethodToAffinityMap","target","getChannelRef","methodList","method","i","length","nameList","name","j","methodName","affinity","affinityKey","sort","ref1","ref2","getActiveStreamsCount","size","channelOptions","Object","assign","grpcChannel","Channel","channelRef","ChannelRef","push","getAffinityConfig","bind","existingChannelRef","affinityCountIncr","unbind","boundKey","boundChannelRef","affinityCountDecr","getAffinityCount","close","forEach","ref","getChannel","getTarget","getConnectivityState","tryToConnect","ready","idle","connecting","transientFailure","shutdown","state","connectivityState","READY","SHUTDOWN","TRANSIENT_FAILURE","CONNECTING","IDLE","Error","watchConnectivityState","currentState","deadline","callback","createCall","host","parentCall","propagateFlags","exports"],"sources":["../../src/gcp_channel_factory.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}