{"ast":null,"code":"import { ref as t, inject as i, provide as n, defineComponent as r } from \"vue\";\nimport { PureAbility as o } from \"@casl/ability\";\nfunction reactiveAbility(i) {\n  if (i.hasOwnProperty(\"possibleRulesFor\")) return i;\n  const n = t(true);\n  i.on(\"updated\", () => {\n    n.value = !n.value;\n  });\n  const r = i.possibleRulesFor.bind(i);\n  i.possibleRulesFor = (t, i) => {\n    n.value = n.value;\n    return r(t, i);\n  };\n  i.can = i.can.bind(i);\n  i.cannot = i.cannot.bind(i);\n  return i;\n}\nconst e = Symbol(\"ability\");\nfunction useAbility() {\n  const t = i(e);\n  if (!t) throw new Error(\"Cannot inject Ability instance because it was not provided\");\n  return t;\n}\nfunction provideAbility(t) {\n  n(e, reactiveAbility(t));\n}\nfunction s(t) {\n  if (void 0 !== t.a) return \"a\";\n  if (void 0 !== t.this) return \"this\";\n  if (void 0 !== t.an) return \"an\";\n  return \"\";\n}\nconst u = r({\n  name: \"Can\",\n  props: {\n    I: String,\n    do: String,\n    a: [String, Function],\n    an: [String, Function],\n    this: [String, Function, Object],\n    on: [String, Function, Object],\n    not: Boolean,\n    passThrough: Boolean,\n    field: String\n  },\n  setup(t, {\n    slots: i\n  }) {\n    const n = t;\n    let r = \"do\";\n    let o = \"on\";\n    if (void 0 === n[r]) {\n      r = \"I\";\n      o = s(t);\n    }\n    if (!n[r]) throw new Error(\"Neither `I` nor `do` prop was passed in <Can>\");\n    if (!i.default) throw new Error(\"Expects to receive default slot\");\n    const e = useAbility();\n    return () => {\n      const s = e.can(n[r], n[o], n.field);\n      const u = t.not ? !s : s;\n      if (!t.passThrough) return u ? i.default() : null;\n      return i.default({\n        allowed: u,\n        ability: e\n      });\n    };\n  }\n});\nfunction l(t, i, n) {\n  if (!i || !(i instanceof o)) throw new Error(\"Please provide an Ability instance to abilitiesPlugin plugin\");\n  t.provide(e, reactiveAbility(i));\n  if (n && n.useGlobalProperties) {\n    t.config.globalProperties.$ability = i;\n    t.config.globalProperties.$can = i.can.bind(i);\n  }\n}\nexport { e as ABILITY_TOKEN, u as Can, l as abilitiesPlugin, provideAbility, useAbility };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import{ref as t,inject as i,provide as n,defineComponent as r}from\"vue\";import{PureAbility as o}from\"@casl/ability\";function reactiveAbility(i){if(i.hasOwnProperty(\"possibleRulesFor\"))return i;const n=t(true);i.on(\"updated\",(()=>{n.value=!n.value}));const r=i.possibleRulesFor.bind(i);i.possibleRulesFor=(t,i)=>{n.value=n.value;return r(t,i)};i.can=i.can.bind(i);i.cannot=i.cannot.bind(i);return i}const e=Symbol(\"ability\");function useAbility(){const t=i(e);if(!t)throw new Error(\"Cannot inject Ability instance because it was not provided\");return t}function provideAbility(t){n(e,reactiveAbility(t))}function s(t){if(void 0!==t.a)return\"a\";if(void 0!==t.this)return\"this\";if(void 0!==t.an)return\"an\";return\"\"}const u=r({name:\"Can\",props:{I:String,do:String,a:[String,Function],an:[String,Function],this:[String,Function,Object],on:[String,Function,Object],not:Boolean,passThrough:Boolean,field:String},setup(t,{slots:i}){const n=t;let r=\"do\";let o=\"on\";if(void 0===n[r]){r=\"I\";o=s(t)}if(!n[r])throw new Error(\"Neither `I` nor `do` prop was passed in <Can>\");if(!i.default)throw new Error(\"Expects to receive default slot\");const e=useAbility();return()=>{const s=e.can(n[r],n[o],n.field);const u=t.not?!s:s;if(!t.passThrough)return u?i.default():null;return i.default({allowed:u,ability:e})}}});function l(t,i,n){if(!i||!(i instanceof o))throw new Error(\"Please provide an Ability instance to abilitiesPlugin plugin\");t.provide(e,reactiveAbility(i));if(n&&n.useGlobalProperties){t.config.globalProperties.$ability=i;t.config.globalProperties.$can=i.can.bind(i)}}export{e as ABILITY_TOKEN,u as Can,l as abilitiesPlugin,provideAbility,useAbility};\n//# sourceMappingURL=index.mjs.map\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}