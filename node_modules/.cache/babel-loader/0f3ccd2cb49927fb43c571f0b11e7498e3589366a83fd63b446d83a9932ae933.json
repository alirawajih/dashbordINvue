{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/web.immediate.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst events_1 = require(\"events\");\nconst http2 = require(\"http2\");\nconst tls_1 = require(\"tls\");\nconst url = require(\"url\");\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\nconst call_stream_1 = require(\"./call-stream\");\nconst channel_options_1 = require(\"./channel-options\");\nconst compression_filter_1 = require(\"./compression-filter\");\nconst constants_1 = require(\"./constants\");\nconst deadline_filter_1 = require(\"./deadline-filter\");\nconst filter_stack_1 = require(\"./filter-stack\");\nconst metadata_status_filter_1 = require(\"./metadata-status-filter\");\nconst subchannel_1 = require(\"./subchannel\");\nconst {\n  version: clientVersion\n} = require('../../package.json');\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT\n} = http2.constants;\nvar ConnectivityState;\n(function (ConnectivityState) {\n  ConnectivityState[ConnectivityState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n  ConnectivityState[ConnectivityState[\"READY\"] = 1] = \"READY\";\n  ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n  ConnectivityState[ConnectivityState[\"IDLE\"] = 3] = \"IDLE\";\n  ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\nclass Http2Channel extends events_1.EventEmitter {\n  constructor(address, credentials, options) {\n    super();\n    this.credentials = credentials;\n    this.options = options;\n    this.connectivityState = ConnectivityState.IDLE;\n    // Helper Promise object only used in the implementation of connect().\n    this.connecting = null;\n    /* For now, we have up to one subchannel, which will exist as long as we are\n     * connecting or trying to connect */\n    this.subChannel = null;\n    this.subChannelConnectCallback = () => {};\n    this.subChannelCloseCallback = () => {};\n    this.currentBackoff = INITIAL_BACKOFF_MS;\n    for (const option in options) {\n      if (options.hasOwnProperty(option)) {\n        if (!channel_options_1.recognizedOptions.hasOwnProperty(option)) {\n          console.warn(`Unrecognized channel argument '${option}' will be ignored.`);\n        }\n      }\n    }\n    if (credentials._isSecure()) {\n      this.target = new url.URL(`https://${address}`);\n    } else {\n      this.target = new url.URL(`http://${address}`);\n    }\n    // TODO(murgatroid99): Add more centralized handling of channel options\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'];\n    } else {\n      this.defaultAuthority = this.target.host;\n    }\n    this.filterStackFactory = new filter_stack_1.FilterStackFactory([new call_credentials_filter_1.CallCredentialsFilterFactory(this), new deadline_filter_1.DeadlineFilterFactory(this), new metadata_status_filter_1.MetadataStatusFilterFactory(this), new compression_filter_1.CompressionFilterFactory(this)]);\n    this.currentBackoffDeadline = new Date();\n    /* The only purpose of these lines is to ensure that this.backoffTimerId has\n     * a value of type NodeJS.Timer. */\n    this.backoffTimerId = setTimeout(() => {}, 0);\n    // Build user-agent string.\n    this.userAgent = [options['grpc.primary_user_agent'], `grpc-node-js/${clientVersion}`, options['grpc.secondary_user_agent']].filter(e => e).join(' '); // remove falsey values first\n  }\n\n  handleStateChange(oldState, newState) {\n    const now = new Date();\n    switch (newState) {\n      case ConnectivityState.CONNECTING:\n        if (oldState === ConnectivityState.IDLE) {\n          this.currentBackoff = INITIAL_BACKOFF_MS;\n          this.currentBackoffDeadline = new Date(now.getTime() + INITIAL_BACKOFF_MS);\n        } else if (oldState === ConnectivityState.TRANSIENT_FAILURE) {\n          this.currentBackoff = Math.min(this.currentBackoff * BACKOFF_MULTIPLIER, MAX_BACKOFF_MS);\n          const jitterMagnitude = BACKOFF_JITTER * this.currentBackoff;\n          this.currentBackoffDeadline = new Date(now.getTime() + this.currentBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude));\n        }\n        this.startConnecting();\n        break;\n      case ConnectivityState.READY:\n        this.emit('connect');\n        break;\n      case ConnectivityState.TRANSIENT_FAILURE:\n        this.subChannel = null;\n        this.backoffTimerId = setTimeout(() => {\n          this.transitionToState([ConnectivityState.TRANSIENT_FAILURE], ConnectivityState.CONNECTING);\n        }, this.currentBackoffDeadline.getTime() - now.getTime());\n        break;\n      case ConnectivityState.IDLE:\n      case ConnectivityState.SHUTDOWN:\n        if (this.subChannel) {\n          this.subChannel.close();\n          this.subChannel.removeListener('connect', this.subChannelConnectCallback);\n          this.subChannel.removeListener('close', this.subChannelCloseCallback);\n          this.subChannel = null;\n          this.emit('shutdown');\n          clearTimeout(this.backoffTimerId);\n        }\n        break;\n      default:\n        throw new Error('This should never happen');\n    }\n  }\n  // Transition from any of a set of oldStates to a specific newState\n  transitionToState(oldStates, newState) {\n    if (oldStates.indexOf(this.connectivityState) > -1) {\n      const oldState = this.connectivityState;\n      this.connectivityState = newState;\n      this.handleStateChange(oldState, newState);\n      this.emit('connectivityStateChanged', newState);\n    }\n  }\n  startConnecting() {\n    const connectionOptions = this.credentials._getConnectionOptions() || {};\n    if (connectionOptions.secureContext !== null) {\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      }\n    }\n    const subChannel = new subchannel_1.Http2SubChannel(this.target, connectionOptions, this.userAgent, this.options);\n    this.subChannel = subChannel;\n    const now = new Date();\n    const connectionTimeout = Math.max(this.currentBackoffDeadline.getTime() - now.getTime(), MIN_CONNECT_TIMEOUT_MS);\n    const connectionTimerId = setTimeout(() => {\n      // This should trigger the 'close' event, which will send us back to\n      // TRANSIENT_FAILURE\n      subChannel.close();\n    }, connectionTimeout);\n    this.subChannelConnectCallback = () => {\n      // Connection succeeded\n      clearTimeout(connectionTimerId);\n      this.transitionToState([ConnectivityState.CONNECTING], ConnectivityState.READY);\n    };\n    subChannel.once('connect', this.subChannelConnectCallback);\n    this.subChannelCloseCallback = () => {\n      // Connection failed\n      clearTimeout(connectionTimerId);\n      /* TODO(murgatroid99): verify that this works for\n       * CONNECTING->TRANSITIVE_FAILURE see nodejs/node#16645 */\n      this.transitionToState([ConnectivityState.CONNECTING, ConnectivityState.READY], ConnectivityState.TRANSIENT_FAILURE);\n    };\n    subChannel.once('close', this.subChannelCloseCallback);\n  }\n  _startHttp2Stream(authority, methodName, stream, metadata) {\n    const finalMetadata = stream.filterStack.sendMetadata(Promise.resolve(metadata.clone()));\n    Promise.all([finalMetadata, this.connect()]).then(([metadataValue]) => {\n      const headers = metadataValue.toHttp2Headers();\n      headers[HTTP2_HEADER_AUTHORITY] = authority;\n      headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n      headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n      headers[HTTP2_HEADER_METHOD] = 'POST';\n      headers[HTTP2_HEADER_PATH] = methodName;\n      headers[HTTP2_HEADER_TE] = 'trailers';\n      if (this.connectivityState === ConnectivityState.READY) {\n        const subChannel = this.subChannel;\n        subChannel.startCallStream(metadataValue, stream);\n      } else {\n        /* In this case, we lost the connection while finalizing\n         * metadata. That should be very unusual */\n        setImmediate(() => {\n          this._startHttp2Stream(authority, methodName, stream, metadata);\n        });\n      }\n    }).catch(error => {\n      // We assume the error code isn't 0 (Status.OK)\n      stream.cancelWithStatus(error.code || constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n    });\n  }\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    const finalOptions = {\n      deadline: deadline === null || deadline === undefined ? Infinity : deadline,\n      flags: propagateFlags || 0,\n      host: host || this.defaultAuthority,\n      parentCall: parentCall || null\n    };\n    const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory);\n    return stream;\n  }\n  /**\n   * Attempts to connect, returning a Promise that resolves when the connection\n   * is successful, or rejects if the channel is shut down.\n   */\n  connect() {\n    if (this.connectivityState === ConnectivityState.READY) {\n      return Promise.resolve();\n    } else if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      return Promise.reject(new Error('Channel has been shut down'));\n    } else {\n      // In effect, this.connecting is only assigned upon the first attempt to\n      // transition from IDLE to CONNECTING, so this condition could have also\n      // been (connectivityState === IDLE).\n      if (!this.connecting) {\n        this.connecting = new Promise((resolve, reject) => {\n          this.transitionToState([ConnectivityState.IDLE], ConnectivityState.CONNECTING);\n          const onConnect = () => {\n            this.connecting = null;\n            this.removeListener('shutdown', onShutdown);\n            resolve();\n          };\n          const onShutdown = () => {\n            this.connecting = null;\n            this.removeListener('connect', onConnect);\n            reject(new Error('Channel has been shut down'));\n          };\n          this.once('connect', onConnect);\n          this.once('shutdown', onShutdown);\n        });\n      }\n      return this.connecting;\n    }\n  }\n  getConnectivityState(tryToConnect) {\n    if (tryToConnect) {\n      this.transitionToState([ConnectivityState.IDLE], ConnectivityState.CONNECTING);\n    }\n    return this.connectivityState;\n  }\n  watchConnectivityState(currentState, deadline, callback) {\n    if (this.connectivityState !== currentState) {\n      /* If the connectivity state is different from the provided currentState,\n       * we assume that a state change has successfully occurred */\n      setImmediate(callback);\n    } else {\n      let deadlineMs = 0;\n      if (deadline instanceof Date) {\n        deadlineMs = deadline.getTime();\n      } else {\n        deadlineMs = deadline;\n      }\n      let timeout = deadlineMs - Date.now();\n      if (timeout < 0) {\n        timeout = 0;\n      }\n      const timeoutId = setTimeout(() => {\n        this.removeListener('connectivityStateChanged', eventCb);\n        callback(new Error('Channel state did not change before deadline'));\n      }, timeout);\n      const eventCb = () => {\n        clearTimeout(timeoutId);\n        callback();\n      };\n      this.once('connectivityStateChanged', eventCb);\n    }\n  }\n  getTarget() {\n    return this.target.toString();\n  }\n  close() {\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    this.transitionToState([ConnectivityState.CONNECTING, ConnectivityState.READY, ConnectivityState.TRANSIENT_FAILURE, ConnectivityState.IDLE], ConnectivityState.SHUTDOWN);\n  }\n}\nexports.Http2Channel = Http2Channel;","map":{"version":3,"names":["require","Object","defineProperty","exports","value","events_1","http2","tls_1","url","call_credentials_filter_1","call_stream_1","channel_options_1","compression_filter_1","constants_1","deadline_filter_1","filter_stack_1","metadata_status_filter_1","subchannel_1","version","clientVersion","MIN_CONNECT_TIMEOUT_MS","INITIAL_BACKOFF_MS","BACKOFF_MULTIPLIER","MAX_BACKOFF_MS","BACKOFF_JITTER","HTTP2_HEADER_AUTHORITY","HTTP2_HEADER_CONTENT_TYPE","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_TE","HTTP2_HEADER_USER_AGENT","constants","ConnectivityState","uniformRandom","min","max","Math","random","Http2Channel","EventEmitter","constructor","address","credentials","options","connectivityState","IDLE","connecting","subChannel","subChannelConnectCallback","subChannelCloseCallback","currentBackoff","option","hasOwnProperty","recognizedOptions","console","warn","_isSecure","target","URL","defaultAuthority","host","filterStackFactory","FilterStackFactory","CallCredentialsFilterFactory","DeadlineFilterFactory","MetadataStatusFilterFactory","CompressionFilterFactory","currentBackoffDeadline","Date","backoffTimerId","setTimeout","userAgent","filter","e","join","handleStateChange","oldState","newState","now","CONNECTING","getTime","TRANSIENT_FAILURE","jitterMagnitude","startConnecting","READY","emit","transitionToState","SHUTDOWN","close","removeListener","clearTimeout","Error","oldStates","indexOf","connectionOptions","_getConnectionOptions","secureContext","sslTargetNameOverride","checkServerIdentity","cert","servername","Http2SubChannel","connectionTimeout","connectionTimerId","once","_startHttp2Stream","authority","methodName","stream","metadata","finalMetadata","filterStack","sendMetadata","Promise","resolve","clone","all","connect","then","metadataValue","headers","toHttp2Headers","startCallStream","setImmediate","catch","error","cancelWithStatus","code","Status","UNKNOWN","message","createCall","method","deadline","parentCall","propagateFlags","finalOptions","undefined","Infinity","flags","Http2CallStream","reject","onConnect","onShutdown","getConnectivityState","tryToConnect","watchConnectivityState","currentState","callback","deadlineMs","timeout","timeoutId","eventCb","getTarget","toString"],"sources":["/var/www/html/project/Dash_Vuexy-master/node_modules/@grpc/grpc-js/build/src/channel.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst http2 = require(\"http2\");\nconst tls_1 = require(\"tls\");\nconst url = require(\"url\");\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\nconst call_stream_1 = require(\"./call-stream\");\nconst channel_options_1 = require(\"./channel-options\");\nconst compression_filter_1 = require(\"./compression-filter\");\nconst constants_1 = require(\"./constants\");\nconst deadline_filter_1 = require(\"./deadline-filter\");\nconst filter_stack_1 = require(\"./filter-stack\");\nconst metadata_status_filter_1 = require(\"./metadata-status-filter\");\nconst subchannel_1 = require(\"./subchannel\");\nconst { version: clientVersion } = require('../../package.json');\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\nconst { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT } = http2.constants;\nvar ConnectivityState;\n(function (ConnectivityState) {\n    ConnectivityState[ConnectivityState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    ConnectivityState[ConnectivityState[\"READY\"] = 1] = \"READY\";\n    ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n    ConnectivityState[ConnectivityState[\"IDLE\"] = 3] = \"IDLE\";\n    ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));\nfunction uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nclass Http2Channel extends events_1.EventEmitter {\n    constructor(address, credentials, options) {\n        super();\n        this.credentials = credentials;\n        this.options = options;\n        this.connectivityState = ConnectivityState.IDLE;\n        // Helper Promise object only used in the implementation of connect().\n        this.connecting = null;\n        /* For now, we have up to one subchannel, which will exist as long as we are\n         * connecting or trying to connect */\n        this.subChannel = null;\n        this.subChannelConnectCallback = () => { };\n        this.subChannelCloseCallback = () => { };\n        this.currentBackoff = INITIAL_BACKOFF_MS;\n        for (const option in options) {\n            if (options.hasOwnProperty(option)) {\n                if (!channel_options_1.recognizedOptions.hasOwnProperty(option)) {\n                    console.warn(`Unrecognized channel argument '${option}' will be ignored.`);\n                }\n            }\n        }\n        if (credentials._isSecure()) {\n            this.target = new url.URL(`https://${address}`);\n        }\n        else {\n            this.target = new url.URL(`http://${address}`);\n        }\n        // TODO(murgatroid99): Add more centralized handling of channel options\n        if (this.options['grpc.default_authority']) {\n            this.defaultAuthority = this.options['grpc.default_authority'];\n        }\n        else {\n            this.defaultAuthority = this.target.host;\n        }\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\n            new call_credentials_filter_1.CallCredentialsFilterFactory(this), new deadline_filter_1.DeadlineFilterFactory(this),\n            new metadata_status_filter_1.MetadataStatusFilterFactory(this), new compression_filter_1.CompressionFilterFactory(this)\n        ]);\n        this.currentBackoffDeadline = new Date();\n        /* The only purpose of these lines is to ensure that this.backoffTimerId has\n         * a value of type NodeJS.Timer. */\n        this.backoffTimerId = setTimeout(() => { }, 0);\n        // Build user-agent string.\n        this.userAgent = [\n            options['grpc.primary_user_agent'], `grpc-node-js/${clientVersion}`,\n            options['grpc.secondary_user_agent']\n        ].filter(e => e).join(' '); // remove falsey values first\n    }\n    handleStateChange(oldState, newState) {\n        const now = new Date();\n        switch (newState) {\n            case ConnectivityState.CONNECTING:\n                if (oldState === ConnectivityState.IDLE) {\n                    this.currentBackoff = INITIAL_BACKOFF_MS;\n                    this.currentBackoffDeadline =\n                        new Date(now.getTime() + INITIAL_BACKOFF_MS);\n                }\n                else if (oldState === ConnectivityState.TRANSIENT_FAILURE) {\n                    this.currentBackoff = Math.min(this.currentBackoff * BACKOFF_MULTIPLIER, MAX_BACKOFF_MS);\n                    const jitterMagnitude = BACKOFF_JITTER * this.currentBackoff;\n                    this.currentBackoffDeadline = new Date(now.getTime() + this.currentBackoff +\n                        uniformRandom(-jitterMagnitude, jitterMagnitude));\n                }\n                this.startConnecting();\n                break;\n            case ConnectivityState.READY:\n                this.emit('connect');\n                break;\n            case ConnectivityState.TRANSIENT_FAILURE:\n                this.subChannel = null;\n                this.backoffTimerId = setTimeout(() => {\n                    this.transitionToState([ConnectivityState.TRANSIENT_FAILURE], ConnectivityState.CONNECTING);\n                }, this.currentBackoffDeadline.getTime() - now.getTime());\n                break;\n            case ConnectivityState.IDLE:\n            case ConnectivityState.SHUTDOWN:\n                if (this.subChannel) {\n                    this.subChannel.close();\n                    this.subChannel.removeListener('connect', this.subChannelConnectCallback);\n                    this.subChannel.removeListener('close', this.subChannelCloseCallback);\n                    this.subChannel = null;\n                    this.emit('shutdown');\n                    clearTimeout(this.backoffTimerId);\n                }\n                break;\n            default:\n                throw new Error('This should never happen');\n        }\n    }\n    // Transition from any of a set of oldStates to a specific newState\n    transitionToState(oldStates, newState) {\n        if (oldStates.indexOf(this.connectivityState) > -1) {\n            const oldState = this.connectivityState;\n            this.connectivityState = newState;\n            this.handleStateChange(oldState, newState);\n            this.emit('connectivityStateChanged', newState);\n        }\n    }\n    startConnecting() {\n        const connectionOptions = this.credentials._getConnectionOptions() || {};\n        if (connectionOptions.secureContext !== null) {\n            // If provided, the value of grpc.ssl_target_name_override should be used\n            // to override the target hostname when checking server identity.\n            // This option is used for testing only.\n            if (this.options['grpc.ssl_target_name_override']) {\n                const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n                connectionOptions.checkServerIdentity =\n                    (host, cert) => {\n                        return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n                    };\n                connectionOptions.servername = sslTargetNameOverride;\n            }\n        }\n        const subChannel = new subchannel_1.Http2SubChannel(this.target, connectionOptions, this.userAgent, this.options);\n        this.subChannel = subChannel;\n        const now = new Date();\n        const connectionTimeout = Math.max(this.currentBackoffDeadline.getTime() - now.getTime(), MIN_CONNECT_TIMEOUT_MS);\n        const connectionTimerId = setTimeout(() => {\n            // This should trigger the 'close' event, which will send us back to\n            // TRANSIENT_FAILURE\n            subChannel.close();\n        }, connectionTimeout);\n        this.subChannelConnectCallback = () => {\n            // Connection succeeded\n            clearTimeout(connectionTimerId);\n            this.transitionToState([ConnectivityState.CONNECTING], ConnectivityState.READY);\n        };\n        subChannel.once('connect', this.subChannelConnectCallback);\n        this.subChannelCloseCallback = () => {\n            // Connection failed\n            clearTimeout(connectionTimerId);\n            /* TODO(murgatroid99): verify that this works for\n             * CONNECTING->TRANSITIVE_FAILURE see nodejs/node#16645 */\n            this.transitionToState([ConnectivityState.CONNECTING, ConnectivityState.READY], ConnectivityState.TRANSIENT_FAILURE);\n        };\n        subChannel.once('close', this.subChannelCloseCallback);\n    }\n    _startHttp2Stream(authority, methodName, stream, metadata) {\n        const finalMetadata = stream.filterStack.sendMetadata(Promise.resolve(metadata.clone()));\n        Promise.all([finalMetadata, this.connect()])\n            .then(([metadataValue]) => {\n            const headers = metadataValue.toHttp2Headers();\n            headers[HTTP2_HEADER_AUTHORITY] = authority;\n            headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n            headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n            headers[HTTP2_HEADER_METHOD] = 'POST';\n            headers[HTTP2_HEADER_PATH] = methodName;\n            headers[HTTP2_HEADER_TE] = 'trailers';\n            if (this.connectivityState === ConnectivityState.READY) {\n                const subChannel = this.subChannel;\n                subChannel.startCallStream(metadataValue, stream);\n            }\n            else {\n                /* In this case, we lost the connection while finalizing\n                 * metadata. That should be very unusual */\n                setImmediate(() => {\n                    this._startHttp2Stream(authority, methodName, stream, metadata);\n                });\n            }\n        })\n            .catch((error) => {\n            // We assume the error code isn't 0 (Status.OK)\n            stream.cancelWithStatus(error.code || constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n        });\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        const finalOptions = {\n            deadline: (deadline === null || deadline === undefined) ? Infinity :\n                deadline,\n            flags: propagateFlags || 0,\n            host: host || this.defaultAuthority,\n            parentCall: parentCall || null\n        };\n        const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory);\n        return stream;\n    }\n    /**\n     * Attempts to connect, returning a Promise that resolves when the connection\n     * is successful, or rejects if the channel is shut down.\n     */\n    connect() {\n        if (this.connectivityState === ConnectivityState.READY) {\n            return Promise.resolve();\n        }\n        else if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n            return Promise.reject(new Error('Channel has been shut down'));\n        }\n        else {\n            // In effect, this.connecting is only assigned upon the first attempt to\n            // transition from IDLE to CONNECTING, so this condition could have also\n            // been (connectivityState === IDLE).\n            if (!this.connecting) {\n                this.connecting = new Promise((resolve, reject) => {\n                    this.transitionToState([ConnectivityState.IDLE], ConnectivityState.CONNECTING);\n                    const onConnect = () => {\n                        this.connecting = null;\n                        this.removeListener('shutdown', onShutdown);\n                        resolve();\n                    };\n                    const onShutdown = () => {\n                        this.connecting = null;\n                        this.removeListener('connect', onConnect);\n                        reject(new Error('Channel has been shut down'));\n                    };\n                    this.once('connect', onConnect);\n                    this.once('shutdown', onShutdown);\n                });\n            }\n            return this.connecting;\n        }\n    }\n    getConnectivityState(tryToConnect) {\n        if (tryToConnect) {\n            this.transitionToState([ConnectivityState.IDLE], ConnectivityState.CONNECTING);\n        }\n        return this.connectivityState;\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        if (this.connectivityState !== currentState) {\n            /* If the connectivity state is different from the provided currentState,\n             * we assume that a state change has successfully occurred */\n            setImmediate(callback);\n        }\n        else {\n            let deadlineMs = 0;\n            if (deadline instanceof Date) {\n                deadlineMs = deadline.getTime();\n            }\n            else {\n                deadlineMs = deadline;\n            }\n            let timeout = deadlineMs - Date.now();\n            if (timeout < 0) {\n                timeout = 0;\n            }\n            const timeoutId = setTimeout(() => {\n                this.removeListener('connectivityStateChanged', eventCb);\n                callback(new Error('Channel state did not change before deadline'));\n            }, timeout);\n            const eventCb = () => {\n                clearTimeout(timeoutId);\n                callback();\n            };\n            this.once('connectivityStateChanged', eventCb);\n        }\n    }\n    getTarget() {\n        return this.target.toString();\n    }\n    close() {\n        if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        this.transitionToState([\n            ConnectivityState.CONNECTING, ConnectivityState.READY,\n            ConnectivityState.TRANSIENT_FAILURE, ConnectivityState.IDLE\n        ], ConnectivityState.SHUTDOWN);\n    }\n}\nexports.Http2Channel = Http2Channel;\n//# sourceMappingURL=channel.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}