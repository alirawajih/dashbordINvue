{"ast":null,"code":"import { ref as t, inject as i, provide as n, defineComponent as r } from \"vue\";\nimport { PureAbility as o } from \"@casl/ability\";\nfunction reactiveAbility(i) {\n  if (Object.hasOwn(i, \"possibleRulesFor\")) return i;\n  const n = t(true);\n  i.on(\"updated\", () => {\n    n.value = !n.value;\n  });\n  const r = i.possibleRulesFor.bind(i);\n  i.possibleRulesFor = (t, i) => {\n    n.value = n.value;\n    return r(t, i);\n  };\n  i.can = i.can.bind(i);\n  i.cannot = i.cannot.bind(i);\n  return i;\n}\nconst e = Symbol(\"ability\");\nfunction useAbility() {\n  const t = i(e);\n  if (!t) throw new Error(\"Cannot inject Ability instance because it was not provided\");\n  return t;\n}\nfunction provideAbility(t) {\n  n(e, reactiveAbility(t));\n}\nfunction s(t) {\n  if (t.a !== void 0) return \"a\";\n  if (t.this !== void 0) return \"this\";\n  if (t.an !== void 0) return \"an\";\n  return \"\";\n}\nconst u = r({\n  name: \"Can\",\n  props: {\n    I: String,\n    do: String,\n    a: [String, Function],\n    an: [String, Function],\n    this: [String, Function, Object],\n    on: [String, Function, Object],\n    not: Boolean,\n    passThrough: Boolean,\n    field: String\n  },\n  setup(t, {\n    slots: i\n  }) {\n    const n = t;\n    let r = \"do\";\n    let o = \"on\";\n    if (n[r] === void 0) {\n      r = \"I\";\n      o = s(t);\n    }\n    if (!n[r]) throw new Error(\"Neither `I` nor `do` prop was passed in <Can>\");\n    if (!i.default) throw new Error(\"Expects to receive default slot\");\n    const e = useAbility();\n    return () => {\n      const s = e.can(n[r], n[o], n.field);\n      const u = t.not ? !s : s;\n      if (!t.passThrough) return u ? i.default() : null;\n      return i.default({\n        allowed: u,\n        ability: e\n      });\n    };\n  }\n});\nfunction l(t, i, n) {\n  if (!i || !(i instanceof o)) throw new Error(\"Please provide an Ability instance to abilitiesPlugin plugin\");\n  t.provide(e, reactiveAbility(i));\n  if (n && n.useGlobalProperties) {\n    t.config.globalProperties.$ability = i;\n    t.config.globalProperties.$can = i.can.bind(i);\n  }\n}\nexport { e as ABILITY_TOKEN, u as Can, l as abilitiesPlugin, provideAbility, useAbility };","map":{"version":3,"names":["reactiveAbility","i","Object","hasOwn","n","t","on","value","r","possibleRulesFor","bind","can","cannot","e","Symbol","useAbility","Error","provideAbility","s","a","this","an","u","name","props","I","String","do","Function","not","Boolean","passThrough","field","setup","slots","o","default","allowed","ability","l","provide","useGlobalProperties","config","globalProperties","$ability","$can","ABILITY_TOKEN","Can","abilitiesPlugin"],"sources":["../../src/reactiveAbility.ts","../../src/useAbility.ts","../../src/component/can.ts","../../src/plugin.ts"],"sourcesContent":["import { AnyAbility, SubjectType } from '@casl/ability';\nimport { ref } from 'vue';\n\nexport function reactiveAbility(ability: AnyAbility) {\n  if (Object.hasOwn(ability, 'possibleRulesFor')) {\n    return ability;\n  }\n\n  const watcher = ref(true);\n  ability.on('updated', () => {\n    watcher.value = !watcher.value;\n  });\n\n  const possibleRulesFor = ability.possibleRulesFor.bind(ability);\n  ability.possibleRulesFor = (action: string, subject: SubjectType) => {\n    watcher.value = watcher.value; // eslint-disable-line\n    return possibleRulesFor(action, subject);\n  };\n  ability.can = ability.can.bind(ability);\n  ability.cannot = ability.cannot.bind(ability);\n\n  return ability;\n}\n","import { inject, InjectionKey, provide } from 'vue';\nimport type { AnyAbility, Ability } from '@casl/ability';\nimport { reactiveAbility } from './reactiveAbility';\n\nexport const ABILITY_TOKEN: InjectionKey<AnyAbility> = Symbol('ability');\n\nexport function useAbility<T extends AnyAbility = Ability>(): T {\n  const ability = inject<T>(ABILITY_TOKEN);\n\n  if (!ability) {\n    throw new Error('Cannot inject Ability instance because it was not provided');\n  }\n\n  return ability;\n}\n\nexport function provideAbility(ability: AnyAbility) {\n  provide(ABILITY_TOKEN, reactiveAbility(ability));\n}\n","import { defineComponent, ComponentCustomProperties } from 'vue';\nimport {\n  SubjectType,\n  Generics,\n  AnyAbility,\n  Ability,\n  Abilities,\n  IfString,\n  AbilityTuple,\n} from '@casl/ability';\nimport { useAbility } from '../useAbility';\n\ntype AbilityCanProps<\n  T extends Abilities,\n  Else = IfString<T, { do: T } | { I: T }>\n> = T extends AbilityTuple\n  ? { do: T[0], on: T[1], field?: string } |\n  { I: T[0], a: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], an: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], this: Exclude<T[1], SubjectType>, field?: string }\n  : Else;\n\nexport type CanProps<T extends AnyAbility> = AbilityCanProps<Generics<T>['abilities']> & {\n  not?: boolean,\n  passThrough?: boolean\n};\n\ntype VueAbility = ComponentCustomProperties extends { $ability: AnyAbility }\n  ? ComponentCustomProperties['$ability']\n  : Ability;\n\nfunction detectSubjectProp(props: Record<string, unknown>) {\n  if (props.a !== undefined) {\n    return 'a';\n  }\n\n  if (props.this !== undefined) {\n    return 'this';\n  }\n\n  if (props.an !== undefined) {\n    return 'an';\n  }\n\n  return '';\n}\n\nexport const Can = defineComponent<CanProps<VueAbility>>({\n  name: 'Can',\n  props: {\n    I: String,\n    do: String,\n    a: [String, Function],\n    an: [String, Function],\n    this: [String, Function, Object],\n    on: [String, Function, Object],\n    not: Boolean,\n    passThrough: Boolean,\n    field: String\n  } as any,\n  setup(props, { slots }) {\n    const $props = props as Record<string, any>;\n    let actionProp = 'do';\n    let subjectProp = 'on';\n\n    if ($props[actionProp] === undefined) {\n      actionProp = 'I';\n      subjectProp = detectSubjectProp(props);\n    }\n\n    if (!$props[actionProp]) {\n      throw new Error('Neither `I` nor `do` prop was passed in <Can>');\n    }\n\n    if (!slots.default) {\n      throw new Error('Expects to receive default slot');\n    }\n\n    const ability = useAbility<VueAbility>();\n\n    return () => {\n      const isAllowed = ability.can($props[actionProp], $props[subjectProp], $props.field);\n      const canRender = props.not ? !isAllowed : isAllowed;\n\n      if (!props.passThrough) {\n        return canRender ? slots.default!() : null;\n      }\n\n      return slots.default!({\n        allowed: canRender,\n        ability,\n      });\n    };\n  }\n});\n","import { App } from 'vue';\nimport { AnyAbility, PureAbility } from '@casl/ability';\nimport { ABILITY_TOKEN } from './useAbility';\nimport { reactiveAbility } from './reactiveAbility';\n\nexport interface AbilityPluginOptions {\n  useGlobalProperties?: boolean\n}\n\nexport function abilitiesPlugin(app: App, ability: AnyAbility, options?: AbilityPluginOptions) {\n  if (!ability || !(ability instanceof PureAbility)) {\n    throw new Error('Please provide an Ability instance to abilitiesPlugin plugin');\n  }\n\n  app.provide(ABILITY_TOKEN, reactiveAbility(ability));\n\n  if (options && options.useGlobalProperties) {\n    app.config.globalProperties.$ability = ability;\n    app.config.globalProperties.$can = ability.can.bind(ability);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}