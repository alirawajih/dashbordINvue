{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\nfunction isLegalKey(key) {\n  return LEGAL_KEY_REGEX.test(key);\n}\nfunction isLegalNonBinaryValue(value) {\n  return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\nfunction isBinaryKey(key) {\n  return key.endsWith('-bin');\n}\nfunction normalizeKey(key) {\n  return key.toLowerCase();\n}\nfunction validate(key, value) {\n  if (!isLegalKey(key)) {\n    throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n  }\n  if (value != null) {\n    if (isBinaryKey(key)) {\n      if (!(value instanceof Buffer)) {\n        throw new Error('keys that end with \\'-bin\\' must have Buffer values');\n      }\n    } else {\n      if (value instanceof Buffer) {\n        throw new Error('keys that don\\'t end with \\'-bin\\' must have String values');\n      }\n      if (!isLegalNonBinaryValue(value)) {\n        throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n      }\n    }\n  }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\nclass Metadata {\n  constructor() {\n    this.internalRepr = new Map();\n  }\n  /**\n   * Sets the given value for the given key by replacing any other values\n   * associated with that key. Normalizes the key.\n   * @param key The key to whose value should be set.\n   * @param value The value to set. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n  set(key, value) {\n    key = normalizeKey(key);\n    validate(key, value);\n    this.internalRepr.set(key, [value]);\n  }\n  /**\n   * Adds the given value for the given key by appending to a list of previous\n   * values associated with that key. Normalizes the key.\n   * @param key The key for which a new value should be appended.\n   * @param value The value to add. Must be a buffer if and only\n   *   if the normalized key ends with '-bin'.\n   */\n  add(key, value) {\n    key = normalizeKey(key);\n    validate(key, value);\n    const existingValue = this.internalRepr.get(key);\n    if (existingValue === undefined) {\n      this.internalRepr.set(key, [value]);\n    } else {\n      existingValue.push(value);\n    }\n  }\n  /**\n   * Removes the given key and any associated values. Normalizes the key.\n   * @param key The key whose values should be removed.\n   */\n  remove(key) {\n    key = normalizeKey(key);\n    validate(key);\n    this.internalRepr.delete(key);\n  }\n  /**\n   * Gets a list of all values associated with the key. Normalizes the key.\n   * @param key The key whose value should be retrieved.\n   * @return A list of values associated with the given key.\n   */\n  get(key) {\n    key = normalizeKey(key);\n    validate(key);\n    return this.internalRepr.get(key) || [];\n  }\n  /**\n   * Gets a plain object mapping each key to the first value associated with it.\n   * This reflects the most common way that people will want to see metadata.\n   * @return A key/value mapping of the metadata.\n   */\n  getMap() {\n    const result = {};\n    this.internalRepr.forEach((values, key) => {\n      if (values.length > 0) {\n        const v = values[0];\n        result[key] = v instanceof Buffer ? v.slice() : v;\n      }\n    });\n    return result;\n  }\n  /**\n   * Clones the metadata object.\n   * @return The newly cloned object.\n   */\n  clone() {\n    const newMetadata = new Metadata();\n    const newInternalRepr = newMetadata.internalRepr;\n    this.internalRepr.forEach((value, key) => {\n      const clonedValue = value.map(v => {\n        if (v instanceof Buffer) {\n          return Buffer.from(v);\n        } else {\n          return v;\n        }\n      });\n      newInternalRepr.set(key, clonedValue);\n    });\n    return newMetadata;\n  }\n  /**\n   * Merges all key-value pairs from a given Metadata object into this one.\n   * If both this object and the given object have values in the same key,\n   * values from the other Metadata object will be appended to this object's\n   * values.\n   * @param other A Metadata object.\n   */\n  merge(other) {\n    other.internalRepr.forEach((values, key) => {\n      const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n      this.internalRepr.set(key, mergedValue);\n    });\n  }\n  /**\n   * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n   */\n  toHttp2Headers() {\n    // NOTE: Node <8.9 formats http2 headers incorrectly.\n    const result = {};\n    this.internalRepr.forEach((values, key) => {\n      // We assume that the user's interaction with this object is limited to\n      // through its public API (i.e. keys and values are already validated).\n      result[key] = values.map(value => {\n        if (value instanceof Buffer) {\n          return value.toString('base64');\n        } else {\n          return value;\n        }\n      });\n    });\n    return result;\n  }\n  // For compatibility with the other Metadata implementation\n  _getCoreRepresentation() {\n    return this.internalRepr;\n  }\n  /**\n   * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n   * object.\n   * @param headers An IncomingHttpHeaders object.\n   */\n  static fromHttp2Headers(headers) {\n    const result = new Metadata();\n    Object.keys(headers).forEach(key => {\n      // Reserved headers (beginning with `:`) are not valid keys.\n      if (key.charAt(0) === ':') {\n        return;\n      }\n      const values = headers[key];\n      if (isBinaryKey(key)) {\n        if (Array.isArray(values)) {\n          values.forEach(value => {\n            result.add(key, Buffer.from(value, 'base64'));\n          });\n        } else if (values !== undefined) {\n          values.split(',').forEach(v => {\n            result.add(key, Buffer.from(v.trim(), 'base64'));\n          });\n        }\n      } else {\n        if (Array.isArray(values)) {\n          values.forEach(value => {\n            result.add(key, value);\n          });\n        } else if (values !== undefined) {\n          values.split(',').forEach(v => result.add(key, v.trim()));\n        }\n      }\n    });\n    return result;\n  }\n}\nexports.Metadata = Metadata;","map":{"version":3,"names":["require","Object","defineProperty","exports","value","LEGAL_KEY_REGEX","LEGAL_NON_BINARY_VALUE_REGEX","isLegalKey","key","test","isLegalNonBinaryValue","isBinaryKey","endsWith","normalizeKey","toLowerCase","validate","Error","Buffer","Metadata","constructor","internalRepr","Map","set","add","existingValue","get","undefined","push","remove","delete","getMap","result","forEach","values","length","v","slice","clone","newMetadata","newInternalRepr","clonedValue","map","from","merge","other","mergedValue","concat","toHttp2Headers","toString","_getCoreRepresentation","fromHttp2Headers","headers","keys","charAt","Array","isArray","split","trim"],"sources":["/var/www/html/project/Dash_Vuexy-master/node_modules/@grpc/grpc-js/build/src/metadata.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\nfunction isLegalKey(key) {\n    return LEGAL_KEY_REGEX.test(key);\n}\nfunction isLegalNonBinaryValue(value) {\n    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\nfunction isBinaryKey(key) {\n    return key.endsWith('-bin');\n}\nfunction normalizeKey(key) {\n    return key.toLowerCase();\n}\nfunction validate(key, value) {\n    if (!isLegalKey(key)) {\n        throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n    }\n    if (value != null) {\n        if (isBinaryKey(key)) {\n            if (!(value instanceof Buffer)) {\n                throw new Error('keys that end with \\'-bin\\' must have Buffer values');\n            }\n        }\n        else {\n            if (value instanceof Buffer) {\n                throw new Error('keys that don\\'t end with \\'-bin\\' must have String values');\n            }\n            if (!isLegalNonBinaryValue(value)) {\n                throw new Error('Metadata string value \"' + value +\n                    '\" contains illegal characters');\n            }\n        }\n    }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\nclass Metadata {\n    constructor() {\n        this.internalRepr = new Map();\n    }\n    /**\n     * Sets the given value for the given key by replacing any other values\n     * associated with that key. Normalizes the key.\n     * @param key The key to whose value should be set.\n     * @param value The value to set. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */\n    set(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        this.internalRepr.set(key, [value]);\n    }\n    /**\n     * Adds the given value for the given key by appending to a list of previous\n     * values associated with that key. Normalizes the key.\n     * @param key The key for which a new value should be appended.\n     * @param value The value to add. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */\n    add(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        const existingValue = this.internalRepr.get(key);\n        if (existingValue === undefined) {\n            this.internalRepr.set(key, [value]);\n        }\n        else {\n            existingValue.push(value);\n        }\n    }\n    /**\n     * Removes the given key and any associated values. Normalizes the key.\n     * @param key The key whose values should be removed.\n     */\n    remove(key) {\n        key = normalizeKey(key);\n        validate(key);\n        this.internalRepr.delete(key);\n    }\n    /**\n     * Gets a list of all values associated with the key. Normalizes the key.\n     * @param key The key whose value should be retrieved.\n     * @return A list of values associated with the given key.\n     */\n    get(key) {\n        key = normalizeKey(key);\n        validate(key);\n        return this.internalRepr.get(key) || [];\n    }\n    /**\n     * Gets a plain object mapping each key to the first value associated with it.\n     * This reflects the most common way that people will want to see metadata.\n     * @return A key/value mapping of the metadata.\n     */\n    getMap() {\n        const result = {};\n        this.internalRepr.forEach((values, key) => {\n            if (values.length > 0) {\n                const v = values[0];\n                result[key] = v instanceof Buffer ? v.slice() : v;\n            }\n        });\n        return result;\n    }\n    /**\n     * Clones the metadata object.\n     * @return The newly cloned object.\n     */\n    clone() {\n        const newMetadata = new Metadata();\n        const newInternalRepr = newMetadata.internalRepr;\n        this.internalRepr.forEach((value, key) => {\n            const clonedValue = value.map(v => {\n                if (v instanceof Buffer) {\n                    return Buffer.from(v);\n                }\n                else {\n                    return v;\n                }\n            });\n            newInternalRepr.set(key, clonedValue);\n        });\n        return newMetadata;\n    }\n    /**\n     * Merges all key-value pairs from a given Metadata object into this one.\n     * If both this object and the given object have values in the same key,\n     * values from the other Metadata object will be appended to this object's\n     * values.\n     * @param other A Metadata object.\n     */\n    merge(other) {\n        other.internalRepr.forEach((values, key) => {\n            const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n            this.internalRepr.set(key, mergedValue);\n        });\n    }\n    /**\n     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n     */\n    toHttp2Headers() {\n        // NOTE: Node <8.9 formats http2 headers incorrectly.\n        const result = {};\n        this.internalRepr.forEach((values, key) => {\n            // We assume that the user's interaction with this object is limited to\n            // through its public API (i.e. keys and values are already validated).\n            result[key] = values.map((value) => {\n                if (value instanceof Buffer) {\n                    return value.toString('base64');\n                }\n                else {\n                    return value;\n                }\n            });\n        });\n        return result;\n    }\n    // For compatibility with the other Metadata implementation\n    _getCoreRepresentation() {\n        return this.internalRepr;\n    }\n    /**\n     * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n     * object.\n     * @param headers An IncomingHttpHeaders object.\n     */\n    static fromHttp2Headers(headers) {\n        const result = new Metadata();\n        Object.keys(headers).forEach((key) => {\n            // Reserved headers (beginning with `:`) are not valid keys.\n            if (key.charAt(0) === ':') {\n                return;\n            }\n            const values = headers[key];\n            if (isBinaryKey(key)) {\n                if (Array.isArray(values)) {\n                    values.forEach((value) => {\n                        result.add(key, Buffer.from(value, 'base64'));\n                    });\n                }\n                else if (values !== undefined) {\n                    values.split(',').forEach(v => {\n                        result.add(key, Buffer.from(v.trim(), 'base64'));\n                    });\n                }\n            }\n            else {\n                if (Array.isArray(values)) {\n                    values.forEach((value) => {\n                        result.add(key, value);\n                    });\n                }\n                else if (values !== undefined) {\n                    values.split(',').forEach(v => result.add(key, v.trim()));\n                }\n            }\n        });\n        return result;\n    }\n}\nexports.Metadata = Metadata;\n//# sourceMappingURL=metadata.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}