{"ast":null,"code":"import { openBlock as _openBlock, createElementBlock as _createElementBlock, createCommentVNode as _createCommentVNode, resolveComponent as _resolveComponent, createBlock as _createBlock, resolveDynamicComponent as _resolveDynamicComponent, Fragment as _Fragment, toDisplayString as _toDisplayString, normalizeClass as _normalizeClass, createElementVNode as _createElementVNode, toHandlerKey as _toHandlerKey, mergeProps as _mergeProps, renderList as _renderList, normalizeStyle as _normalizeStyle } from \"vue\";\nconst _hoisted_1 = {\n  key: 0,\n  class: \"BlockBack\"\n};\nconst _hoisted_2 = {\n  key: 0,\n  class: \"labelName\"\n};\nconst _hoisted_3 = {\n  key: 1\n};\nconst _hoisted_4 = {\n  key: 1\n};\nconst _hoisted_5 = {\n  key: 0,\n  class: \"labelName\"\n};\nconst _hoisted_6 = {\n  key: 0,\n  class: \"labelminiSub\"\n};\nconst _hoisted_7 = {\n  key: 2,\n  class: \"labelminiSub\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_MenuItemIconVue = _resolveComponent(\"MenuItemIconVue\");\n  const _component_menu_item = _resolveComponent(\"menu-item\");\n  return _openBlock(), _createElementBlock(\"div\", {\n    class: _normalizeClass([$options.menuItemClass, \"menu-item-base alignCenter\"]),\n    ref: \"menuItem\",\n    style: _normalizeStyle({\n      float: $setup.miniMenu && $props.depth === 1 ? $setup.menuDirection : $options.menuDirectionOposite\n    })\n  }, [_ctx.active ? (_openBlock(), _createElementBlock(\"div\", _hoisted_1)) : _createCommentVNode(\"v-if\", true), _createCommentVNode(\" ========================= \"), _createCommentVNode(\" ========================= \"), _createCommentVNode(\" 1 this is the menu label  \"), _createCommentVNode(\" ========================= \"), _createCommentVNode(\" ========================= \"), _createElementVNode(\"div\", _mergeProps({\n    class: \"label\"\n  }, {\n    [_toHandlerKey($options.shouldMouseEnterEvent)]: _cache[0] || (_cache[0] = $event => this.hover = true)\n  }, {\n    [_toHandlerKey($options.shouldMouseLeaveEvent)]: _cache[1] || (_cache[1] = $event => this.hover = false)\n  }, {\n    class: {\n      TransitionC: !$setup.miniMenu || $setup.miniMenu && !_ctx.showChildren,\n      menuexpand: _ctx.showChildren,\n      [$options.activeClass]: _ctx.active,\n      [$options.miniActiveClass]: _ctx.miniActive,\n      labelHoverClass: $props.depth != 0 && $setup.miniMenu || !$setup.miniMenu\n    }\n  }, {\n    [_toHandlerKey($options.keyOrClick)]: _cache[2] || (_cache[2] = (...args) => $options.labelClick && $options.labelClick(...args))\n  }, {\n    style: {\n      [$setup.menuDirection == 'left' ? 'paddingLeft' : 'paddingRight']: $setup.menuType === 'fully' ? `${$props.depth * 18}px` : ``,\n      background: $props.depth == 0 && !_ctx.active && $setup.miniMenu ? 'none' : ''\n    }\n  }), [_createElementVNode(\"div\", {\n    class: _normalizeClass([\"left\", {\n      marginAuto: $setup.miniMenu && $props.depth === 0,\n      collapseEnd: $setup.miniMenu\n    }]),\n    ref: \"labelRef\"\n  }, [!$setup.removeIconSpace || $setup.removeIconSpace && $props.siblingsHaveIconProp ? (_openBlock(), _createElementBlock(_Fragment, {\n    key: 0\n  }, [!$setup.itemPrepandIcon ? (_openBlock(), _createBlock(_component_MenuItemIconVue, {\n    key: 0,\n    icon: $props.item?.icon\n  }, null, 8 /* PROPS */, [\"icon\"])) : $setup.itemPrepandIcon ? (_openBlock(), _createElementBlock(_Fragment, {\n    key: 1\n  }, [_createCommentVNode(\" !!! slot for menuitem icon\"), (_openBlock(), _createBlock(_resolveDynamicComponent($setup.itemPrepandIcon), {\n    icon: $props.item?.icon,\n    active: _ctx.active,\n    miniActive: _ctx.miniActive,\n    isChildrenMenuOpen: _ctx.showChildren\n  }, null, 8 /* PROPS */, [\"icon\", \"active\", \"miniActive\", \"isChildrenMenuOpen\"]))], 2112 /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */)) : _createCommentVNode(\"v-if\", true)], 64 /* STABLE_FRAGMENT */)) : _createCommentVNode(\"v-if\", true), $options.labelName ? (_openBlock(), _createElementBlock(_Fragment, {\n    key: 1\n  }, [!$setup.menuItemLabel ? (_openBlock(), _createElementBlock(\"span\", _hoisted_2, _toDisplayString($options.labelName), 1 /* TEXT */)) : (_openBlock(), _createBlock(_resolveDynamicComponent($setup.menuItemLabel), {\n    key: 1,\n    labelName: $options.labelName,\n    active: _ctx.active,\n    miniActive: _ctx.miniActive,\n    isChildrenMenuOpen: _ctx.showChildren\n  }, null, 8 /* PROPS */, [\"labelName\", \"active\", \"miniActive\", \"isChildrenMenuOpen\"]))], 64 /* STABLE_FRAGMENT */)) : _createCommentVNode(\"v-if\", true)], 2 /* CLASS */), $setup.miniMenu && $props.depth != 0 || !$setup.miniMenu ? (_openBlock(), _createElementBlock(_Fragment, {\n    key: 0\n  }, [$props.item.children && !$setup.itemApendIcon ? (_openBlock(), _createElementBlock(\"div\", {\n    key: 0,\n    class: _normalizeClass([\"icons postIconOpenAnima\", {\n      opened: _ctx.showChildren\n    }])\n  }, null, 2 /* CLASS */)) : _createCommentVNode(\"v-if\", true), _createCommentVNode(\" !!!  slot for menuitem prepand icon\"), $props.item.children && $setup.itemApendIcon ? (_openBlock(), _createElementBlock(\"div\", _hoisted_3, [$setup.itemApendIcon ? (_openBlock(), _createBlock(_resolveDynamicComponent($setup.itemApendIcon), {\n    key: 0,\n    icon: $props.item?.icon,\n    isChildrenMenuOpen: _ctx.showChildren,\n    active: _ctx.active,\n    miniActive: _ctx.miniActive\n  }, null, 8 /* PROPS */, [\"icon\", \"isChildrenMenuOpen\", \"active\", \"miniActive\"])) : _createCommentVNode(\"v-if\", true)])) : _createCommentVNode(\"v-if\", true)], 64 /* STABLE_FRAGMENT */)) : _createCommentVNode(\"v-if\", true)], 16 /* FULL_PROPS */), _createCommentVNode(\" ========================= \"), _createCommentVNode(\" ========================= \"), _createCommentVNode(\"2 this container is for when menu Children when full width \"), _createCommentVNode(\" ========================= \"), _createCommentVNode(\" ========================= \"), !$setup.miniMenu || $props.depth != 0 && $setup.miniMenu ? (_openBlock(), _createElementBlock(\"div\", _hoisted_4, [$props.item.children ? (_openBlock(), _createElementBlock(\"div\", {\n    key: 0,\n    class: _normalizeClass([\"items-container\", {\n      'small-menu': $props.smallMenu\n    }]),\n    style: _normalizeStyle({\n      maxHeight: $options.heifOfContainer,\n      transition: $options.transitionTime\n    }),\n    ref: \"container\"\n  }, [_ctx.renderChildren ? (_openBlock(true), _createElementBlock(_Fragment, {\n    key: 0\n  }, _renderList($props.item.children, (item, index) => {\n    return _openBlock(), _createBlock(_component_menu_item, {\n      siblingsHaveIconProp: _ctx.siblingsHaveIcon,\n      isParentFlat: $props.siblingsHaveIconProp,\n      key: index,\n      item: item,\n      depth: $props.depth + 1,\n      smallMenu: $props.smallMenu\n    }, null, 8 /* PROPS */, [\"siblingsHaveIconProp\", \"isParentFlat\", \"item\", \"depth\", \"smallMenu\"]);\n  }), 128 /* KEYED_FRAGMENT */)) : _createCommentVNode(\"v-if\", true)], 6 /* CLASS, STYLE */)) : _createCommentVNode(\"v-if\", true)])) : _createCommentVNode(\"v-if\", true), _createCommentVNode(\" ========================= \"), _createCommentVNode(\" ========================= \"), _createCommentVNode(\"3  this container is for mini Menu Children \"), _createCommentVNode(\" ========================= \"), _createCommentVNode(\" ========================= \"), $setup.miniMenu && $props.depth === 0 && !$setup.collapsed ? (_openBlock(), _createElementBlock(\"div\", {\n    key: 2,\n    class: _normalizeClass({\n      topContainer: $props.depth == 0,\n      vasopacitiy: !_ctx.expanded\n    }),\n    ref: \"topContainerRef\",\n    style: _normalizeStyle({\n      [_ctx.MakeSpace ? 'bottom' : 'top']: `calc(${$options.ContainerOffsetYConputed} - 1px)`,\n      [$setup.menuDirection]: `calc(${$setup.widthMiniMenu} - 1px)`,\n      maxHeight: _ctx.TopcontainerHiefht,\n      width: _ctx.showChildren ? '250px' : '0px',\n      zIndex: _ctx.showChildren ? '850' : '849',\n      animationDelay: _ctx.seTAnimationTimeOut ? '0.3s' : '0'\n    })\n  }, [_createElementVNode(\"div\", {\n    onClick: _cache[3] || (_cache[3] = (...args) => $options.miniLabelClick && $options.miniLabelClick(...args)),\n    onMousewheel: _cache[4] || (_cache[4] = (...args) => $options.mousewheelop && $options.mousewheelop(...args)),\n    class: _normalizeClass([\"labelMini\", {\n      [$options.miniActiveClass]: _ctx.miniActive,\n      [$options.activeClass]: _ctx.active\n    }]),\n    style: _normalizeStyle({\n      position: 'fixed',\n      whiteSpace: 'nowrap',\n      [$setup.menuDirection]: $setup.menuType === 'fully' ? '0px' : $options.miniLabelDirection,\n      width: $options.miniLabelWidth,\n      [_ctx.MakeSpace ? 'bottom' : 'top']: $options.ContainerOffsetYConputed,\n      opacity: $props.depth === 0 && _ctx.showChildren ? '1' : '0'\n    })\n  }, [_createCommentVNode(\"main menu btn\"), _ctx.showChildren ? (_openBlock(), _createElementBlock(\"div\", {\n    key: 0,\n    class: _normalizeClass([\"left\", {\n      marginAuto: $setup.miniMenu && $props.depth === 0\n    }]),\n    style: _normalizeStyle({\n      [$setup.menuDirection]: $setup.widthMiniMenu,\n      top: _ctx.labelMiniYYofsset + 'px'\n    })\n  }, [!$setup.menuItemLabel ? (_openBlock(), _createElementBlock(\"span\", _hoisted_5, _toDisplayString($props.item?.name), 1 /* TEXT */)) : (_openBlock(), _createBlock(_resolveDynamicComponent($setup.menuItemLabel), {\n    key: 1,\n    labelName: $props.item?.name,\n    active: _ctx.active,\n    miniActive: _ctx.miniActive,\n    isChildrenMenuOpen: _ctx.showChildren\n  }, null, 8 /* PROPS */, [\"labelName\", \"active\", \"miniActive\", \"isChildrenMenuOpen\"]))], 6 /* CLASS, STYLE */)) : _createCommentVNode(\"v-if\", true)], 38 /* CLASS, STYLE, HYDRATE_EVENTS */), $props.depth == 0 && !_ctx.MakeSpace ? (_openBlock(), _createElementBlock(\"div\", _hoisted_6)) : _createCommentVNode(\"v-if\", true), $props.item.children ? (_openBlock(), _createElementBlock(\"div\", {\n    key: 1,\n    class: _normalizeClass([\"items-container\", {\n      'small-menu': $props.smallMenu\n    }]),\n    style: _normalizeStyle({\n      maxHeight: $options.heifOfContainer,\n      transition: $options.transitionTime\n    }),\n    ref: \"container\"\n  }, [_ctx.renderChildren ? (_openBlock(true), _createElementBlock(_Fragment, {\n    key: 0\n  }, _renderList($props.item.children, (item, index) => {\n    return _openBlock(), _createBlock(_component_menu_item, {\n      siblingsHaveIconProp: _ctx.siblingsHaveIcon,\n      isParentFlat: $props.siblingsHaveIconProp,\n      key: index,\n      item: item,\n      depth: $props.depth + 1,\n      smallMenu: $props.smallMenu,\n      setMaxHeightTopCProp: $options.setMaxHeightTopC,\n      isMakeSpace: _ctx.MakeSpace\n    }, null, 8 /* PROPS */, [\"siblingsHaveIconProp\", \"isParentFlat\", \"item\", \"depth\", \"smallMenu\", \"setMaxHeightTopCProp\", \"isMakeSpace\"]);\n  }), 128 /* KEYED_FRAGMENT */)) : _createCommentVNode(\"v-if\", true)], 6 /* CLASS, STYLE */)) : _createCommentVNode(\"v-if\", true), $props.depth == 0 && _ctx.MakeSpace ? (_openBlock(), _createElementBlock(\"div\", _hoisted_7)) : _createCommentVNode(\"v-if\", true)], 6 /* CLASS, STYLE */)) : _createCommentVNode(\"v-if\", true)], 6 /* CLASS, STYLE */);\n}","map":{"version":3,"names":["class","_createElementBlock","_normalizeClass","$options","menuItemClass","ref","style","_normalizeStyle","$setup","miniMenu","$props","depth","menuDirection","menuDirectionOposite","_ctx","active","_hoisted_1","_createCommentVNode","_createElementVNode","_mergeProps","shouldMouseEnterEvent","_cache","$event","hover","shouldMouseLeaveEvent","showChildren","activeClass","miniActiveClass","miniActive","keyOrClick","args","labelClick","menuType","marginAuto","collapseEnd","removeIconSpace","siblingsHaveIconProp","_Fragment","key","itemPrepandIcon","_createBlock","_component_MenuItemIconVue","icon","item","_resolveDynamicComponent","isChildrenMenuOpen","labelName","menuItemLabel","_hoisted_2","_toDisplayString","children","itemApendIcon","opened","_hoisted_3","_hoisted_4","smallMenu","maxHeight","heifOfContainer","transition","transitionTime","renderChildren","_renderList","index","_component_menu_item","siblingsHaveIcon","isParentFlat","collapsed","topContainer","vasopacitiy","expanded","MakeSpace","ContainerOffsetYConputed","widthMiniMenu","TopcontainerHiefht","seTAnimationTimeOut","onClick","miniLabelClick","onMousewheel","mousewheelop","miniLabelDirection","miniLabelWidth","labelMiniYYofsset","_hoisted_5","name","_hoisted_6","setMaxHeightTopCProp","setMaxHeightTopC","isMakeSpace","_hoisted_7"],"sources":["/var/www/html/project/Dash_Vuexy-master/src/components/chat.vue"],"sourcesContent":["<template>\n  <div\n    :class=\"menuItemClass\"\n    ref=\"menuItem\"\n    class=\"menu-item-base alignCenter\"\n    :style=\"{\n      float: miniMenu && depth === 1 ? menuDirection : menuDirectionOposite\n    }\"\n  >\n    <div v-if=\"active\" class=\"BlockBack\"></div>\n    <!-- ========================= -->\n    <!-- ========================= -->\n    <!-- 1 this is the menu label  -->\n    <!-- ========================= -->\n    <!-- ========================= -->\n\n    <div\n      class=\"label\"\n      @[shouldMouseEnterEvent]=\"this.hover = true\"\n      @[shouldMouseLeaveEvent]=\"this.hover = false\"\n      :class=\"{\n        TransitionC: !miniMenu || (miniMenu && !showChildren),\n        menuexpand: showChildren,\n        [activeClass]: active,\n        [miniActiveClass]: miniActive,\n        labelHoverClass: (depth != 0 && miniMenu) || !miniMenu\n      }\"\n      @[keyOrClick]=\"labelClick\"\n      :style=\"{\n        [menuDirection == 'left' ? 'paddingLeft' : 'paddingRight']:\n          menuType === 'fully' ? `${depth * 18}px` : ``,\n        background: depth == 0 && !active && miniMenu ? 'none' : ''\n      }\"\n    >\n      <div\n        class=\"left\"\n        ref=\"labelRef\"\n        :class=\"{ marginAuto: miniMenu && depth === 0, collapseEnd: miniMenu }\"\n      >\n        <template\n          v-if=\"!removeIconSpace || (removeIconSpace && siblingsHaveIconProp)\"\n        >\n          <MenuItemIconVue v-if=\"!itemPrepandIcon\" :icon=\"item?.icon\" />\n          <!-- !!! slot for menuitem icon-->\n          <component\n            v-else-if=\"itemPrepandIcon\"\n            :is=\"itemPrepandIcon\"\n            :icon=\"item?.icon\"\n            :active=\"active\"\n            :miniActive=\"miniActive\"\n            :isChildrenMenuOpen=\"showChildren\"\n          ></component>\n        </template>\n        <template v-if=\"labelName\">\n          <span v-if=\"!menuItemLabel\" class=\"labelName\">{{ labelName }}</span>\n          <component\n            v-else\n            :labelName=\"labelName\"\n            :active=\"active\"\n            :miniActive=\"miniActive\"\n            :isChildrenMenuOpen=\"showChildren\"\n            :is=\"menuItemLabel\"\n          />\n        </template>\n      </div>\n      <template v-if=\"(miniMenu && depth != 0) || !miniMenu\">\n        <div\n          v-if=\"item.children && !itemApendIcon\"\n          class=\"icons postIconOpenAnima\"\n          :class=\"{ opened: showChildren }\"\n        ></div>\n        <!-- !!!  slot for menuitem prepand icon-->\n        <div v-if=\"item.children && itemApendIcon\">\n          <component\n            v-if=\"itemApendIcon\"\n            :is=\"itemApendIcon\"\n            :icon=\"item?.icon\"\n            :isChildrenMenuOpen=\"showChildren\"\n            :active=\"active\"\n            :miniActive=\"miniActive\"\n          >\n          </component>\n        </div>\n      </template>\n    </div>\n\n    <!-- ========================= -->\n    <!-- ========================= -->\n    <!--2 this container is for when menu Children when full width -->\n    <!-- ========================= -->\n    <!-- ========================= -->\n    <div v-if=\"!miniMenu || (depth != 0 && miniMenu)\">\n      <div\n        class=\"items-container\"\n        :class=\"{ 'small-menu': smallMenu }\"\n        :style=\"{ maxHeight: heifOfContainer, transition: transitionTime }\"\n        ref=\"container\"\n        v-if=\"item.children\"\n      >\n        <template v-if=\"renderChildren\">\n          <menu-item\n            v-for=\"(item, index) in item.children\"\n            :siblingsHaveIconProp=\"siblingsHaveIcon\"\n            :isParentFlat=\"siblingsHaveIconProp\"\n            :key=\"index\"\n            :item=\"item\"\n            :depth=\"depth + 1\"\n            :smallMenu=\"smallMenu\"\n          />\n        </template>\n      </div>\n    </div>\n\n    <!-- ========================= -->\n    <!-- ========================= -->\n    <!--3  this container is for mini Menu Children -->\n    <!-- ========================= -->\n    <!-- ========================= -->\n\n    <div\n      v-if=\"miniMenu && depth === 0 && !collapsed\"\n      :class=\"{ topContainer: depth == 0, vasopacitiy: !expanded }\"\n      ref=\"topContainerRef\"\n      :style=\"{\n        [MakeSpace\n          ? 'bottom'\n          : 'top']: `calc(${ContainerOffsetYConputed} - 1px)`,\n        [menuDirection]: `calc(${widthMiniMenu} - 1px)`,\n        maxHeight: TopcontainerHiefht,\n        width: showChildren ? '250px' : '0px',\n        zIndex: showChildren ? '850' : '849',\n        animationDelay: seTAnimationTimeOut ? '0.3s' : '0'\n      }\"\n    >\n      <div\n        @click=\"miniLabelClick\"\n        @mousewheel=\"mousewheelop\"\n        class=\"labelMini\"\n        :class=\"{\n          [miniActiveClass]: miniActive,\n          [activeClass]: active\n        }\"\n        :style=\"{\n          position: 'fixed',\n          whiteSpace: 'nowrap',\n          [menuDirection]: menuType === 'fully' ? '0px' : miniLabelDirection,\n          width: miniLabelWidth,\n          [MakeSpace ? 'bottom' : 'top']: ContainerOffsetYConputed,\n          opacity: depth === 0 && showChildren ? '1' : '0'\n        }\"\n      >\n        <!--main menu btn-->\n        <div\n          v-if=\"showChildren\"\n          class=\"left\"\n          :class=\"{ marginAuto: miniMenu && depth === 0 }\"\n          :style=\"{\n            [menuDirection]: widthMiniMenu,\n            top: labelMiniYYofsset + 'px'\n          }\"\n        >\n          <span v-if=\"!menuItemLabel\" class=\"labelName\">{{ item?.name }}</span>\n          <component\n            v-else\n            :labelName=\"item?.name\"\n            :active=\"active\"\n            :miniActive=\"miniActive\"\n            :isChildrenMenuOpen=\"showChildren\"\n            :is=\"menuItemLabel\"\n          />\n        </div>\n      </div>\n      <div class=\"labelminiSub\" v-if=\"depth == 0 && !MakeSpace\"></div>\n      <div\n        class=\"items-container\"\n        :class=\"{ 'small-menu': smallMenu }\"\n        :style=\"{\n          maxHeight: heifOfContainer,\n          transition: transitionTime\n        }\"\n        ref=\"container\"\n        v-if=\"item.children\"\n      >\n        <template v-if=\"renderChildren\">\n          <menu-item\n            v-for=\"(item, index) in item.children\"\n            :siblingsHaveIconProp=\"siblingsHaveIcon\"\n            :isParentFlat=\"siblingsHaveIconProp\"\n            :key=\"index\"\n            :item=\"item\"\n            :depth=\"depth + 1\"\n            :smallMenu=\"smallMenu\"\n            :setMaxHeightTopCProp=\"setMaxHeightTopC\"\n            :isMakeSpace=\"MakeSpace\"\n          />\n        </template>\n      </div>\n      <div class=\"labelminiSub\" v-if=\"depth == 0 && MakeSpace\"></div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport MenuItemIconVue from './MenuItemIcon.vue'\nimport { inject, onBeforeUnmount } from 'vue'\nexport default {\n  name: 'menu-item',\n  components: { MenuItemIconVue },\n  data: () => ({\n    showChildren: false,\n    expanded: false,\n    containerHeight: '0',\n    hieghtTimeout: null,\n    renderTimeOut: null,\n    renderChildren: false,\n    cacheHieght: null,\n    active: false,\n    miniActive: false,\n    hover: false,\n    ContainerOffsetY: 0,\n    id: null,\n    siblingsHaveIcon: false,\n    MakeSpace: false,\n    TopcontainerHiefht: 'fit-content',\n    labelMiniYofsset: 0,\n    labelMiniYYofsset: 0,\n    miniMenuOffset: 50,\n    seTAnimationTimeOut: false,\n    topConTime: null\n  }),\n\n  props: [\n    'smallMenu',\n    'header',\n    'depth',\n    'siblingsHaveIconProp',\n    'isParentFlat',\n    'item',\n    'isMakeSpace',\n    'setMaxHeightTopCProp'\n  ],\n  setup() {\n    const getSlots = inject('getSlotByName')\n    const {\n      animationDuration,\n      menuType,\n      widthMiniMenu,\n      childrenOpenAnimation,\n      removeIconSpace,\n      vueRouterEnabel,\n      keepChildrenOpen,\n      checkButtonActive,\n      ChildrenOpenActiveRoute,\n      collapsed,\n      closeOpenMenuOnHrefPush,\n      position\n    } = inject('sidebarProps')\n    const userAgentHeight = inject('browserAgent')\n    const currentRoute = inject('currentRoute')\n    const isSameUrl = inject('isSameUrl')\n    const extractChildrenRoutes = inject('extractChildrenRoutes')\n    const menuMounted = inject('menuMounted')\n    const miniMenu = inject('miniMenu')\n    const MenuScroll = inject('MenuScroll')\n    const MenuHover = inject('MenuHover')\n    const getRandomUid = inject('getRandomUid')\n    const updateCurrantItemHover = inject('updateCurrantItemHover')\n    const updateCurranContainerHover = inject('updateCurranContainerHover')\n    const CurrantItemHover = inject('CurrantItemHover')\n    const menuDirection = inject('menuDirection')\n    const emitOut = inject('emitOut')\n    const updateIsCollapsed = inject('updateIsCollapsed')\n    const routerPushBlockList = inject('routerPushBlockList')\n    const pushToRouterPush = inject('pushToRouterPush')\n    const symbolId = inject('symbolId')\n    let itemApendIcon = getSlots('itemApendIcon')\n    let itemPrepandIcon = getSlots('itemPrepandIcon')\n    let menuItemLabel = getSlots('menuItemLabel')\n\n    return {\n      animationDuration,\n      pushToRouterPush,\n      symbolId,\n      routerPushBlockList,\n      menuItemLabel,\n      updateIsCollapsed,\n      currentRoute,\n      menuMounted,\n      itemApendIcon,\n      itemPrepandIcon,\n      miniMenu,\n      MenuScroll,\n      MenuHover,\n      keepChildrenOpen,\n      ChildrenOpenActiveRoute,\n      closeOpenMenuOnHrefPush,\n      emitOut,\n      menuDirection,\n      checkButtonActive,\n      CurrantItemHover,\n      updateCurranContainerHover,\n      updateCurrantItemHover,\n      getRandomUid,\n      vueRouterEnabel,\n      extractChildrenRoutes,\n      isSameUrl,\n      menuType,\n      widthMiniMenu,\n      childrenOpenAnimation,\n      removeIconSpace,\n      collapsed,\n      userAgentHeight,\n      position\n    }\n  },\n  watch: {\n    routerPushBlockList(valur){\n      if(!this.closeOpenMenuOnHrefPush || (this.item[this.symbolId]===valur))return\n      if(this.item.children){\n        let isFound = false\n        const self = this\n        function backTrack(arr){\n          if(isFound) return\n          for(let i=0;i<arr.length;i++){\n            if(arr[i][self.symbolId] === valur){\n              isFound = true\n              break;\n            }\n            if(arr[i].children){\n              backTrack(arr[i].children)\n            }\n          }\n        }\n        backTrack(this.item.children)\n        if(!isFound){\n          this.closeItemChildren()\n        }\n      }\n    },\n    currentRoute() {\n      this.checkActive()\n    },\n    collapsed(val) {\n      if (val && this.miniMenu && this.depth === 0) {\n        this.closeItemChildren()\n      }\n    },\n    hover() {\n      //TODO :MAKE THIS MORE EFFICEANT\n\n      if (!this.id) {\n        this.id = this.getRandomUid()\n      }\n      if (this.hover) {\n        this.seTAnimationTimeOut = true\n        this.updateCurrantItemHover(this.id)\n        this.openItemCildren()\n        this.$nextTick(() => {\n          setTimeout(() => {\n            this.setItemOffsetHeight()\n          }, 0)\n          const y = this.$refs['labelRef'].getBoundingClientRect()\n          this.labelMiniYofsset = y[this.menuDirection]\n          this.labelMiniYYofsset = y.top\n        })\n      } else {\n        if (this.CurrantItemHover === this.id && this.MenuHover) {\n        } else {\n          this.closeItemChildren()\n        }\n      }\n    },\n    MenuHover() {\n      if (!this.MenuHover) {\n        this.closeItemChildren()\n      }\n    },\n    CurrantItemHover() {\n      //   this.miniActive =this.CurrantItemHover != this.id\n      if (this.CurrantItemHover != this.id) {\n        //this.miniActive = false\n        this.closeItemChildren()\n      } else {\n        // this.miniActive = true\n      }\n    },\n    MenuScroll() {\n      if (this.isMobile) {\n        this.closeItemChildren()\n      } else {\n        this.setItemOffsetHeight()\n        const y = this.$refs['labelRef'].getBoundingClientRect()\n        this.labelMiniYofsset = y[this.menuDirection]\n        this.labelMiniYYofsset = y.top\n      }\n    },\n    miniMenu() {\n      this.closeItemChildren()\n      this.$nextTick(() => {\n        this.setItemOffsetHeight()\n      })\n    }\n  },\n  created() {\n    this.checkActive()\n  },\n  mounted() {\n    this.checkSiblingsForIcon()\n    this.setItemOffsetHeight()\n    if (this.position != 'fixed') {\n      const listenr = () => {\n        if ('ontouchstart' in document.documentElement) {\n          this.closeItemChildren()\n          return\n        }\n        this.setItemOffsetHeight()\n        const y = this.$refs['labelRef'].getBoundingClientRect()\n        this.labelMiniYofsset = y[this.menuDirection]\n        this.labelMiniYYofsset = y.top\n      }\n      const removeSideBarListner = () => {\n        window.removeEventListener('scroll', listenr)\n      }\n      window.addEventListener('scroll', listenr)\n      onBeforeUnmount(removeSideBarListner)\n    }\n  },\n  computed: {\n    isMobile() {\n      return 'ontouchstart' in document.documentElement\n    },\n    miniActiveClass() {\n      return this.item?.miniActiveClass\n        ? this.item?.miniActiveClass\n        : 'miniActive'\n    },\n    activeClass() {\n      return this.item?.activeClass ? this.item?.activeClass : 'activeClass'\n    },\n    menuDirectionOposite() {\n      return this.menuDirection === 'right' ? 'left' : 'right'\n    },\n    labelName() {\n      if (this.miniMenu) {\n        return this.depth != 0 ? this.item?.name : false\n      }\n      return this.item?.name\n    },\n    heifOfContainer() {\n      return this.containerHeight === this.userAgentHeight\n        ? this.containerHeight\n        : this.containerHeight + 'px'\n    },\n    transitionTime() {\n      return `all ${this.animationDuration / 1000}s ease-in-out`\n    },\n    menuItemSlotData() {\n      return {\n        icon: { icon: this.item?.icon || {}, name: this.item?.name }\n      }\n    },\n    shouldMouseEnterEvent() {\n      return this.miniMenu && this.depth == 0 ? 'mouseover' : null\n    },\n    keyOrClick() {\n      if(!this.miniMenu) return 'click'\n      if(this.depth == 0){\n        if(this.expanded){\n          return this.isMobile ? 'touchend' : 'click'\n        }\n        return  this.isMobile ? '' : 'click'\n      }\n      return 'click'\n    },\n    shouldMouseLeaveEvent() {\n      return this.miniMenu && this.depth == 0 ? 'mouseleave' : null\n    },\n    ContainerOffsetYConputed() {\n      return `${this.ContainerOffsetY}px`\n    },\n    menuItemClass() {\n      let obj = {}\n      obj[`vas-${this.menuType}`] = true\n      obj[this.item?.class || ''] = this.item?.class\n      return {\n        miniCollapseIconWidth: this.miniMenu && this.depth == 0,\n        MenuItemWidthOnMiniCollapse: this.miniMenu && this.depth != 0,\n        menuExpanded:\n          this.menuType === 'fully' &&\n          ((!this.miniMenu && this.expanded && this.depth == 0) ||\n            (this.miniMenu && this.depth == 1 && this.expanded)),\n        noIconWidth:\n          this.removeIconSpace &&\n          !this.miniMenu &&\n          !this.siblingsHaveIconProp &&\n          this.isParentFlat,\n        noIconwidthMiniMenu:\n          this.removeIconSpace &&\n          this.miniMenu &&\n          this.depth != 0 &&\n          !this.siblingsHaveIconProp &&\n          this.isParentFlat,\n        ...obj\n      }\n      // return `menu-item-type-${this.menuType}`\n    },\n    miniLabelWidth() {\n      const zarib = Number(this.menuType != 'fully')\n      return this.expanded\n        ? `calc(${this.widthMiniMenu}*${zarib}/2 - ${this.$refs['menuItem'].clientWidth}*${zarib}px/2 + ${this.$refs['menuItem'].clientWidth}px + 250px - 1.5px)`\n        : `35px`\n    },\n    miniLabelDirection() {\n      return `calc((${this.widthMiniMenu} - ${this.miniMenuOffset}px) / 2)`\n    }\n  },\n\n  methods: {\n    mousewheelop(w) {\n      document.querySelector('.vas-menu').scrollBy(0, w.deltaY)\n    },\n    PushToTopOfCallStack(cb) {\n      setTimeout(() => {\n        cb()\n      }, 0)\n    },\n    resloveHref(href) {\n      if (this?.$router) {\n        const x = this.$router.resolve(href)\n        return x.href\n      }\n      return href\n    },\n    checkActive() {\n      if (!this.checkButtonActive) return\n      if (\n        this.item?.href &&\n        this.isSameUrl(this.resloveHref(this.item?.href))\n      ) {\n        this.active = true\n        this.miniActive = false\n      } else {\n        this.active = false\n        if (!this.item?.children) return\n        let hasFound = false\n        let x = this.extractChildrenRoutes(this.item?.children, 'href') || []\n        for (var i = 0; i < x.length; i++) {\n          if (this.isSameUrl(this.resloveHref(x[i]))) {\n            hasFound = true\n            // clearTimeout(this.hieghtTimeout)\n            // clearTimeout(this.renderTimeOut)\n            this.miniActive = true\n            if (this.menuMounted || this.miniMenu) break\n            if (this.ChildrenOpenActiveRoute) {\n              this.openItemCildren()\n            }\n            break\n          }\n        }\n        this.miniActive = hasFound\n      }\n    },\n    labelClick() {\n      if (this.hover) {\n        this.miniLabelClick()\n      } else {\n        this.toggleMenu()\n      }\n    },\n    clickCompose() {\n      if (this.item?.collapseOnClick) {\n        this.updateIsCollapsed(true)\n      }\n      this.emitOut('item-click', this.item)\n      if (this.vueRouterEnabel && this.item?.href && this.$router){\n        this.pushToRouterPush(this.item[this.symbolId])\n        this.$router?.push(this.item?.href)\n      }\n    },\n    miniLabelClick() {\n      this.clickCompose()\n    },\n    toggleMenu() {\n      this.clickCompose()\n      if (!this.item?.children) return\n      clearTimeout(this.hieghtTimeout)\n      clearTimeout(this.renderTimeOut)\n      if (this.showChildren) {\n        if(!(this.item?.href && this.closeOpenMenuOnHrefPush)){\n          this.closeItemChildren()\n        }\n      } else {\n        this.openItemCildren()\n      }\n      // this.showChildren ? this.openItemCildren() : this.closeItemChildren()\n    },\n    setSmallMenuDataForToggle(val) {\n      clearTimeout(this.topConTime)\n      clearTimeout(this.hieghtTimeout)\n      clearTimeout(this.renderTimeOut)\n      this.$nextTick(() => {\n        this.expanded = val\n      })\n      this.showChildren = val\n    },\n    checkSiblingsForIcon() {\n      if (!this.removeIconSpace && this.menuType == 'fully') return\n      if (!this.item?.children) return\n      for (var i = 0; i < this.item?.children.length; i++) {\n        if (this.item?.children[i]?.icon) {\n          this.siblingsHaveIcon = true\n          break\n        }\n      }\n    },\n    openItemCildren() {\n      if (this.depth === 1 && this.miniMenu) {\n        this.setMaxHeightTopCProp()\n      }\n      if (this.miniMenu && this.depth === 0) {\n        this.showChildren = true\n\n        this.$nextTick(() => {\n          this.expanded = true\n        })\n      }\n      if (!this.item?.children) return\n      if (this.expanded) return\n      this.setSmallMenuDataForToggle(true)\n      this.renderChildren = true\n      if (this.cacheHieght) {\n        this.containerHeight = this.cacheHieght\n      } else {\n        this.containerHeight = this.menuMounted\n          ? this.item?.children.length * this.$refs['menuItem']?.offsetHeight +\n            3\n          : this.userAgentHeight\n      }\n      this.cacheHieght = null\n      //if manue is not maounted remove a\n      if (!this.menuMounted) return\n      if (this.miniMenu && this.depth === 0) {\n        this.containerHeight = this.userAgentHeight\n      }\n      //add animation\n      this.hieghtTimeout = setTimeout(\n        () => {\n          this.containerHeight = this.userAgentHeight\n        },\n        this.childrenOpenAnimation ? this.animationDuration : 0\n      )\n    },\n    closeItemChildren() {\n      this.seTAnimationTimeOut = false\n      if (!this.menuCollapsed && this.miniMenu && this.depth === 0) {\n        this.setSmallMenuDataForToggle(false)\n        this.topConTime = setTimeout(() => {\n          this.containerHeight = 0\n          this.topConTime = null\n        }, this.animationDuration)\n        return\n      }\n      this.setSmallMenuDataForToggle(false)\n      if (!this.item?.children) return\n      if (!this.cacheHieght) {\n        this.cacheHieght = this.$refs['container']?.offsetHeight\n      }\n      this.containerHeight = this.$refs['container']?.offsetHeight\n      //this line must be pushed to top of call stack\n      this.PushToTopOfCallStack(() => {\n      })\n      setTimeout(() => {\n        this.$nextTick(()=>{\n          this.containerHeight = 0\n        })\n      }, 10);\n      //return if keepchildren open\n      if (this.keepChildrenOpen) return\n      this.renderTimeOut = setTimeout(\n        () => {\n          setTimeout(() => {\n             this.renderChildren = false\n          }, 20);\n           this.cacheHieght = null\n        },\n        this.childrenOpenAnimation ? this.animationDuration : 0\n      )\n    },\n    setMaxHeightTopC() {\n      const x = this.$refs['topContainerRef']?.getBoundingClientRect()\n      if (this.MakeSpace) {\n        this.TopcontainerHiefht = x.height + 'px'\n      } else {\n        this.TopcontainerHiefht =\n          x.height + innerHeight - (x.top + x.height) - 2 + 'px'\n      }\n    },\n    setItemOffsetHeight() {\n      if (this.depth == 0) {\n        const x = this.$refs['menuItem'].getBoundingClientRect()\n        const x1 = this.$refs['topContainerRef']?.getBoundingClientRect().height\n        let z = 0\n        if (this.item?.children) {\n          z = x.height * this.item?.children.length + x.height\n        }\n        if (x1 && z + x.top - 15 > innerHeight) {\n          this.ContainerOffsetY = innerHeight - x.bottom\n          this.MakeSpace = true\n        } else {\n          this.ContainerOffsetY = x.top\n          this.MakeSpace = false\n        }\n        this.miniMenuOffset = x.width\n      }\n    }\n  }\n}\n</script>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}