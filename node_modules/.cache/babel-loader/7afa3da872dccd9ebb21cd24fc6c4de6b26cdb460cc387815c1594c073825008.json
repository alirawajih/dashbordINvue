{"ast":null,"code":"import { inject, onBeforeUnmount } from 'vue';\nexport default {\n  name: 'menu-item',\n  components: {\n    MenuItemIconVue\n  },\n  data: () => ({\n    showChildren: false,\n    expanded: false,\n    containerHeight: '0',\n    hieghtTimeout: null,\n    renderTimeOut: null,\n    renderChildren: false,\n    cacheHieght: null,\n    active: false,\n    miniActive: false,\n    hover: false,\n    ContainerOffsetY: 0,\n    id: null,\n    siblingsHaveIcon: false,\n    MakeSpace: false,\n    TopcontainerHiefht: 'fit-content',\n    labelMiniYofsset: 0,\n    labelMiniYYofsset: 0,\n    miniMenuOffset: 50,\n    seTAnimationTimeOut: false,\n    topConTime: null\n  }),\n  props: ['smallMenu', 'header', 'depth', 'siblingsHaveIconProp', 'isParentFlat', 'item', 'isMakeSpace', 'setMaxHeightTopCProp'],\n  setup() {\n    const getSlots = inject('getSlotByName');\n    const {\n      animationDuration,\n      menuType,\n      widthMiniMenu,\n      childrenOpenAnimation,\n      removeIconSpace,\n      vueRouterEnabel,\n      keepChildrenOpen,\n      checkButtonActive,\n      ChildrenOpenActiveRoute,\n      collapsed,\n      closeOpenMenuOnHrefPush,\n      position\n    } = inject('sidebarProps');\n    const userAgentHeight = inject('browserAgent');\n    const currentRoute = inject('currentRoute');\n    const isSameUrl = inject('isSameUrl');\n    const extractChildrenRoutes = inject('extractChildrenRoutes');\n    const menuMounted = inject('menuMounted');\n    const miniMenu = inject('miniMenu');\n    const MenuScroll = inject('MenuScroll');\n    const MenuHover = inject('MenuHover');\n    const getRandomUid = inject('getRandomUid');\n    const updateCurrantItemHover = inject('updateCurrantItemHover');\n    const updateCurranContainerHover = inject('updateCurranContainerHover');\n    const CurrantItemHover = inject('CurrantItemHover');\n    const menuDirection = inject('menuDirection');\n    const emitOut = inject('emitOut');\n    const updateIsCollapsed = inject('updateIsCollapsed');\n    const routerPushBlockList = inject('routerPushBlockList');\n    const pushToRouterPush = inject('pushToRouterPush');\n    const symbolId = inject('symbolId');\n    let itemApendIcon = getSlots('itemApendIcon');\n    let itemPrepandIcon = getSlots('itemPrepandIcon');\n    let menuItemLabel = getSlots('menuItemLabel');\n    return {\n      animationDuration,\n      pushToRouterPush,\n      symbolId,\n      routerPushBlockList,\n      menuItemLabel,\n      updateIsCollapsed,\n      currentRoute,\n      menuMounted,\n      itemApendIcon,\n      itemPrepandIcon,\n      miniMenu,\n      MenuScroll,\n      MenuHover,\n      keepChildrenOpen,\n      ChildrenOpenActiveRoute,\n      closeOpenMenuOnHrefPush,\n      emitOut,\n      menuDirection,\n      checkButtonActive,\n      CurrantItemHover,\n      updateCurranContainerHover,\n      updateCurrantItemHover,\n      getRandomUid,\n      vueRouterEnabel,\n      extractChildrenRoutes,\n      isSameUrl,\n      menuType,\n      widthMiniMenu,\n      childrenOpenAnimation,\n      removeIconSpace,\n      collapsed,\n      userAgentHeight,\n      position\n    };\n  },\n  watch: {\n    routerPushBlockList(valur) {\n      if (!this.closeOpenMenuOnHrefPush || this.item[this.symbolId] === valur) return;\n      if (this.item.children) {\n        let isFound = false;\n        const self = this;\n        function backTrack(arr) {\n          if (isFound) return;\n          for (let i = 0; i < arr.length; i++) {\n            if (arr[i][self.symbolId] === valur) {\n              isFound = true;\n              break;\n            }\n            if (arr[i].children) {\n              backTrack(arr[i].children);\n            }\n          }\n        }\n        backTrack(this.item.children);\n        if (!isFound) {\n          this.closeItemChildren();\n        }\n      }\n    },\n    currentRoute() {\n      this.checkActive();\n    },\n    collapsed(val) {\n      if (val && this.miniMenu && this.depth === 0) {\n        this.closeItemChildren();\n      }\n    },\n    hover() {\n      //TODO :MAKE THIS MORE EFFICEANT\n\n      if (!this.id) {\n        this.id = this.getRandomUid();\n      }\n      if (this.hover) {\n        this.seTAnimationTimeOut = true;\n        this.updateCurrantItemHover(this.id);\n        this.openItemCildren();\n        this.$nextTick(() => {\n          setTimeout(() => {\n            this.setItemOffsetHeight();\n          }, 0);\n          const y = this.$refs['labelRef'].getBoundingClientRect();\n          this.labelMiniYofsset = y[this.menuDirection];\n          this.labelMiniYYofsset = y.top;\n        });\n      } else {\n        if (this.CurrantItemHover === this.id && this.MenuHover) {} else {\n          this.closeItemChildren();\n        }\n      }\n    },\n    MenuHover() {\n      if (!this.MenuHover) {\n        this.closeItemChildren();\n      }\n    },\n    CurrantItemHover() {\n      //   this.miniActive =this.CurrantItemHover != this.id\n      if (this.CurrantItemHover != this.id) {\n        //this.miniActive = false\n        this.closeItemChildren();\n      } else {\n        // this.miniActive = true\n      }\n    },\n    MenuScroll() {\n      if (this.isMobile) {\n        this.closeItemChildren();\n      } else {\n        this.setItemOffsetHeight();\n        const y = this.$refs['labelRef'].getBoundingClientRect();\n        this.labelMiniYofsset = y[this.menuDirection];\n        this.labelMiniYYofsset = y.top;\n      }\n    },\n    miniMenu() {\n      this.closeItemChildren();\n      this.$nextTick(() => {\n        this.setItemOffsetHeight();\n      });\n    }\n  },\n  created() {\n    this.checkActive();\n  },\n  mounted() {\n    this.checkSiblingsForIcon();\n    this.setItemOffsetHeight();\n    if (this.position != 'fixed') {\n      const listenr = () => {\n        if ('ontouchstart' in document.documentElement) {\n          this.closeItemChildren();\n          return;\n        }\n        this.setItemOffsetHeight();\n        const y = this.$refs['labelRef'].getBoundingClientRect();\n        this.labelMiniYofsset = y[this.menuDirection];\n        this.labelMiniYYofsset = y.top;\n      };\n      const removeSideBarListner = () => {\n        window.removeEventListener('scroll', listenr);\n      };\n      window.addEventListener('scroll', listenr);\n      onBeforeUnmount(removeSideBarListner);\n    }\n  },\n  computed: {\n    isMobile() {\n      return 'ontouchstart' in document.documentElement;\n    },\n    miniActiveClass() {\n      return this.item?.miniActiveClass ? this.item?.miniActiveClass : 'miniActive';\n    },\n    activeClass() {\n      return this.item?.activeClass ? this.item?.activeClass : 'activeClass';\n    },\n    menuDirectionOposite() {\n      return this.menuDirection === 'right' ? 'left' : 'right';\n    },\n    labelName() {\n      if (this.miniMenu) {\n        return this.depth != 0 ? this.item?.name : false;\n      }\n      return this.item?.name;\n    },\n    heifOfContainer() {\n      return this.containerHeight === this.userAgentHeight ? this.containerHeight : this.containerHeight + 'px';\n    },\n    transitionTime() {\n      return `all ${this.animationDuration / 1000}s ease-in-out`;\n    },\n    menuItemSlotData() {\n      return {\n        icon: {\n          icon: this.item?.icon || {},\n          name: this.item?.name\n        }\n      };\n    },\n    shouldMouseEnterEvent() {\n      return this.miniMenu && this.depth == 0 ? 'mouseover' : null;\n    },\n    keyOrClick() {\n      if (!this.miniMenu) return 'click';\n      if (this.depth == 0) {\n        if (this.expanded) {\n          return this.isMobile ? 'touchend' : 'click';\n        }\n        return this.isMobile ? '' : 'click';\n      }\n      return 'click';\n    },\n    shouldMouseLeaveEvent() {\n      return this.miniMenu && this.depth == 0 ? 'mouseleave' : null;\n    },\n    ContainerOffsetYConputed() {\n      return `${this.ContainerOffsetY}px`;\n    },\n    menuItemClass() {\n      let obj = {};\n      obj[`vas-${this.menuType}`] = true;\n      obj[this.item?.class || ''] = this.item?.class;\n      return {\n        miniCollapseIconWidth: this.miniMenu && this.depth == 0,\n        MenuItemWidthOnMiniCollapse: this.miniMenu && this.depth != 0,\n        menuExpanded: this.menuType === 'fully' && (!this.miniMenu && this.expanded && this.depth == 0 || this.miniMenu && this.depth == 1 && this.expanded),\n        noIconWidth: this.removeIconSpace && !this.miniMenu && !this.siblingsHaveIconProp && this.isParentFlat,\n        noIconwidthMiniMenu: this.removeIconSpace && this.miniMenu && this.depth != 0 && !this.siblingsHaveIconProp && this.isParentFlat,\n        ...obj\n      };\n      // return `menu-item-type-${this.menuType}`\n    },\n\n    miniLabelWidth() {\n      const zarib = Number(this.menuType != 'fully');\n      return this.expanded ? `calc(${this.widthMiniMenu}*${zarib}/2 - ${this.$refs['menuItem'].clientWidth}*${zarib}px/2 + ${this.$refs['menuItem'].clientWidth}px + 250px - 1.5px)` : `35px`;\n    },\n    miniLabelDirection() {\n      return `calc((${this.widthMiniMenu} - ${this.miniMenuOffset}px) / 2)`;\n    }\n  },\n  methods: {\n    mousewheelop(w) {\n      document.querySelector('.vas-menu').scrollBy(0, w.deltaY);\n    },\n    PushToTopOfCallStack(cb) {\n      setTimeout(() => {\n        cb();\n      }, 0);\n    },\n    resloveHref(href) {\n      if (this?.$router) {\n        const x = this.$router.resolve(href);\n        return x.href;\n      }\n      return href;\n    },\n    checkActive() {\n      if (!this.checkButtonActive) return;\n      if (this.item?.href && this.isSameUrl(this.resloveHref(this.item?.href))) {\n        this.active = true;\n        this.miniActive = false;\n      } else {\n        this.active = false;\n        if (!this.item?.children) return;\n        let hasFound = false;\n        let x = this.extractChildrenRoutes(this.item?.children, 'href') || [];\n        for (var i = 0; i < x.length; i++) {\n          if (this.isSameUrl(this.resloveHref(x[i]))) {\n            hasFound = true;\n            // clearTimeout(this.hieghtTimeout)\n            // clearTimeout(this.renderTimeOut)\n            this.miniActive = true;\n            if (this.menuMounted || this.miniMenu) break;\n            if (this.ChildrenOpenActiveRoute) {\n              this.openItemCildren();\n            }\n            break;\n          }\n        }\n        this.miniActive = hasFound;\n      }\n    },\n    labelClick() {\n      if (this.hover) {\n        this.miniLabelClick();\n      } else {\n        this.toggleMenu();\n      }\n    },\n    clickCompose() {\n      if (this.item?.collapseOnClick) {\n        this.updateIsCollapsed(true);\n      }\n      this.emitOut('item-click', this.item);\n      if (this.vueRouterEnabel && this.item?.href && this.$router) {\n        this.pushToRouterPush(this.item[this.symbolId]);\n        this.$router?.push(this.item?.href);\n      }\n    },\n    miniLabelClick() {\n      this.clickCompose();\n    },\n    toggleMenu() {\n      this.clickCompose();\n      if (!this.item?.children) return;\n      clearTimeout(this.hieghtTimeout);\n      clearTimeout(this.renderTimeOut);\n      if (this.showChildren) {\n        if (!(this.item?.href && this.closeOpenMenuOnHrefPush)) {\n          this.closeItemChildren();\n        }\n      } else {\n        this.openItemCildren();\n      }\n      // this.showChildren ? this.openItemCildren() : this.closeItemChildren()\n    },\n\n    setSmallMenuDataForToggle(val) {\n      clearTimeout(this.topConTime);\n      clearTimeout(this.hieghtTimeout);\n      clearTimeout(this.renderTimeOut);\n      this.$nextTick(() => {\n        this.expanded = val;\n      });\n      this.showChildren = val;\n    },\n    checkSiblingsForIcon() {\n      if (!this.removeIconSpace && this.menuType == 'fully') return;\n      if (!this.item?.children) return;\n      for (var i = 0; i < this.item?.children.length; i++) {\n        if (this.item?.children[i]?.icon) {\n          this.siblingsHaveIcon = true;\n          break;\n        }\n      }\n    },\n    openItemCildren() {\n      if (this.depth === 1 && this.miniMenu) {\n        this.setMaxHeightTopCProp();\n      }\n      if (this.miniMenu && this.depth === 0) {\n        this.showChildren = true;\n        this.$nextTick(() => {\n          this.expanded = true;\n        });\n      }\n      if (!this.item?.children) return;\n      if (this.expanded) return;\n      this.setSmallMenuDataForToggle(true);\n      this.renderChildren = true;\n      if (this.cacheHieght) {\n        this.containerHeight = this.cacheHieght;\n      } else {\n        this.containerHeight = this.menuMounted ? this.item?.children.length * this.$refs['menuItem']?.offsetHeight + 3 : this.userAgentHeight;\n      }\n      this.cacheHieght = null;\n      //if manue is not maounted remove a\n      if (!this.menuMounted) return;\n      if (this.miniMenu && this.depth === 0) {\n        this.containerHeight = this.userAgentHeight;\n      }\n      //add animation\n      this.hieghtTimeout = setTimeout(() => {\n        this.containerHeight = this.userAgentHeight;\n      }, this.childrenOpenAnimation ? this.animationDuration : 0);\n    },\n    closeItemChildren() {\n      this.seTAnimationTimeOut = false;\n      if (!this.menuCollapsed && this.miniMenu && this.depth === 0) {\n        this.setSmallMenuDataForToggle(false);\n        this.topConTime = setTimeout(() => {\n          this.containerHeight = 0;\n          this.topConTime = null;\n        }, this.animationDuration);\n        return;\n      }\n      this.setSmallMenuDataForToggle(false);\n      if (!this.item?.children) return;\n      if (!this.cacheHieght) {\n        this.cacheHieght = this.$refs['container']?.offsetHeight;\n      }\n      this.containerHeight = this.$refs['container']?.offsetHeight;\n      //this line must be pushed to top of call stack\n      this.PushToTopOfCallStack(() => {});\n      setTimeout(() => {\n        this.$nextTick(() => {\n          this.containerHeight = 0;\n        });\n      }, 10);\n      //return if keepchildren open\n      if (this.keepChildrenOpen) return;\n      this.renderTimeOut = setTimeout(() => {\n        setTimeout(() => {\n          this.renderChildren = false;\n        }, 20);\n        this.cacheHieght = null;\n      }, this.childrenOpenAnimation ? this.animationDuration : 0);\n    },\n    setMaxHeightTopC() {\n      const x = this.$refs['topContainerRef']?.getBoundingClientRect();\n      if (this.MakeSpace) {\n        this.TopcontainerHiefht = x.height + 'px';\n      } else {\n        this.TopcontainerHiefht = x.height + innerHeight - (x.top + x.height) - 2 + 'px';\n      }\n    },\n    setItemOffsetHeight() {\n      if (this.depth == 0) {\n        const x = this.$refs['menuItem'].getBoundingClientRect();\n        const x1 = this.$refs['topContainerRef']?.getBoundingClientRect().height;\n        let z = 0;\n        if (this.item?.children) {\n          z = x.height * this.item?.children.length + x.height;\n        }\n        if (x1 && z + x.top - 15 > innerHeight) {\n          this.ContainerOffsetY = innerHeight - x.bottom;\n          this.MakeSpace = true;\n        } else {\n          this.ContainerOffsetY = x.top;\n          this.MakeSpace = false;\n        }\n        this.miniMenuOffset = x.width;\n      }\n    }\n  }\n};","map":{"version":3,"names":["inject","onBeforeUnmount","name","components","MenuItemIconVue","data","showChildren","expanded","containerHeight","hieghtTimeout","renderTimeOut","renderChildren","cacheHieght","active","miniActive","hover","ContainerOffsetY","id","siblingsHaveIcon","MakeSpace","TopcontainerHiefht","labelMiniYofsset","labelMiniYYofsset","miniMenuOffset","seTAnimationTimeOut","topConTime","props","setup","getSlots","animationDuration","menuType","widthMiniMenu","childrenOpenAnimation","removeIconSpace","vueRouterEnabel","keepChildrenOpen","checkButtonActive","ChildrenOpenActiveRoute","collapsed","closeOpenMenuOnHrefPush","position","userAgentHeight","currentRoute","isSameUrl","extractChildrenRoutes","menuMounted","miniMenu","MenuScroll","MenuHover","getRandomUid","updateCurrantItemHover","updateCurranContainerHover","CurrantItemHover","menuDirection","emitOut","updateIsCollapsed","routerPushBlockList","pushToRouterPush","symbolId","itemApendIcon","itemPrepandIcon","menuItemLabel","watch","valur","item","children","isFound","self","backTrack","arr","i","length","closeItemChildren","checkActive","val","depth","openItemCildren","$nextTick","setTimeout","setItemOffsetHeight","y","$refs","getBoundingClientRect","top","isMobile","created","mounted","checkSiblingsForIcon","listenr","document","documentElement","removeSideBarListner","window","removeEventListener","addEventListener","computed","miniActiveClass","activeClass","menuDirectionOposite","labelName","heifOfContainer","transitionTime","menuItemSlotData","icon","shouldMouseEnterEvent","keyOrClick","shouldMouseLeaveEvent","ContainerOffsetYConputed","menuItemClass","obj","class","miniCollapseIconWidth","MenuItemWidthOnMiniCollapse","menuExpanded","noIconWidth","siblingsHaveIconProp","isParentFlat","noIconwidthMiniMenu","miniLabelWidth","zarib","Number","clientWidth","miniLabelDirection","methods","mousewheelop","w","querySelector","scrollBy","deltaY","PushToTopOfCallStack","cb","resloveHref","href","$router","x","resolve","hasFound","labelClick","miniLabelClick","toggleMenu","clickCompose","collapseOnClick","push","clearTimeout","setSmallMenuDataForToggle","setMaxHeightTopCProp","offsetHeight","menuCollapsed","setMaxHeightTopC","height","innerHeight","x1","z","bottom","width"],"sources":["/var/www/html/project/Dash_Vuexy-master/src/components/chat.vue"],"sourcesContent":["<template>\n  <div\n    :class=\"menuItemClass\"\n    ref=\"menuItem\"\n    class=\"menu-item-base alignCenter\"\n    :style=\"{\n      float: miniMenu && depth === 1 ? menuDirection : menuDirectionOposite\n    }\"\n  >\n    <div v-if=\"active\" class=\"BlockBack\"></div>\n    <!-- ========================= -->\n    <!-- ========================= -->\n    <!-- 1 this is the menu label  -->\n    <!-- ========================= -->\n    <!-- ========================= -->\n\n    <div\n      class=\"label\"\n      @[shouldMouseEnterEvent]=\"this.hover = true\"\n      @[shouldMouseLeaveEvent]=\"this.hover = false\"\n      :class=\"{\n        TransitionC: !miniMenu || (miniMenu && !showChildren),\n        menuexpand: showChildren,\n        [activeClass]: active,\n        [miniActiveClass]: miniActive,\n        labelHoverClass: (depth != 0 && miniMenu) || !miniMenu\n      }\"\n      @[keyOrClick]=\"labelClick\"\n      :style=\"{\n        [menuDirection == 'left' ? 'paddingLeft' : 'paddingRight']:\n          menuType === 'fully' ? `${depth * 18}px` : ``,\n        background: depth == 0 && !active && miniMenu ? 'none' : ''\n      }\"\n    >\n      <div\n        class=\"left\"\n        ref=\"labelRef\"\n        :class=\"{ marginAuto: miniMenu && depth === 0, collapseEnd: miniMenu }\"\n      >\n        <template\n          v-if=\"!removeIconSpace || (removeIconSpace && siblingsHaveIconProp)\"\n        >\n          \n          <!-- !!! slot for menuitem icon-->\n          <component\n            v-else-if=\"itemPrepandIcon\"\n            :is=\"itemPrepandIcon\"\n            :icon=\"item?.icon\"\n            :active=\"active\"\n            :miniActive=\"miniActive\"\n            :isChildrenMenuOpen=\"showChildren\"\n          ></component>\n        </template>\n        <template v-if=\"labelName\">\n          <span v-if=\"!menuItemLabel\" class=\"labelName\">{{ labelName }}</span>\n          <component\n            v-else\n            :labelName=\"labelName\"\n            :active=\"active\"\n            :miniActive=\"miniActive\"\n            :isChildrenMenuOpen=\"showChildren\"\n            :is=\"menuItemLabel\"\n          />\n        </template>\n      </div>\n      <template v-if=\"(miniMenu && depth != 0) || !miniMenu\">\n        <div\n          v-if=\"item.children && !itemApendIcon\"\n          class=\"icons postIconOpenAnima\"\n          :class=\"{ opened: showChildren }\"\n        ></div>\n        <!-- !!!  slot for menuitem prepand icon-->\n        <div v-if=\"item.children && itemApendIcon\">\n          <component\n            v-if=\"itemApendIcon\"\n            :is=\"itemApendIcon\"\n            :icon=\"item?.icon\"\n            :isChildrenMenuOpen=\"showChildren\"\n            :active=\"active\"\n            :miniActive=\"miniActive\"\n          >\n          </component>\n        </div>\n      </template>\n    </div>\n\n    <!-- ========================= -->\n    <!-- ========================= -->\n    <!--2 this container is for when menu Children when full width -->\n    <!-- ========================= -->\n    <!-- ========================= -->\n    <div v-if=\"!miniMenu || (depth != 0 && miniMenu)\">\n      <div\n        class=\"items-container\"\n        :class=\"{ 'small-menu': smallMenu }\"\n        :style=\"{ maxHeight: heifOfContainer, transition: transitionTime }\"\n        ref=\"container\"\n        v-if=\"item.children\"\n      >\n        <template v-if=\"renderChildren\">\n          <menu-item\n            v-for=\"(item, index) in item.children\"\n            :siblingsHaveIconProp=\"siblingsHaveIcon\"\n            :isParentFlat=\"siblingsHaveIconProp\"\n            :key=\"index\"\n            :item=\"item\"\n            :depth=\"depth + 1\"\n            :smallMenu=\"smallMenu\"\n          />\n        </template>\n      </div>\n    </div>\n\n    <!-- ========================= -->\n    <!-- ========================= -->\n    <!--3  this container is for mini Menu Children -->\n    <!-- ========================= -->\n    <!-- ========================= -->\n\n    <div\n      v-if=\"miniMenu && depth === 0 && !collapsed\"\n      :class=\"{ topContainer: depth == 0, vasopacitiy: !expanded }\"\n      ref=\"topContainerRef\"\n      :style=\"{\n        [MakeSpace\n          ? 'bottom'\n          : 'top']: `calc(${ContainerOffsetYConputed} - 1px)`,\n        [menuDirection]: `calc(${widthMiniMenu} - 1px)`,\n        maxHeight: TopcontainerHiefht,\n        width: showChildren ? '250px' : '0px',\n        zIndex: showChildren ? '850' : '849',\n        animationDelay: seTAnimationTimeOut ? '0.3s' : '0'\n      }\"\n    >\n      <div\n        @click=\"miniLabelClick\"\n        @mousewheel=\"mousewheelop\"\n        class=\"labelMini\"\n        :class=\"{\n          [miniActiveClass]: miniActive,\n          [activeClass]: active\n        }\"\n        :style=\"{\n          position: 'fixed',\n          whiteSpace: 'nowrap',\n          [menuDirection]: menuType === 'fully' ? '0px' : miniLabelDirection,\n          width: miniLabelWidth,\n          [MakeSpace ? 'bottom' : 'top']: ContainerOffsetYConputed,\n          opacity: depth === 0 && showChildren ? '1' : '0'\n        }\"\n      >\n        <!--main menu btn-->\n        <div\n          v-if=\"showChildren\"\n          class=\"left\"\n          :class=\"{ marginAuto: miniMenu && depth === 0 }\"\n          :style=\"{\n            [menuDirection]: widthMiniMenu,\n            top: labelMiniYYofsset + 'px'\n          }\"\n        >\n          <span v-if=\"!menuItemLabel\" class=\"labelName\">{{ item?.name }}</span>\n          <component\n            v-else\n            :labelName=\"item?.name\"\n            :active=\"active\"\n            :miniActive=\"miniActive\"\n            :isChildrenMenuOpen=\"showChildren\"\n            :is=\"menuItemLabel\"\n          />\n        </div>\n      </div>\n      <div class=\"labelminiSub\" v-if=\"depth == 0 && !MakeSpace\"></div>\n      <div\n        class=\"items-container\"\n        :class=\"{ 'small-menu': smallMenu }\"\n        :style=\"{\n          maxHeight: heifOfContainer,\n          transition: transitionTime\n        }\"\n        ref=\"container\"\n        v-if=\"item.children\"\n      >\n        <template v-if=\"renderChildren\">\n          <menu-item\n            v-for=\"(item, index) in item.children\"\n            :siblingsHaveIconProp=\"siblingsHaveIcon\"\n            :isParentFlat=\"siblingsHaveIconProp\"\n            :key=\"index\"\n            :item=\"item\"\n            :depth=\"depth + 1\"\n            :smallMenu=\"smallMenu\"\n            :setMaxHeightTopCProp=\"setMaxHeightTopC\"\n            :isMakeSpace=\"MakeSpace\"\n          />\n        </template>\n      </div>\n      <div class=\"labelminiSub\" v-if=\"depth == 0 && MakeSpace\"></div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { inject, onBeforeUnmount } from 'vue'\nexport default {\n  name: 'menu-item',\n  components: { MenuItemIconVue },\n  data: () => ({\n    showChildren: false,\n    expanded: false,\n    containerHeight: '0',\n    hieghtTimeout: null,\n    renderTimeOut: null,\n    renderChildren: false,\n    cacheHieght: null,\n    active: false,\n    miniActive: false,\n    hover: false,\n    ContainerOffsetY: 0,\n    id: null,\n    siblingsHaveIcon: false,\n    MakeSpace: false,\n    TopcontainerHiefht: 'fit-content',\n    labelMiniYofsset: 0,\n    labelMiniYYofsset: 0,\n    miniMenuOffset: 50,\n    seTAnimationTimeOut: false,\n    topConTime: null\n  }),\n\n  props: [\n    'smallMenu',\n    'header',\n    'depth',\n    'siblingsHaveIconProp',\n    'isParentFlat',\n    'item',\n    'isMakeSpace',\n    'setMaxHeightTopCProp'\n  ],\n  setup() {\n    const getSlots = inject('getSlotByName')\n    const {\n      animationDuration,\n      menuType,\n      widthMiniMenu,\n      childrenOpenAnimation,\n      removeIconSpace,\n      vueRouterEnabel,\n      keepChildrenOpen,\n      checkButtonActive,\n      ChildrenOpenActiveRoute,\n      collapsed,\n      closeOpenMenuOnHrefPush,\n      position\n    } = inject('sidebarProps')\n    const userAgentHeight = inject('browserAgent')\n    const currentRoute = inject('currentRoute')\n    const isSameUrl = inject('isSameUrl')\n    const extractChildrenRoutes = inject('extractChildrenRoutes')\n    const menuMounted = inject('menuMounted')\n    const miniMenu = inject('miniMenu')\n    const MenuScroll = inject('MenuScroll')\n    const MenuHover = inject('MenuHover')\n    const getRandomUid = inject('getRandomUid')\n    const updateCurrantItemHover = inject('updateCurrantItemHover')\n    const updateCurranContainerHover = inject('updateCurranContainerHover')\n    const CurrantItemHover = inject('CurrantItemHover')\n    const menuDirection = inject('menuDirection')\n    const emitOut = inject('emitOut')\n    const updateIsCollapsed = inject('updateIsCollapsed')\n    const routerPushBlockList = inject('routerPushBlockList')\n    const pushToRouterPush = inject('pushToRouterPush')\n    const symbolId = inject('symbolId')\n    let itemApendIcon = getSlots('itemApendIcon')\n    let itemPrepandIcon = getSlots('itemPrepandIcon')\n    let menuItemLabel = getSlots('menuItemLabel')\n\n    return {\n      animationDuration,\n      pushToRouterPush,\n      symbolId,\n      routerPushBlockList,\n      menuItemLabel,\n      updateIsCollapsed,\n      currentRoute,\n      menuMounted,\n      itemApendIcon,\n      itemPrepandIcon,\n      miniMenu,\n      MenuScroll,\n      MenuHover,\n      keepChildrenOpen,\n      ChildrenOpenActiveRoute,\n      closeOpenMenuOnHrefPush,\n      emitOut,\n      menuDirection,\n      checkButtonActive,\n      CurrantItemHover,\n      updateCurranContainerHover,\n      updateCurrantItemHover,\n      getRandomUid,\n      vueRouterEnabel,\n      extractChildrenRoutes,\n      isSameUrl,\n      menuType,\n      widthMiniMenu,\n      childrenOpenAnimation,\n      removeIconSpace,\n      collapsed,\n      userAgentHeight,\n      position\n    }\n  },\n  watch: {\n    routerPushBlockList(valur){\n      if(!this.closeOpenMenuOnHrefPush || (this.item[this.symbolId]===valur))return\n      if(this.item.children){\n        let isFound = false\n        const self = this\n        function backTrack(arr){\n          if(isFound) return\n          for(let i=0;i<arr.length;i++){\n            if(arr[i][self.symbolId] === valur){\n              isFound = true\n              break;\n            }\n            if(arr[i].children){\n              backTrack(arr[i].children)\n            }\n          }\n        }\n        backTrack(this.item.children)\n        if(!isFound){\n          this.closeItemChildren()\n        }\n      }\n    },\n    currentRoute() {\n      this.checkActive()\n    },\n    collapsed(val) {\n      if (val && this.miniMenu && this.depth === 0) {\n        this.closeItemChildren()\n      }\n    },\n    hover() {\n      //TODO :MAKE THIS MORE EFFICEANT\n\n      if (!this.id) {\n        this.id = this.getRandomUid()\n      }\n      if (this.hover) {\n        this.seTAnimationTimeOut = true\n        this.updateCurrantItemHover(this.id)\n        this.openItemCildren()\n        this.$nextTick(() => {\n          setTimeout(() => {\n            this.setItemOffsetHeight()\n          }, 0)\n          const y = this.$refs['labelRef'].getBoundingClientRect()\n          this.labelMiniYofsset = y[this.menuDirection]\n          this.labelMiniYYofsset = y.top\n        })\n      } else {\n        if (this.CurrantItemHover === this.id && this.MenuHover) {\n        } else {\n          this.closeItemChildren()\n        }\n      }\n    },\n    MenuHover() {\n      if (!this.MenuHover) {\n        this.closeItemChildren()\n      }\n    },\n    CurrantItemHover() {\n      //   this.miniActive =this.CurrantItemHover != this.id\n      if (this.CurrantItemHover != this.id) {\n        //this.miniActive = false\n        this.closeItemChildren()\n      } else {\n        // this.miniActive = true\n      }\n    },\n    MenuScroll() {\n      if (this.isMobile) {\n        this.closeItemChildren()\n      } else {\n        this.setItemOffsetHeight()\n        const y = this.$refs['labelRef'].getBoundingClientRect()\n        this.labelMiniYofsset = y[this.menuDirection]\n        this.labelMiniYYofsset = y.top\n      }\n    },\n    miniMenu() {\n      this.closeItemChildren()\n      this.$nextTick(() => {\n        this.setItemOffsetHeight()\n      })\n    }\n  },\n  created() {\n    this.checkActive()\n  },\n  mounted() {\n    this.checkSiblingsForIcon()\n    this.setItemOffsetHeight()\n    if (this.position != 'fixed') {\n      const listenr = () => {\n        if ('ontouchstart' in document.documentElement) {\n          this.closeItemChildren()\n          return\n        }\n        this.setItemOffsetHeight()\n        const y = this.$refs['labelRef'].getBoundingClientRect()\n        this.labelMiniYofsset = y[this.menuDirection]\n        this.labelMiniYYofsset = y.top\n      }\n      const removeSideBarListner = () => {\n        window.removeEventListener('scroll', listenr)\n      }\n      window.addEventListener('scroll', listenr)\n      onBeforeUnmount(removeSideBarListner)\n    }\n  },\n  computed: {\n    isMobile() {\n      return 'ontouchstart' in document.documentElement\n    },\n    miniActiveClass() {\n      return this.item?.miniActiveClass\n        ? this.item?.miniActiveClass\n        : 'miniActive'\n    },\n    activeClass() {\n      return this.item?.activeClass ? this.item?.activeClass : 'activeClass'\n    },\n    menuDirectionOposite() {\n      return this.menuDirection === 'right' ? 'left' : 'right'\n    },\n    labelName() {\n      if (this.miniMenu) {\n        return this.depth != 0 ? this.item?.name : false\n      }\n      return this.item?.name\n    },\n    heifOfContainer() {\n      return this.containerHeight === this.userAgentHeight\n        ? this.containerHeight\n        : this.containerHeight + 'px'\n    },\n    transitionTime() {\n      return `all ${this.animationDuration / 1000}s ease-in-out`\n    },\n    menuItemSlotData() {\n      return {\n        icon: { icon: this.item?.icon || {}, name: this.item?.name }\n      }\n    },\n    shouldMouseEnterEvent() {\n      return this.miniMenu && this.depth == 0 ? 'mouseover' : null\n    },\n    keyOrClick() {\n      if(!this.miniMenu) return 'click'\n      if(this.depth == 0){\n        if(this.expanded){\n          return this.isMobile ? 'touchend' : 'click'\n        }\n        return  this.isMobile ? '' : 'click'\n      }\n      return 'click'\n    },\n    shouldMouseLeaveEvent() {\n      return this.miniMenu && this.depth == 0 ? 'mouseleave' : null\n    },\n    ContainerOffsetYConputed() {\n      return `${this.ContainerOffsetY}px`\n    },\n    menuItemClass() {\n      let obj = {}\n      obj[`vas-${this.menuType}`] = true\n      obj[this.item?.class || ''] = this.item?.class\n      return {\n        miniCollapseIconWidth: this.miniMenu && this.depth == 0,\n        MenuItemWidthOnMiniCollapse: this.miniMenu && this.depth != 0,\n        menuExpanded:\n          this.menuType === 'fully' &&\n          ((!this.miniMenu && this.expanded && this.depth == 0) ||\n            (this.miniMenu && this.depth == 1 && this.expanded)),\n        noIconWidth:\n          this.removeIconSpace &&\n          !this.miniMenu &&\n          !this.siblingsHaveIconProp &&\n          this.isParentFlat,\n        noIconwidthMiniMenu:\n          this.removeIconSpace &&\n          this.miniMenu &&\n          this.depth != 0 &&\n          !this.siblingsHaveIconProp &&\n          this.isParentFlat,\n        ...obj\n      }\n      // return `menu-item-type-${this.menuType}`\n    },\n    miniLabelWidth() {\n      const zarib = Number(this.menuType != 'fully')\n      return this.expanded\n        ? `calc(${this.widthMiniMenu}*${zarib}/2 - ${this.$refs['menuItem'].clientWidth}*${zarib}px/2 + ${this.$refs['menuItem'].clientWidth}px + 250px - 1.5px)`\n        : `35px`\n    },\n    miniLabelDirection() {\n      return `calc((${this.widthMiniMenu} - ${this.miniMenuOffset}px) / 2)`\n    }\n  },\n\n  methods: {\n    mousewheelop(w) {\n      document.querySelector('.vas-menu').scrollBy(0, w.deltaY)\n    },\n    PushToTopOfCallStack(cb) {\n      setTimeout(() => {\n        cb()\n      }, 0)\n    },\n    resloveHref(href) {\n      if (this?.$router) {\n        const x = this.$router.resolve(href)\n        return x.href\n      }\n      return href\n    },\n    checkActive() {\n      if (!this.checkButtonActive) return\n      if (\n        this.item?.href &&\n        this.isSameUrl(this.resloveHref(this.item?.href))\n      ) {\n        this.active = true\n        this.miniActive = false\n      } else {\n        this.active = false\n        if (!this.item?.children) return\n        let hasFound = false\n        let x = this.extractChildrenRoutes(this.item?.children, 'href') || []\n        for (var i = 0; i < x.length; i++) {\n          if (this.isSameUrl(this.resloveHref(x[i]))) {\n            hasFound = true\n            // clearTimeout(this.hieghtTimeout)\n            // clearTimeout(this.renderTimeOut)\n            this.miniActive = true\n            if (this.menuMounted || this.miniMenu) break\n            if (this.ChildrenOpenActiveRoute) {\n              this.openItemCildren()\n            }\n            break\n          }\n        }\n        this.miniActive = hasFound\n      }\n    },\n    labelClick() {\n      if (this.hover) {\n        this.miniLabelClick()\n      } else {\n        this.toggleMenu()\n      }\n    },\n    clickCompose() {\n      if (this.item?.collapseOnClick) {\n        this.updateIsCollapsed(true)\n      }\n      this.emitOut('item-click', this.item)\n      if (this.vueRouterEnabel && this.item?.href && this.$router){\n        this.pushToRouterPush(this.item[this.symbolId])\n        this.$router?.push(this.item?.href)\n      }\n    },\n    miniLabelClick() {\n      this.clickCompose()\n    },\n    toggleMenu() {\n      this.clickCompose()\n      if (!this.item?.children) return\n      clearTimeout(this.hieghtTimeout)\n      clearTimeout(this.renderTimeOut)\n      if (this.showChildren) {\n        if(!(this.item?.href && this.closeOpenMenuOnHrefPush)){\n          this.closeItemChildren()\n        }\n      } else {\n        this.openItemCildren()\n      }\n      // this.showChildren ? this.openItemCildren() : this.closeItemChildren()\n    },\n    setSmallMenuDataForToggle(val) {\n      clearTimeout(this.topConTime)\n      clearTimeout(this.hieghtTimeout)\n      clearTimeout(this.renderTimeOut)\n      this.$nextTick(() => {\n        this.expanded = val\n      })\n      this.showChildren = val\n    },\n    checkSiblingsForIcon() {\n      if (!this.removeIconSpace && this.menuType == 'fully') return\n      if (!this.item?.children) return\n      for (var i = 0; i < this.item?.children.length; i++) {\n        if (this.item?.children[i]?.icon) {\n          this.siblingsHaveIcon = true\n          break\n        }\n      }\n    },\n    openItemCildren() {\n      if (this.depth === 1 && this.miniMenu) {\n        this.setMaxHeightTopCProp()\n      }\n      if (this.miniMenu && this.depth === 0) {\n        this.showChildren = true\n\n        this.$nextTick(() => {\n          this.expanded = true\n        })\n      }\n      if (!this.item?.children) return\n      if (this.expanded) return\n      this.setSmallMenuDataForToggle(true)\n      this.renderChildren = true\n      if (this.cacheHieght) {\n        this.containerHeight = this.cacheHieght\n      } else {\n        this.containerHeight = this.menuMounted\n          ? this.item?.children.length * this.$refs['menuItem']?.offsetHeight +\n            3\n          : this.userAgentHeight\n      }\n      this.cacheHieght = null\n      //if manue is not maounted remove a\n      if (!this.menuMounted) return\n      if (this.miniMenu && this.depth === 0) {\n        this.containerHeight = this.userAgentHeight\n      }\n      //add animation\n      this.hieghtTimeout = setTimeout(\n        () => {\n          this.containerHeight = this.userAgentHeight\n        },\n        this.childrenOpenAnimation ? this.animationDuration : 0\n      )\n    },\n    closeItemChildren() {\n      this.seTAnimationTimeOut = false\n      if (!this.menuCollapsed && this.miniMenu && this.depth === 0) {\n        this.setSmallMenuDataForToggle(false)\n        this.topConTime = setTimeout(() => {\n          this.containerHeight = 0\n          this.topConTime = null\n        }, this.animationDuration)\n        return\n      }\n      this.setSmallMenuDataForToggle(false)\n      if (!this.item?.children) return\n      if (!this.cacheHieght) {\n        this.cacheHieght = this.$refs['container']?.offsetHeight\n      }\n      this.containerHeight = this.$refs['container']?.offsetHeight\n      //this line must be pushed to top of call stack\n      this.PushToTopOfCallStack(() => {\n      })\n      setTimeout(() => {\n        this.$nextTick(()=>{\n          this.containerHeight = 0\n        })\n      }, 10);\n      //return if keepchildren open\n      if (this.keepChildrenOpen) return\n      this.renderTimeOut = setTimeout(\n        () => {\n          setTimeout(() => {\n             this.renderChildren = false\n          }, 20);\n           this.cacheHieght = null\n        },\n        this.childrenOpenAnimation ? this.animationDuration : 0\n      )\n    },\n    setMaxHeightTopC() {\n      const x = this.$refs['topContainerRef']?.getBoundingClientRect()\n      if (this.MakeSpace) {\n        this.TopcontainerHiefht = x.height + 'px'\n      } else {\n        this.TopcontainerHiefht =\n          x.height + innerHeight - (x.top + x.height) - 2 + 'px'\n      }\n    },\n    setItemOffsetHeight() {\n      if (this.depth == 0) {\n        const x = this.$refs['menuItem'].getBoundingClientRect()\n        const x1 = this.$refs['topContainerRef']?.getBoundingClientRect().height\n        let z = 0\n        if (this.item?.children) {\n          z = x.height * this.item?.children.length + x.height\n        }\n        if (x1 && z + x.top - 15 > innerHeight) {\n          this.ContainerOffsetY = innerHeight - x.bottom\n          this.MakeSpace = true\n        } else {\n          this.ContainerOffsetY = x.top\n          this.MakeSpace = false\n        }\n        this.miniMenuOffset = x.width\n      }\n    }\n  }\n}\n</script>\n"],"mappings":"AA2MA,SAASA,MAAM,EAAEC,eAAc,QAAS,KAAI;AAC5C,eAAe;EACbC,IAAI,EAAE,WAAW;EACjBC,UAAU,EAAE;IAAEC;EAAgB,CAAC;EAC/BC,IAAI,EAAEA,CAAA,MAAO;IACXC,YAAY,EAAE,KAAK;IACnBC,QAAQ,EAAE,KAAK;IACfC,eAAe,EAAE,GAAG;IACpBC,aAAa,EAAE,IAAI;IACnBC,aAAa,EAAE,IAAI;IACnBC,cAAc,EAAE,KAAK;IACrBC,WAAW,EAAE,IAAI;IACjBC,MAAM,EAAE,KAAK;IACbC,UAAU,EAAE,KAAK;IACjBC,KAAK,EAAE,KAAK;IACZC,gBAAgB,EAAE,CAAC;IACnBC,EAAE,EAAE,IAAI;IACRC,gBAAgB,EAAE,KAAK;IACvBC,SAAS,EAAE,KAAK;IAChBC,kBAAkB,EAAE,aAAa;IACjCC,gBAAgB,EAAE,CAAC;IACnBC,iBAAiB,EAAE,CAAC;IACpBC,cAAc,EAAE,EAAE;IAClBC,mBAAmB,EAAE,KAAK;IAC1BC,UAAU,EAAE;EACd,CAAC,CAAC;EAEFC,KAAK,EAAE,CACL,WAAW,EACX,QAAQ,EACR,OAAO,EACP,sBAAsB,EACtB,cAAc,EACd,MAAM,EACN,aAAa,EACb,sBAAqB,CACtB;EACDC,KAAKA,CAAA,EAAG;IACN,MAAMC,QAAO,GAAI5B,MAAM,CAAC,eAAe;IACvC,MAAM;MACJ6B,iBAAiB;MACjBC,QAAQ;MACRC,aAAa;MACbC,qBAAqB;MACrBC,eAAe;MACfC,eAAe;MACfC,gBAAgB;MAChBC,iBAAiB;MACjBC,uBAAuB;MACvBC,SAAS;MACTC,uBAAuB;MACvBC;IACF,IAAIxC,MAAM,CAAC,cAAc;IACzB,MAAMyC,eAAc,GAAIzC,MAAM,CAAC,cAAc;IAC7C,MAAM0C,YAAW,GAAI1C,MAAM,CAAC,cAAc;IAC1C,MAAM2C,SAAQ,GAAI3C,MAAM,CAAC,WAAW;IACpC,MAAM4C,qBAAoB,GAAI5C,MAAM,CAAC,uBAAuB;IAC5D,MAAM6C,WAAU,GAAI7C,MAAM,CAAC,aAAa;IACxC,MAAM8C,QAAO,GAAI9C,MAAM,CAAC,UAAU;IAClC,MAAM+C,UAAS,GAAI/C,MAAM,CAAC,YAAY;IACtC,MAAMgD,SAAQ,GAAIhD,MAAM,CAAC,WAAW;IACpC,MAAMiD,YAAW,GAAIjD,MAAM,CAAC,cAAc;IAC1C,MAAMkD,sBAAqB,GAAIlD,MAAM,CAAC,wBAAwB;IAC9D,MAAMmD,0BAAyB,GAAInD,MAAM,CAAC,4BAA4B;IACtE,MAAMoD,gBAAe,GAAIpD,MAAM,CAAC,kBAAkB;IAClD,MAAMqD,aAAY,GAAIrD,MAAM,CAAC,eAAe;IAC5C,MAAMsD,OAAM,GAAItD,MAAM,CAAC,SAAS;IAChC,MAAMuD,iBAAgB,GAAIvD,MAAM,CAAC,mBAAmB;IACpD,MAAMwD,mBAAkB,GAAIxD,MAAM,CAAC,qBAAqB;IACxD,MAAMyD,gBAAe,GAAIzD,MAAM,CAAC,kBAAkB;IAClD,MAAM0D,QAAO,GAAI1D,MAAM,CAAC,UAAU;IAClC,IAAI2D,aAAY,GAAI/B,QAAQ,CAAC,eAAe;IAC5C,IAAIgC,eAAc,GAAIhC,QAAQ,CAAC,iBAAiB;IAChD,IAAIiC,aAAY,GAAIjC,QAAQ,CAAC,eAAe;IAE5C,OAAO;MACLC,iBAAiB;MACjB4B,gBAAgB;MAChBC,QAAQ;MACRF,mBAAmB;MACnBK,aAAa;MACbN,iBAAiB;MACjBb,YAAY;MACZG,WAAW;MACXc,aAAa;MACbC,eAAe;MACfd,QAAQ;MACRC,UAAU;MACVC,SAAS;MACTb,gBAAgB;MAChBE,uBAAuB;MACvBE,uBAAuB;MACvBe,OAAO;MACPD,aAAa;MACbjB,iBAAiB;MACjBgB,gBAAgB;MAChBD,0BAA0B;MAC1BD,sBAAsB;MACtBD,YAAY;MACZf,eAAe;MACfU,qBAAqB;MACrBD,SAAS;MACTb,QAAQ;MACRC,aAAa;MACbC,qBAAqB;MACrBC,eAAe;MACfK,SAAS;MACTG,eAAe;MACfD;IACF;EACF,CAAC;EACDsB,KAAK,EAAE;IACLN,mBAAmBA,CAACO,KAAK,EAAC;MACxB,IAAG,CAAC,IAAI,CAACxB,uBAAsB,IAAM,IAAI,CAACyB,IAAI,CAAC,IAAI,CAACN,QAAQ,CAAC,KAAGK,KAAM,EAAC;MACvE,IAAG,IAAI,CAACC,IAAI,CAACC,QAAQ,EAAC;QACpB,IAAIC,OAAM,GAAI,KAAI;QAClB,MAAMC,IAAG,GAAI,IAAG;QAChB,SAASC,SAASA,CAACC,GAAG,EAAC;UACrB,IAAGH,OAAO,EAAE;UACZ,KAAI,IAAII,CAAC,GAAC,CAAC,EAACA,CAAC,GAACD,GAAG,CAACE,MAAM,EAACD,CAAC,EAAE,EAAC;YAC3B,IAAGD,GAAG,CAACC,CAAC,CAAC,CAACH,IAAI,CAACT,QAAQ,MAAMK,KAAK,EAAC;cACjCG,OAAM,GAAI,IAAG;cACb;YACF;YACA,IAAGG,GAAG,CAACC,CAAC,CAAC,CAACL,QAAQ,EAAC;cACjBG,SAAS,CAACC,GAAG,CAACC,CAAC,CAAC,CAACL,QAAQ;YAC3B;UACF;QACF;QACAG,SAAS,CAAC,IAAI,CAACJ,IAAI,CAACC,QAAQ;QAC5B,IAAG,CAACC,OAAO,EAAC;UACV,IAAI,CAACM,iBAAiB,EAAC;QACzB;MACF;IACF,CAAC;IACD9B,YAAYA,CAAA,EAAG;MACb,IAAI,CAAC+B,WAAW,EAAC;IACnB,CAAC;IACDnC,SAASA,CAACoC,GAAG,EAAE;MACb,IAAIA,GAAE,IAAK,IAAI,CAAC5B,QAAO,IAAK,IAAI,CAAC6B,KAAI,KAAM,CAAC,EAAE;QAC5C,IAAI,CAACH,iBAAiB,EAAC;MACzB;IACF,CAAC;IACDzD,KAAKA,CAAA,EAAG;MACN;;MAEA,IAAI,CAAC,IAAI,CAACE,EAAE,EAAE;QACZ,IAAI,CAACA,EAAC,GAAI,IAAI,CAACgC,YAAY,EAAC;MAC9B;MACA,IAAI,IAAI,CAAClC,KAAK,EAAE;QACd,IAAI,CAACS,mBAAkB,GAAI,IAAG;QAC9B,IAAI,CAAC0B,sBAAsB,CAAC,IAAI,CAACjC,EAAE;QACnC,IAAI,CAAC2D,eAAe,EAAC;QACrB,IAAI,CAACC,SAAS,CAAC,MAAM;UACnBC,UAAU,CAAC,MAAM;YACf,IAAI,CAACC,mBAAmB,EAAC;UAC3B,CAAC,EAAE,CAAC;UACJ,MAAMC,CAAA,GAAI,IAAI,CAACC,KAAK,CAAC,UAAU,CAAC,CAACC,qBAAqB,EAAC;UACvD,IAAI,CAAC7D,gBAAe,GAAI2D,CAAC,CAAC,IAAI,CAAC3B,aAAa;UAC5C,IAAI,CAAC/B,iBAAgB,GAAI0D,CAAC,CAACG,GAAE;QAC/B,CAAC;MACH,OAAO;QACL,IAAI,IAAI,CAAC/B,gBAAe,KAAM,IAAI,CAACnC,EAAC,IAAK,IAAI,CAAC+B,SAAS,EAAE,CACzD,OAAO;UACL,IAAI,CAACwB,iBAAiB,EAAC;QACzB;MACF;IACF,CAAC;IACDxB,SAASA,CAAA,EAAG;MACV,IAAI,CAAC,IAAI,CAACA,SAAS,EAAE;QACnB,IAAI,CAACwB,iBAAiB,EAAC;MACzB;IACF,CAAC;IACDpB,gBAAgBA,CAAA,EAAG;MACjB;MACA,IAAI,IAAI,CAACA,gBAAe,IAAK,IAAI,CAACnC,EAAE,EAAE;QACpC;QACA,IAAI,CAACuD,iBAAiB,EAAC;MACzB,OAAO;QACL;MAAA;IAEJ,CAAC;IACDzB,UAAUA,CAAA,EAAG;MACX,IAAI,IAAI,CAACqC,QAAQ,EAAE;QACjB,IAAI,CAACZ,iBAAiB,EAAC;MACzB,OAAO;QACL,IAAI,CAACO,mBAAmB,EAAC;QACzB,MAAMC,CAAA,GAAI,IAAI,CAACC,KAAK,CAAC,UAAU,CAAC,CAACC,qBAAqB,EAAC;QACvD,IAAI,CAAC7D,gBAAe,GAAI2D,CAAC,CAAC,IAAI,CAAC3B,aAAa;QAC5C,IAAI,CAAC/B,iBAAgB,GAAI0D,CAAC,CAACG,GAAE;MAC/B;IACF,CAAC;IACDrC,QAAQA,CAAA,EAAG;MACT,IAAI,CAAC0B,iBAAiB,EAAC;MACvB,IAAI,CAACK,SAAS,CAAC,MAAM;QACnB,IAAI,CAACE,mBAAmB,EAAC;MAC3B,CAAC;IACH;EACF,CAAC;EACDM,OAAOA,CAAA,EAAG;IACR,IAAI,CAACZ,WAAW,EAAC;EACnB,CAAC;EACDa,OAAOA,CAAA,EAAG;IACR,IAAI,CAACC,oBAAoB,EAAC;IAC1B,IAAI,CAACR,mBAAmB,EAAC;IACzB,IAAI,IAAI,CAACvC,QAAO,IAAK,OAAO,EAAE;MAC5B,MAAMgD,OAAM,GAAIA,CAAA,KAAM;QACpB,IAAI,cAAa,IAAKC,QAAQ,CAACC,eAAe,EAAE;UAC9C,IAAI,CAAClB,iBAAiB,EAAC;UACvB;QACF;QACA,IAAI,CAACO,mBAAmB,EAAC;QACzB,MAAMC,CAAA,GAAI,IAAI,CAACC,KAAK,CAAC,UAAU,CAAC,CAACC,qBAAqB,EAAC;QACvD,IAAI,CAAC7D,gBAAe,GAAI2D,CAAC,CAAC,IAAI,CAAC3B,aAAa;QAC5C,IAAI,CAAC/B,iBAAgB,GAAI0D,CAAC,CAACG,GAAE;MAC/B;MACA,MAAMQ,oBAAmB,GAAIA,CAAA,KAAM;QACjCC,MAAM,CAACC,mBAAmB,CAAC,QAAQ,EAAEL,OAAO;MAC9C;MACAI,MAAM,CAACE,gBAAgB,CAAC,QAAQ,EAAEN,OAAO;MACzCvF,eAAe,CAAC0F,oBAAoB;IACtC;EACF,CAAC;EACDI,QAAQ,EAAE;IACRX,QAAQA,CAAA,EAAG;MACT,OAAO,cAAa,IAAKK,QAAQ,CAACC,eAAc;IAClD,CAAC;IACDM,eAAeA,CAAA,EAAG;MAChB,OAAO,IAAI,CAAChC,IAAI,EAAEgC,eAAc,GAC5B,IAAI,CAAChC,IAAI,EAAEgC,eAAc,GACzB,YAAW;IACjB,CAAC;IACDC,WAAWA,CAAA,EAAG;MACZ,OAAO,IAAI,CAACjC,IAAI,EAAEiC,WAAU,GAAI,IAAI,CAACjC,IAAI,EAAEiC,WAAU,GAAI,aAAY;IACvE,CAAC;IACDC,oBAAoBA,CAAA,EAAG;MACrB,OAAO,IAAI,CAAC7C,aAAY,KAAM,OAAM,GAAI,MAAK,GAAI,OAAM;IACzD,CAAC;IACD8C,SAASA,CAAA,EAAG;MACV,IAAI,IAAI,CAACrD,QAAQ,EAAE;QACjB,OAAO,IAAI,CAAC6B,KAAI,IAAK,IAAI,IAAI,CAACX,IAAI,EAAE9D,IAAG,GAAI,KAAI;MACjD;MACA,OAAO,IAAI,CAAC8D,IAAI,EAAE9D,IAAG;IACvB,CAAC;IACDkG,eAAeA,CAAA,EAAG;MAChB,OAAO,IAAI,CAAC5F,eAAc,KAAM,IAAI,CAACiC,eAAc,GAC/C,IAAI,CAACjC,eAAc,GACnB,IAAI,CAACA,eAAc,GAAI,IAAG;IAChC,CAAC;IACD6F,cAAcA,CAAA,EAAG;MACf,OAAQ,OAAM,IAAI,CAACxE,iBAAgB,GAAI,IAAK,eAAa;IAC3D,CAAC;IACDyE,gBAAgBA,CAAA,EAAG;MACjB,OAAO;QACLC,IAAI,EAAE;UAAEA,IAAI,EAAE,IAAI,CAACvC,IAAI,EAAEuC,IAAG,IAAK,CAAC,CAAC;UAAErG,IAAI,EAAE,IAAI,CAAC8D,IAAI,EAAE9D;QAAK;MAC7D;IACF,CAAC;IACDsG,qBAAqBA,CAAA,EAAG;MACtB,OAAO,IAAI,CAAC1D,QAAO,IAAK,IAAI,CAAC6B,KAAI,IAAK,IAAI,WAAU,GAAI,IAAG;IAC7D,CAAC;IACD8B,UAAUA,CAAA,EAAG;MACX,IAAG,CAAC,IAAI,CAAC3D,QAAQ,EAAE,OAAO,OAAM;MAChC,IAAG,IAAI,CAAC6B,KAAI,IAAK,CAAC,EAAC;QACjB,IAAG,IAAI,CAACpE,QAAQ,EAAC;UACf,OAAO,IAAI,CAAC6E,QAAO,GAAI,UAAS,GAAI,OAAM;QAC5C;QACA,OAAQ,IAAI,CAACA,QAAO,GAAI,EAAC,GAAI,OAAM;MACrC;MACA,OAAO,OAAM;IACf,CAAC;IACDsB,qBAAqBA,CAAA,EAAG;MACtB,OAAO,IAAI,CAAC5D,QAAO,IAAK,IAAI,CAAC6B,KAAI,IAAK,IAAI,YAAW,GAAI,IAAG;IAC9D,CAAC;IACDgC,wBAAwBA,CAAA,EAAG;MACzB,OAAQ,GAAE,IAAI,CAAC3F,gBAAiB,IAAE;IACpC,CAAC;IACD4F,aAAaA,CAAA,EAAG;MACd,IAAIC,GAAE,GAAI,CAAC;MACXA,GAAG,CAAE,OAAM,IAAI,CAAC/E,QAAS,EAAC,IAAI,IAAG;MACjC+E,GAAG,CAAC,IAAI,CAAC7C,IAAI,EAAE8C,KAAI,IAAK,EAAE,IAAI,IAAI,CAAC9C,IAAI,EAAE8C,KAAI;MAC7C,OAAO;QACLC,qBAAqB,EAAE,IAAI,CAACjE,QAAO,IAAK,IAAI,CAAC6B,KAAI,IAAK,CAAC;QACvDqC,2BAA2B,EAAE,IAAI,CAAClE,QAAO,IAAK,IAAI,CAAC6B,KAAI,IAAK,CAAC;QAC7DsC,YAAY,EACV,IAAI,CAACnF,QAAO,KAAM,OAAM,KACtB,CAAC,IAAI,CAACgB,QAAO,IAAK,IAAI,CAACvC,QAAO,IAAK,IAAI,CAACoE,KAAI,IAAK,CAAC,IACjD,IAAI,CAAC7B,QAAO,IAAK,IAAI,CAAC6B,KAAI,IAAK,KAAK,IAAI,CAACpE,QAAS,CAAC;QACxD2G,WAAW,EACT,IAAI,CAACjF,eAAc,IACnB,CAAC,IAAI,CAACa,QAAO,IACb,CAAC,IAAI,CAACqE,oBAAmB,IACzB,IAAI,CAACC,YAAY;QACnBC,mBAAmB,EACjB,IAAI,CAACpF,eAAc,IACnB,IAAI,CAACa,QAAO,IACZ,IAAI,CAAC6B,KAAI,IAAK,KACd,CAAC,IAAI,CAACwC,oBAAmB,IACzB,IAAI,CAACC,YAAY;QACnB,GAAGP;MACL;MACA;IACF,CAAC;;IACDS,cAAcA,CAAA,EAAG;MACf,MAAMC,KAAI,GAAIC,MAAM,CAAC,IAAI,CAAC1F,QAAO,IAAK,OAAO;MAC7C,OAAO,IAAI,CAACvB,QAAO,GACd,QAAO,IAAI,CAACwB,aAAc,IAAGwF,KAAM,QAAO,IAAI,CAACtC,KAAK,CAAC,UAAU,CAAC,CAACwC,WAAY,IAAGF,KAAM,UAAS,IAAI,CAACtC,KAAK,CAAC,UAAU,CAAC,CAACwC,WAAY,qBAAmB,GACrJ,MAAI;IACX,CAAC;IACDC,kBAAkBA,CAAA,EAAG;MACnB,OAAQ,SAAQ,IAAI,CAAC3F,aAAa,MAAM,IAAI,CAACR,cAAe,UAAQ;IACtE;EACF,CAAC;EAEDoG,OAAO,EAAE;IACPC,YAAYA,CAACC,CAAC,EAAE;MACdpC,QAAQ,CAACqC,aAAa,CAAC,WAAW,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAEF,CAAC,CAACG,MAAM;IAC1D,CAAC;IACDC,oBAAoBA,CAACC,EAAE,EAAE;MACvBpD,UAAU,CAAC,MAAM;QACfoD,EAAE,EAAC;MACL,CAAC,EAAE,CAAC;IACN,CAAC;IACDC,WAAWA,CAACC,IAAI,EAAE;MAChB,IAAI,IAAI,EAAEC,OAAO,EAAE;QACjB,MAAMC,CAAA,GAAI,IAAI,CAACD,OAAO,CAACE,OAAO,CAACH,IAAI;QACnC,OAAOE,CAAC,CAACF,IAAG;MACd;MACA,OAAOA,IAAG;IACZ,CAAC;IACD3D,WAAWA,CAAA,EAAG;MACZ,IAAI,CAAC,IAAI,CAACrC,iBAAiB,EAAE;MAC7B,IACE,IAAI,CAAC4B,IAAI,EAAEoE,IAAG,IACd,IAAI,CAACzF,SAAS,CAAC,IAAI,CAACwF,WAAW,CAAC,IAAI,CAACnE,IAAI,EAAEoE,IAAI,CAAC,GAChD;QACA,IAAI,CAACvH,MAAK,GAAI,IAAG;QACjB,IAAI,CAACC,UAAS,GAAI,KAAI;MACxB,OAAO;QACL,IAAI,CAACD,MAAK,GAAI,KAAI;QAClB,IAAI,CAAC,IAAI,CAACmD,IAAI,EAAEC,QAAQ,EAAE;QAC1B,IAAIuE,QAAO,GAAI,KAAI;QACnB,IAAIF,CAAA,GAAI,IAAI,CAAC1F,qBAAqB,CAAC,IAAI,CAACoB,IAAI,EAAEC,QAAQ,EAAE,MAAM,KAAK,EAAC;QACpE,KAAK,IAAIK,CAAA,GAAI,CAAC,EAAEA,CAAA,GAAIgE,CAAC,CAAC/D,MAAM,EAAED,CAAC,EAAE,EAAE;UACjC,IAAI,IAAI,CAAC3B,SAAS,CAAC,IAAI,CAACwF,WAAW,CAACG,CAAC,CAAChE,CAAC,CAAC,CAAC,CAAC,EAAE;YAC1CkE,QAAO,GAAI,IAAG;YACd;YACA;YACA,IAAI,CAAC1H,UAAS,GAAI,IAAG;YACrB,IAAI,IAAI,CAAC+B,WAAU,IAAK,IAAI,CAACC,QAAQ,EAAE;YACvC,IAAI,IAAI,CAACT,uBAAuB,EAAE;cAChC,IAAI,CAACuC,eAAe,EAAC;YACvB;YACA;UACF;QACF;QACA,IAAI,CAAC9D,UAAS,GAAI0H,QAAO;MAC3B;IACF,CAAC;IACDC,UAAUA,CAAA,EAAG;MACX,IAAI,IAAI,CAAC1H,KAAK,EAAE;QACd,IAAI,CAAC2H,cAAc,EAAC;MACtB,OAAO;QACL,IAAI,CAACC,UAAU,EAAC;MAClB;IACF,CAAC;IACDC,YAAYA,CAAA,EAAG;MACb,IAAI,IAAI,CAAC5E,IAAI,EAAE6E,eAAe,EAAE;QAC9B,IAAI,CAACtF,iBAAiB,CAAC,IAAI;MAC7B;MACA,IAAI,CAACD,OAAO,CAAC,YAAY,EAAE,IAAI,CAACU,IAAI;MACpC,IAAI,IAAI,CAAC9B,eAAc,IAAK,IAAI,CAAC8B,IAAI,EAAEoE,IAAG,IAAK,IAAI,CAACC,OAAO,EAAC;QAC1D,IAAI,CAAC5E,gBAAgB,CAAC,IAAI,CAACO,IAAI,CAAC,IAAI,CAACN,QAAQ,CAAC;QAC9C,IAAI,CAAC2E,OAAO,EAAES,IAAI,CAAC,IAAI,CAAC9E,IAAI,EAAEoE,IAAI;MACpC;IACF,CAAC;IACDM,cAAcA,CAAA,EAAG;MACf,IAAI,CAACE,YAAY,EAAC;IACpB,CAAC;IACDD,UAAUA,CAAA,EAAG;MACX,IAAI,CAACC,YAAY,EAAC;MAClB,IAAI,CAAC,IAAI,CAAC5E,IAAI,EAAEC,QAAQ,EAAE;MAC1B8E,YAAY,CAAC,IAAI,CAACtI,aAAa;MAC/BsI,YAAY,CAAC,IAAI,CAACrI,aAAa;MAC/B,IAAI,IAAI,CAACJ,YAAY,EAAE;QACrB,IAAG,EAAE,IAAI,CAAC0D,IAAI,EAAEoE,IAAG,IAAK,IAAI,CAAC7F,uBAAuB,CAAC,EAAC;UACpD,IAAI,CAACiC,iBAAiB,EAAC;QACzB;MACF,OAAO;QACL,IAAI,CAACI,eAAe,EAAC;MACvB;MACA;IACF,CAAC;;IACDoE,yBAAyBA,CAACtE,GAAG,EAAE;MAC7BqE,YAAY,CAAC,IAAI,CAACtH,UAAU;MAC5BsH,YAAY,CAAC,IAAI,CAACtI,aAAa;MAC/BsI,YAAY,CAAC,IAAI,CAACrI,aAAa;MAC/B,IAAI,CAACmE,SAAS,CAAC,MAAM;QACnB,IAAI,CAACtE,QAAO,GAAImE,GAAE;MACpB,CAAC;MACD,IAAI,CAACpE,YAAW,GAAIoE,GAAE;IACxB,CAAC;IACDa,oBAAoBA,CAAA,EAAG;MACrB,IAAI,CAAC,IAAI,CAACtD,eAAc,IAAK,IAAI,CAACH,QAAO,IAAK,OAAO,EAAE;MACvD,IAAI,CAAC,IAAI,CAACkC,IAAI,EAAEC,QAAQ,EAAE;MAC1B,KAAK,IAAIK,CAAA,GAAI,CAAC,EAAEA,CAAA,GAAI,IAAI,CAACN,IAAI,EAAEC,QAAQ,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;QACnD,IAAI,IAAI,CAACN,IAAI,EAAEC,QAAQ,CAACK,CAAC,CAAC,EAAEiC,IAAI,EAAE;UAChC,IAAI,CAACrF,gBAAe,GAAI,IAAG;UAC3B;QACF;MACF;IACF,CAAC;IACD0D,eAAeA,CAAA,EAAG;MAChB,IAAI,IAAI,CAACD,KAAI,KAAM,KAAK,IAAI,CAAC7B,QAAQ,EAAE;QACrC,IAAI,CAACmG,oBAAoB,EAAC;MAC5B;MACA,IAAI,IAAI,CAACnG,QAAO,IAAK,IAAI,CAAC6B,KAAI,KAAM,CAAC,EAAE;QACrC,IAAI,CAACrE,YAAW,GAAI,IAAG;QAEvB,IAAI,CAACuE,SAAS,CAAC,MAAM;UACnB,IAAI,CAACtE,QAAO,GAAI,IAAG;QACrB,CAAC;MACH;MACA,IAAI,CAAC,IAAI,CAACyD,IAAI,EAAEC,QAAQ,EAAE;MAC1B,IAAI,IAAI,CAAC1D,QAAQ,EAAE;MACnB,IAAI,CAACyI,yBAAyB,CAAC,IAAI;MACnC,IAAI,CAACrI,cAAa,GAAI,IAAG;MACzB,IAAI,IAAI,CAACC,WAAW,EAAE;QACpB,IAAI,CAACJ,eAAc,GAAI,IAAI,CAACI,WAAU;MACxC,OAAO;QACL,IAAI,CAACJ,eAAc,GAAI,IAAI,CAACqC,WAAU,GAClC,IAAI,CAACmB,IAAI,EAAEC,QAAQ,CAACM,MAAK,GAAI,IAAI,CAACU,KAAK,CAAC,UAAU,CAAC,EAAEiE,YAAW,GAChE,IACA,IAAI,CAACzG,eAAc;MACzB;MACA,IAAI,CAAC7B,WAAU,GAAI,IAAG;MACtB;MACA,IAAI,CAAC,IAAI,CAACiC,WAAW,EAAE;MACvB,IAAI,IAAI,CAACC,QAAO,IAAK,IAAI,CAAC6B,KAAI,KAAM,CAAC,EAAE;QACrC,IAAI,CAACnE,eAAc,GAAI,IAAI,CAACiC,eAAc;MAC5C;MACA;MACA,IAAI,CAAChC,aAAY,GAAIqE,UAAU,CAC7B,MAAM;QACJ,IAAI,CAACtE,eAAc,GAAI,IAAI,CAACiC,eAAc;MAC5C,CAAC,EACD,IAAI,CAACT,qBAAoB,GAAI,IAAI,CAACH,iBAAgB,GAAI,EACxD;IACF,CAAC;IACD2C,iBAAiBA,CAAA,EAAG;MAClB,IAAI,CAAChD,mBAAkB,GAAI,KAAI;MAC/B,IAAI,CAAC,IAAI,CAAC2H,aAAY,IAAK,IAAI,CAACrG,QAAO,IAAK,IAAI,CAAC6B,KAAI,KAAM,CAAC,EAAE;QAC5D,IAAI,CAACqE,yBAAyB,CAAC,KAAK;QACpC,IAAI,CAACvH,UAAS,GAAIqD,UAAU,CAAC,MAAM;UACjC,IAAI,CAACtE,eAAc,GAAI;UACvB,IAAI,CAACiB,UAAS,GAAI,IAAG;QACvB,CAAC,EAAE,IAAI,CAACI,iBAAiB;QACzB;MACF;MACA,IAAI,CAACmH,yBAAyB,CAAC,KAAK;MACpC,IAAI,CAAC,IAAI,CAAChF,IAAI,EAAEC,QAAQ,EAAE;MAC1B,IAAI,CAAC,IAAI,CAACrD,WAAW,EAAE;QACrB,IAAI,CAACA,WAAU,GAAI,IAAI,CAACqE,KAAK,CAAC,WAAW,CAAC,EAAEiE,YAAW;MACzD;MACA,IAAI,CAAC1I,eAAc,GAAI,IAAI,CAACyE,KAAK,CAAC,WAAW,CAAC,EAAEiE,YAAW;MAC3D;MACA,IAAI,CAACjB,oBAAoB,CAAC,MAAM,CAChC,CAAC;MACDnD,UAAU,CAAC,MAAM;QACf,IAAI,CAACD,SAAS,CAAC,MAAI;UACjB,IAAI,CAACrE,eAAc,GAAI;QACzB,CAAC;MACH,CAAC,EAAE,EAAE,CAAC;MACN;MACA,IAAI,IAAI,CAAC2B,gBAAgB,EAAE;MAC3B,IAAI,CAACzB,aAAY,GAAIoE,UAAU,CAC7B,MAAM;QACJA,UAAU,CAAC,MAAM;UACd,IAAI,CAACnE,cAAa,GAAI,KAAI;QAC7B,CAAC,EAAE,EAAE,CAAC;QACL,IAAI,CAACC,WAAU,GAAI,IAAG;MACzB,CAAC,EACD,IAAI,CAACoB,qBAAoB,GAAI,IAAI,CAACH,iBAAgB,GAAI,EACxD;IACF,CAAC;IACDuH,gBAAgBA,CAAA,EAAG;MACjB,MAAMd,CAAA,GAAI,IAAI,CAACrD,KAAK,CAAC,iBAAiB,CAAC,EAAEC,qBAAqB,EAAC;MAC/D,IAAI,IAAI,CAAC/D,SAAS,EAAE;QAClB,IAAI,CAACC,kBAAiB,GAAIkH,CAAC,CAACe,MAAK,GAAI,IAAG;MAC1C,OAAO;QACL,IAAI,CAACjI,kBAAiB,GACpBkH,CAAC,CAACe,MAAK,GAAIC,WAAU,IAAKhB,CAAC,CAACnD,GAAE,GAAImD,CAAC,CAACe,MAAM,IAAI,IAAI,IAAG;MACzD;IACF,CAAC;IACDtE,mBAAmBA,CAAA,EAAG;MACpB,IAAI,IAAI,CAACJ,KAAI,IAAK,CAAC,EAAE;QACnB,MAAM2D,CAAA,GAAI,IAAI,CAACrD,KAAK,CAAC,UAAU,CAAC,CAACC,qBAAqB,EAAC;QACvD,MAAMqE,EAAC,GAAI,IAAI,CAACtE,KAAK,CAAC,iBAAiB,CAAC,EAAEC,qBAAqB,EAAE,CAACmE,MAAK;QACvE,IAAIG,CAAA,GAAI;QACR,IAAI,IAAI,CAACxF,IAAI,EAAEC,QAAQ,EAAE;UACvBuF,CAAA,GAAIlB,CAAC,CAACe,MAAK,GAAI,IAAI,CAACrF,IAAI,EAAEC,QAAQ,CAACM,MAAK,GAAI+D,CAAC,CAACe,MAAK;QACrD;QACA,IAAIE,EAAC,IAAKC,CAAA,GAAIlB,CAAC,CAACnD,GAAE,GAAI,EAAC,GAAImE,WAAW,EAAE;UACtC,IAAI,CAACtI,gBAAe,GAAIsI,WAAU,GAAIhB,CAAC,CAACmB,MAAK;UAC7C,IAAI,CAACtI,SAAQ,GAAI,IAAG;QACtB,OAAO;UACL,IAAI,CAACH,gBAAe,GAAIsH,CAAC,CAACnD,GAAE;UAC5B,IAAI,CAAChE,SAAQ,GAAI,KAAI;QACvB;QACA,IAAI,CAACI,cAAa,GAAI+G,CAAC,CAACoB,KAAI;MAC9B;IACF;EACF;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}