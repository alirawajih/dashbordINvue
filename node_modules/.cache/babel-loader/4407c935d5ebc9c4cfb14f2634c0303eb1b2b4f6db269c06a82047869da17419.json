{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { createFactory as t, $eq as i, $ne as e, $lt as s, $lte as n, $gt as r, $gte as o, $in as c, $nin as u, $all as h, $size as l, $regex as a, $options as f, $elemMatch as d, $exists as y, eq as p, ne as b, lt as w, lte as g, gt as $, gte as A, within as m, nin as M, all as j, size as E, regex as x, elemMatch as v, exists as _, and as F } from \"@ucast/mongo2js\";\nfunction O(t) {\n  return Array.isArray(t) ? t : [t];\n}\nconst C = \"__caslSubjectType__\";\nfunction R(t, i) {\n  if (i) if (!Object.hasOwn(i, C)) Object.defineProperty(i, C, {\n    value: t\n  });else if (t !== i[C]) throw new Error(`Trying to cast object to subject type ${t} but previously it was casted to ${i[C]}`);\n  return i;\n}\nconst P = t => {\n  const i = typeof t;\n  return i === \"string\" || i === \"function\";\n};\nconst S = t => t.modelName || t.name;\nfunction T(t) {\n  return typeof t === \"string\" ? t : S(t);\n}\nfunction z(t) {\n  if (Object.hasOwn(t, C)) return t[C];\n  return S(t.constructor);\n}\nconst B = {\n  function: t => t.constructor,\n  string: z\n};\nfunction q(t, i, e) {\n  let s = O(i);\n  let n = 0;\n  while (n < s.length) {\n    const i = s[n++];\n    if (Object.hasOwn(t, i)) s = e(s, t[i]);\n  }\n  return s;\n}\nfunction D(t, i) {\n  if (typeof i === \"string\" && t.indexOf(i) !== -1) return i;\n  for (let e = 0; e < i.length; e++) if (t.indexOf(i[e]) !== -1) return i[e];\n  return null;\n}\nconst Y = (t, i) => t.concat(i);\nfunction k(t, i) {\n  if (i in t) throw new Error(`Cannot use \"${i}\" as an alias because it's reserved action.`);\n  const e = Object.keys(t);\n  const s = (t, e) => {\n    const s = D(t, e);\n    if (s) throw new Error(`Detected cycle ${s} -> ${t.join(\", \")}`);\n    const n = typeof e === \"string\" && e === i || t.indexOf(i) !== -1 || Array.isArray(e) && e.indexOf(i) !== -1;\n    if (n) throw new Error(`Cannot make an alias to \"${i}\" because this is reserved action`);\n    return t.concat(e);\n  };\n  for (let i = 0; i < e.length; i++) q(t, e[i], s);\n}\nfunction L(t, i) {\n  if (!i || i.skipValidate !== false) k(t, i && i.anyAction || \"manage\");\n  return i => q(t, i, Y);\n}\nfunction U(t, i, e) {\n  for (let s = e; s < i.length; s++) t.push(i[s]);\n}\nfunction G(t, i) {\n  if (!t || !t.length) return i || [];\n  if (!i || !i.length) return t || [];\n  let e = 0;\n  let s = 0;\n  const n = [];\n  while (e < t.length && s < i.length) if (t[e].priority < i[s].priority) {\n    n.push(t[e]);\n    e++;\n  } else {\n    n.push(i[s]);\n    s++;\n  }\n  U(n, t, e);\n  U(n, i, s);\n  return n;\n}\nfunction H(t, i, e) {\n  let s = t.get(i);\n  if (!s) {\n    s = e();\n    t.set(i, s);\n  }\n  return s;\n}\nconst I = t => t;\nfunction J(t, i) {\n  if (Array.isArray(t.fields) && !t.fields.length) throw new Error(\"`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa\");\n  if (t.fields && !i.fieldMatcher) throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  if (t.conditions && !i.conditionsMatcher) throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n}\nclass K {\n  constructor(t, i, e = 0) {\n    J(t, i);\n    this.action = i.resolveAction(t.action);\n    this.subject = t.subject;\n    this.inverted = !!t.inverted;\n    this.conditions = t.conditions;\n    this.reason = t.reason;\n    this.origin = t;\n    this.fields = t.fields ? O(t.fields) : void 0;\n    this.priority = e;\n    this.t = i;\n  }\n  i() {\n    if (this.conditions && !this.o) this.o = this.t.conditionsMatcher(this.conditions);\n    return this.o;\n  }\n  get ast() {\n    const t = this.i();\n    return t ? t.ast : void 0;\n  }\n  matchesConditions(t) {\n    if (!this.conditions) return true;\n    if (!t || P(t)) return !this.inverted;\n    const i = this.i();\n    return i(t);\n  }\n  matchesField(t) {\n    if (!this.fields) return true;\n    if (!t) return !this.inverted;\n    if (this.fields && !this.u) this.u = this.t.fieldMatcher(this.fields);\n    return this.u(t);\n  }\n}\nfunction N(t, i) {\n  const e = {\n    value: t,\n    prev: i,\n    next: null\n  };\n  if (i) i.next = e;\n  return e;\n}\nfunction Q(t) {\n  if (t.next) t.next.prev = t.prev;\n  if (t.prev) t.prev.next = t.next;\n  t.next = t.prev = null;\n}\nconst V = t => ({\n  value: t.value,\n  prev: t.prev,\n  next: t.next\n});\nconst W = () => ({\n  rules: [],\n  merged: false\n});\nconst X = () => new Map();\nclass Z {\n  constructor(t = [], i = {}) {\n    this.h = false;\n    this.l = new Map();\n    this.p = {\n      conditionsMatcher: i.conditionsMatcher,\n      fieldMatcher: i.fieldMatcher,\n      resolveAction: i.resolveAction || I\n    };\n    this.$ = i.anyAction || \"manage\";\n    this.A = i.anySubjectType || \"all\";\n    this.m = t;\n    this.M = !!i.detectSubjectType;\n    this.j = i.detectSubjectType || z;\n    this.v(t);\n  }\n  get rules() {\n    return this.m;\n  }\n  detectSubjectType(t) {\n    if (P(t)) return t;\n    if (!t) return this.A;\n    return this.j(t);\n  }\n  update(t) {\n    const i = {\n      rules: t,\n      ability: this,\n      target: this\n    };\n    this._(\"update\", i);\n    this.m = t;\n    this.v(t);\n    this._(\"updated\", i);\n    return this;\n  }\n  v(t) {\n    const i = new Map();\n    let e;\n    for (let s = t.length - 1; s >= 0; s--) {\n      const n = t.length - s - 1;\n      const r = new K(t[s], this.p, n);\n      const o = O(r.action);\n      const c = O(r.subject || this.A);\n      if (!this.h && r.fields) this.h = true;\n      for (let t = 0; t < c.length; t++) {\n        const s = H(i, c[t], X);\n        if (e === void 0) e = typeof c[t];\n        if (typeof c[t] !== e && e !== \"mixed\") e = \"mixed\";\n        for (let t = 0; t < o.length; t++) H(s, o[t], W).rules.push(r);\n      }\n    }\n    this.l = i;\n    if (e !== \"mixed\" && !this.M) {\n      const t = B[e] || B.string;\n      this.j = t;\n    }\n  }\n  possibleRulesFor(t, i = this.A) {\n    if (!P(i)) throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    const e = H(this.l, i, X);\n    const s = H(e, t, W);\n    if (s.merged) return s.rules;\n    const n = t !== this.$ && e.has(this.$) ? e.get(this.$).rules : void 0;\n    let r = G(s.rules, n);\n    if (i !== this.A) r = G(r, this.possibleRulesFor(t, this.A));\n    s.rules = r;\n    s.merged = true;\n    return r;\n  }\n  rulesFor(t, i, e) {\n    const s = this.possibleRulesFor(t, i);\n    if (e && typeof e !== \"string\") throw new Error(\"The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details\");\n    if (!this.h) return s;\n    return s.filter(t => t.matchesField(e));\n  }\n  actionsFor(t) {\n    if (!P(t)) throw new Error('\"actionsFor\" accepts only subject types (i.e., string or class) as a parameter');\n    const i = new Set();\n    const e = this.l.get(t);\n    if (e) Array.from(e.keys()).forEach(t => i.add(t));\n    const s = t !== this.A ? this.l.get(this.A) : void 0;\n    if (s) Array.from(s.keys()).forEach(t => i.add(t));\n    return Array.from(i);\n  }\n  on(t, i) {\n    this.F = this.F || new Map();\n    const e = this.F;\n    const s = e.get(t) || null;\n    const n = N(i, s);\n    e.set(t, n);\n    return () => {\n      const i = e.get(t);\n      if (!n.next && !n.prev && i === n) e.delete(t);else if (n === i) e.set(t, n.prev);\n      Q(n);\n    };\n  }\n  _(t, i) {\n    if (!this.F) return;\n    let e = this.F.get(t) || null;\n    while (e !== null) {\n      const t = e.prev ? V(e.prev) : null;\n      e.value(i);\n      e = t;\n    }\n  }\n}\nclass PureAbility extends Z {\n  can(t, i, e) {\n    const s = this.relevantRuleFor(t, i, e);\n    return !!s && !s.inverted;\n  }\n  relevantRuleFor(t, i, e) {\n    const s = this.detectSubjectType(i);\n    const n = this.rulesFor(t, s, e);\n    for (let t = 0, e = n.length; t < e; t++) if (n[t].matchesConditions(i)) return n[t];\n    return null;\n  }\n  cannot(t, i, e) {\n    return !this.can(t, i, e);\n  }\n}\nconst tt = {\n  $eq: i,\n  $ne: e,\n  $lt: s,\n  $lte: n,\n  $gt: r,\n  $gte: o,\n  $in: c,\n  $nin: u,\n  $all: h,\n  $size: l,\n  $regex: a,\n  $options: f,\n  $elemMatch: d,\n  $exists: y\n};\nconst it = {\n  eq: p,\n  ne: b,\n  lt: w,\n  lte: g,\n  gt: $,\n  gte: A,\n  in: m,\n  nin: M,\n  all: j,\n  size: E,\n  regex: x,\n  elemMatch: v,\n  exists: _,\n  and: F\n};\nconst et = (i, e, s) => t(Object.assign({}, tt, i), Object.assign({}, it, e), s);\nconst st = t(tt, it);\nconst nt = /[-/\\\\^$+?.()|[\\]{}]/g;\nconst rt = /\\.?\\*+\\.?/g;\nconst ot = /\\*+/;\nconst ct = /\\./g;\nfunction ut(t, i, e) {\n  const s = e[0] === \"*\" || t[0] === \".\" && t[t.length - 1] === \".\" ? \"+\" : \"*\";\n  const n = t.indexOf(\"**\") === -1 ? \"[^.]\" : \".\";\n  const r = t.replace(ct, \"\\\\$&\").replace(ot, n + s);\n  return i + t.length === e.length ? `(?:${r})?` : r;\n}\nfunction ht(t, i, e) {\n  if (t === \".\" && (e[i - 1] === \"*\" || e[i + 1] === \"*\")) return t;\n  return `\\\\${t}`;\n}\nfunction lt(t) {\n  const i = t.map(t => t.replace(nt, ht).replace(rt, ut));\n  const e = i.length > 1 ? `(?:${i.join(\"|\")})` : i[0];\n  return new RegExp(`^${e}$`);\n}\nconst at = t => {\n  let i;\n  return e => {\n    if (typeof i === \"undefined\") i = t.every(t => t.indexOf(\"*\") === -1) ? null : lt(t);\n    return i === null ? t.indexOf(e) !== -1 : i.test(e);\n  };\n};\nclass Ability extends PureAbility {\n  constructor(t = [], i = {}) {\n    super(t, Object.assign({\n      conditionsMatcher: st,\n      fieldMatcher: at\n    }, i));\n  }\n}\nfunction createMongoAbility(t = [], i = {}) {\n  return new PureAbility(t, Object.assign({\n    conditionsMatcher: st,\n    fieldMatcher: at\n  }, i));\n}\nfunction isAbilityClass(t) {\n  return typeof t.prototype.possibleRulesFor === \"function\";\n}\nclass ft {\n  constructor(t) {\n    this.O = t;\n  }\n  because(t) {\n    this.O.reason = t;\n    return this;\n  }\n}\nclass AbilityBuilder {\n  constructor(t) {\n    this.rules = [];\n    this.C = t;\n    this.can = (t, i, e, s) => this.R(t, i, e, s, false);\n    this.cannot = (t, i, e, s) => this.R(t, i, e, s, true);\n    this.build = t => isAbilityClass(this.C) ? new this.C(this.rules, t) : this.C(this.rules, t);\n  }\n  R(t, i, e, s, n) {\n    const r = {\n      action: t\n    };\n    if (n) r.inverted = n;\n    if (i) {\n      r.subject = i;\n      if (Array.isArray(e) || typeof e === \"string\") r.fields = e;else if (typeof e !== \"undefined\") r.conditions = e;\n      if (typeof s !== \"undefined\") r.conditions = s;\n    }\n    this.rules.push(r);\n    return new ft(r);\n  }\n}\nfunction defineAbility(t, i) {\n  const e = new AbilityBuilder(createMongoAbility);\n  const s = t(e.can, e.cannot);\n  if (s && typeof s.then === \"function\") return s.then(() => e.build(i));\n  return e.build(i);\n}\nconst dt = t => `Cannot execute \"${t.action}\" on \"${t.subjectType}\"`;\nconst yt = function t(i) {\n  this.message = i;\n};\nyt.prototype = Object.create(Error.prototype);\nclass ForbiddenError extends yt {\n  static setDefaultMessage(t) {\n    this.P = typeof t === \"string\" ? () => t : t;\n  }\n  static from(t) {\n    return new this(t);\n  }\n  constructor(t) {\n    super(\"\");\n    this.ability = t;\n    if (typeof Error.captureStackTrace === \"function\") {\n      this.name = \"ForbiddenError\";\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n  setMessage(t) {\n    this.message = t;\n    return this;\n  }\n  throwUnlessCan(t, i, e) {\n    const s = this.unlessCan(t, i, e);\n    if (s) throw s;\n  }\n  unlessCan(t, i, e) {\n    const s = this.ability.relevantRuleFor(t, i, e);\n    if (s && !s.inverted) return;\n    this.action = t;\n    this.subject = i;\n    this.subjectType = T(this.ability.detectSubjectType(i));\n    this.field = e;\n    const n = s ? s.reason : \"\";\n    this.message = this.message || n || this.constructor.P(this);\n    return this;\n  }\n}\nForbiddenError.P = dt;\nvar pt = Object.freeze({\n  __proto__: null\n});\nexport { Ability, AbilityBuilder, ForbiddenError, PureAbility, et as buildMongoQueryMatcher, L as createAliasResolver, createMongoAbility, defineAbility, z as detectSubjectType, at as fieldPatternMatcher, dt as getDefaultErrorMessage, pt as hkt, st as mongoQueryMatcher, R as subject, O as wrapArray };","map":{"version":3,"names":["O","t","Array","isArray","C","R","i","Object","hasOwn","defineProperty","value","Error","P","S","modelName","name","T","z","constructor","B","function","string","q","e","s","n","length","D","indexOf","Y","concat","k","keys","join","L","skipValidate","anyAction","U","push","G","priority","H","get","set","I","J","fields","fieldMatcher","conditions","conditionsMatcher","K","action","resolveAction","subject","inverted","reason","origin","o","ast","matchesConditions","matchesField","u","N","prev","next","Q","V","W","rules","merged","X","Map","Z","h","l","p","$","A","anySubjectType","m","M","detectSubjectType","j","v","update","ability","target","_","r","c","possibleRulesFor","has","rulesFor","filter","actionsFor","Set","from","forEach","add","on","F","delete","PureAbility","can","relevantRuleFor","cannot","tt","$eq","$ne","$lt","$lte","$gt","$gte","$in","$nin","$all","$size","$regex","a","$options","f","$elemMatch","d","$exists","y","it","eq","ne","b","lt","w","lte","g","gt","gte","in","nin","all","size","E","regex","x","elemMatch","exists","and","et","assign","st","nt","rt","ot","ct","ut","replace","ht","map","RegExp","at","every","test","Ability","createMongoAbility","isAbilityClass","prototype","ft","because","AbilityBuilder","build","defineAbility","then","dt","subjectType","yt","message","create","ForbiddenError","setDefaultMessage","captureStackTrace","setMessage","throwUnlessCan","unlessCan","field","pt","freeze","__proto__","buildMongoQueryMatcher","createAliasResolver","fieldPatternMatcher","getDefaultErrorMessage","hkt","mongoQueryMatcher","wrapArray"],"sources":["../../src/utils.ts","../../src/Rule.ts","../../src/structures/LinkedItem.ts","../../src/RuleIndex.ts","../../src/PureAbility.ts","../../src/matchers/conditions.ts","../../src/matchers/field.ts","../../src/Ability.ts","../../src/AbilityBuilder.ts","../../src/ForbiddenError.ts"],"sourcesContent":["import { AnyObject, Subject, SubjectType, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!Object.hasOwn(object, TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport const isSubjectType = (value: unknown): value is SubjectType => {\n  const type = typeof value;\n  return type === 'string' || type === 'function';\n};\n\nconst getSubjectClassName = (value: SubjectClass) => value.modelName || value.name;\nexport function getSubjectTypeName(value: SubjectType) {\n  return typeof value === 'string' ? value : getSubjectClassName(value);\n}\n\nexport function detectSubjectType(object: Exclude<Subject, SubjectType>): string {\n  if (Object.hasOwn(object, TYPE_FIELD)) {\n    return object[TYPE_FIELD];\n  }\n\n  return getSubjectClassName(object.constructor as SubjectClass);\n}\n\nexport const DETECT_SUBJECT_TYPE_STRATEGY = {\n  function: (object: Exclude<Subject, SubjectType>) => object.constructor as SubjectClass,\n  string: detectSubjectType\n};\n\ntype AliasMerge = (actions: string[], action: string | string[]) => string[];\nfunction expandActions(aliasMap: AliasesMap, rawActions: string | string[], merge: AliasMerge) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (Object.hasOwn(aliasMap, action)) {\n      actions = merge(actions, aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction findDuplicate(actions: string[], actionToFind: string | string[]) {\n  if (typeof actionToFind === 'string' && actions.indexOf(actionToFind) !== -1) {\n    return actionToFind;\n  }\n\n  for (let i = 0; i < actionToFind.length; i++) {\n    if (actions.indexOf(actionToFind[i]) !== -1) return actionToFind[i];\n  }\n\n  return null;\n}\n\nconst defaultAliasMerge: AliasMerge = (actions, action) => actions.concat(action);\nfunction validateForCycles(aliasMap: AliasesMap, reservedAction: string) {\n  if (reservedAction in aliasMap) {\n    throw new Error(`Cannot use \"${reservedAction}\" as an alias because it's reserved action.`);\n  }\n\n  const keys = Object.keys(aliasMap);\n  const mergeAliasesAndDetectCycles: AliasMerge = (actions, action) => {\n    const duplicate = findDuplicate(actions, action);\n    if (duplicate) throw new Error(`Detected cycle ${duplicate} -> ${actions.join(', ')}`);\n\n    const isUsingReservedAction = typeof action === 'string' && action === reservedAction\n      || actions.indexOf(reservedAction) !== -1\n      || Array.isArray(action) && action.indexOf(reservedAction) !== -1;\n    if (isUsingReservedAction) throw new Error(`Cannot make an alias to \"${reservedAction}\" because this is reserved action`);\n\n    return actions.concat(action);\n  };\n\n  for (let i = 0; i < keys.length; i++) {\n    expandActions(aliasMap, keys[i], mergeAliasesAndDetectCycles);\n  }\n}\n\nexport type AliasResolverOptions = { skipValidate?: boolean; anyAction?: string };\nexport function createAliasResolver(aliasMap: AliasesMap, options?: AliasResolverOptions) {\n  if (!options || options.skipValidate !== false) {\n    validateForCycles(aliasMap, options && options.anyAction || 'manage');\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action, defaultAliasMerge);\n}\n\nfunction copyArrayTo<T>(dest: T[], target: T[], start: number) {\n  for (let i = start; i < target.length; i++) {\n    dest.push(target[i]);\n  }\n}\n\nexport function mergePrioritized<T extends { priority: number }>(\n  array?: T[],\n  anotherArray?: T[]\n): T[] {\n  if (!array || !array.length) {\n    return anotherArray || [];\n  }\n\n  if (!anotherArray || !anotherArray.length) {\n    return array || [];\n  }\n\n  let i = 0;\n  let j = 0;\n  const merged: T[] = [];\n\n  while (i < array.length && j < anotherArray.length) {\n    if (array[i].priority < anotherArray[j].priority) {\n      merged.push(array[i]);\n      i++;\n    } else {\n      merged.push(anotherArray[j]);\n      j++;\n    }\n  }\n\n  copyArrayTo(merged, array, i);\n  copyArrayTo(merged, anotherArray, j);\n\n  return merged;\n}\n\nexport function getOrDefault<K, V>(map: Map<K, V>, key: K, defaultValue: () => V) {\n  let value = map.get(key);\n\n  if (!value) {\n    value = defaultValue();\n    map.set(key, value);\n  }\n\n  return value;\n}\n\nexport const identity = <T>(x: T) => x;\n","import { wrapArray, isSubjectType } from './utils';\nimport {\n  MatchConditions,\n  MatchField,\n  Abilities,\n  ToAbilityTypes,\n  Normalize,\n  ConditionsMatcher,\n  FieldMatcher,\n} from './types';\nimport { RawRule, RawRuleFrom } from './RawRule';\n\ntype Tuple<A extends Abilities> = Normalize<ToAbilityTypes<A>>;\n\nfunction validate(rule: RawRuleFrom<Abilities, any>, options: RuleOptions<any>) {\n  if (Array.isArray(rule.fields) && !rule.fields.length) {\n    throw new Error('`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa');\n  }\n\n  if (rule.fields && !options.fieldMatcher) {\n    throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  }\n\n  if (rule.conditions && !options.conditionsMatcher) {\n    throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n  }\n}\n\nexport interface RuleOptions<Conditions> {\n  conditionsMatcher?: ConditionsMatcher<Conditions>\n  fieldMatcher?: FieldMatcher\n  resolveAction(action: string | string[]): string | string[]\n}\n\nexport class Rule<A extends Abilities, C> {\n  private _matchConditions: MatchConditions | undefined;\n  private _matchField: MatchField<string> | undefined;\n  private readonly _options!: RuleOptions<C>;\n  public readonly action!: Tuple<A>[0] | Tuple<A>[0][];\n  public readonly subject!: Tuple<A>[1] | Tuple<A>[1][];\n  public readonly inverted!: boolean;\n  public readonly conditions!: C | undefined;\n  public readonly fields!: string[] | undefined;\n  public readonly reason!: string | undefined;\n  public readonly origin!: RawRule<ToAbilityTypes<A>, C>;\n  public readonly priority!: number;\n\n  constructor(\n    rule: RawRule<ToAbilityTypes<A>, C>,\n    options: RuleOptions<C>,\n    priority: number = 0\n  ) {\n    validate(rule, options);\n\n    this.action = options.resolveAction(rule.action);\n    this.subject = rule.subject!;\n    this.inverted = !!rule.inverted;\n    this.conditions = rule.conditions;\n    this.reason = rule.reason;\n    this.origin = rule;\n    this.fields = rule.fields ? wrapArray(rule.fields) : undefined;\n    this.priority = priority;\n    this._options = options;\n  }\n\n  private _conditionsMatcher() {\n    if (this.conditions && !this._matchConditions) {\n      this._matchConditions = this._options.conditionsMatcher!(this.conditions);\n    }\n\n    return this._matchConditions!;\n  }\n\n  get ast() {\n    const matches = this._conditionsMatcher();\n    return matches ? matches.ast : undefined;\n  }\n\n  matchesConditions(object: Normalize<A>[1] | undefined): boolean {\n    if (!this.conditions) {\n      return true;\n    }\n\n    if (!object || isSubjectType(object)) {\n      return !this.inverted;\n    }\n\n    const matches = this._conditionsMatcher();\n    return matches(object as Record<string, unknown>);\n  }\n\n  matchesField(field: string | undefined): boolean {\n    if (!this.fields) {\n      return true;\n    }\n\n    if (!field) {\n      return !this.inverted;\n    }\n\n    if (this.fields && !this._matchField) {\n      this._matchField = this._options.fieldMatcher!(this.fields);\n    }\n\n    return this._matchField!(field);\n  }\n}\n","export interface LinkedItem<T> {\n  next: LinkedItem<T> | null\n  prev: LinkedItem<T> | null\n  readonly value: T\n}\n\nexport function linkedItem<T>(value: T, prev: LinkedItem<T>['prev']) {\n  const item = { value, prev, next: null };\n\n  if (prev) {\n    prev.next = item;\n  }\n\n  return item;\n}\n\nexport function unlinkItem(item: LinkedItem<any>) {\n  if (item.next) {\n    item.next.prev = item.prev;\n  }\n\n  if (item.prev) {\n    item.prev.next = item.next;\n  }\n\n  item.next = item.prev = null; // eslint-disable-line\n}\n\nexport const cloneLinkedItem = <T extends LinkedItem<any>>(item: T): T => ({\n  value: item.value,\n  prev: item.prev,\n  next: item.next,\n} as T);\n","import { Rule, RuleOptions } from './Rule';\nimport { RawRuleFrom } from './RawRule';\nimport {\n  Abilities,\n  Normalize,\n  SubjectType,\n  AbilityParameters,\n  AbilityTuple,\n  ExtractSubjectType\n} from './types';\nimport { wrapArray, detectSubjectType, mergePrioritized, getOrDefault, identity, isSubjectType, DETECT_SUBJECT_TYPE_STRATEGY } from './utils';\nimport { LinkedItem, linkedItem, unlinkItem, cloneLinkedItem } from './structures/LinkedItem';\n\nexport interface RuleIndexOptions<A extends Abilities, C> extends Partial<RuleOptions<C>> {\n  detectSubjectType?(\n    subject: Exclude<Normalize<A>[1], SubjectType>\n  ): ExtractSubjectType<Normalize<A>[1]>;\n  anyAction?: string;\n  anySubjectType?: string;\n}\n\nexport declare const ɵabilities: unique symbol;\nexport declare const ɵconditions: unique symbol;\ninterface WithGenerics {\n  [ɵabilities]: any\n  [ɵconditions]: any\n}\nexport type Public<T extends WithGenerics> = { [K in keyof T]: T[K] };\nexport interface Generics<T extends WithGenerics> {\n  abilities: T[typeof ɵabilities],\n  conditions: T[typeof ɵconditions]\n}\n\nexport type RuleOf<T extends WithGenerics> =\n  Rule<Generics<T>['abilities'], Generics<T>['conditions']>;\nexport type RawRuleOf<T extends WithGenerics> =\n  RawRuleFrom<Generics<T>['abilities'], Generics<T>['conditions']>;\n\nexport type RuleIndexOptionsOf<T extends WithGenerics> =\n  RuleIndexOptions<Generics<T>['abilities'], Generics<T>['conditions']>;\n\ninterface AbilityEvent<T extends WithGenerics> {\n  target: T\n  /** @deprecated use \"target\" property instead */\n  ability: T\n}\n\nexport interface UpdateEvent<T extends WithGenerics> extends AbilityEvent<T> {\n  rules: RawRuleOf<T>[]\n}\n/**\n * @deprecated `on`/`emit` properly infer type without this type\n * TODO(major): delete\n */\nexport type EventHandler<Event> = (event: Event) => void;\n\nexport type Events<\n  T extends WithGenerics,\n  K extends keyof EventsMap<T> = keyof EventsMap<T>\n> = Map<K, LinkedItem<EventsMap<T>[K]> | null>;\n\ninterface EventsMap<T extends WithGenerics> {\n  update(event: UpdateEvent<T>): void\n  updated(event: UpdateEvent<T>): void\n}\n\ntype IndexTree<A extends Abilities, C> = Map<SubjectType, Map<string, {\n  rules: Rule<A, C>[],\n  merged: boolean\n}>>;\n\nexport type Unsubscribe = () => void;\n\nconst defaultActionEntry = () => ({\n  rules: [] as unknown as Rule<any, any>[],\n  merged: false\n});\nconst defaultSubjectEntry = () => new Map<string, ReturnType<typeof defaultActionEntry>>();\n\ntype AbilitySubjectTypeParameters<T extends Abilities, IncludeField extends boolean = true> =\n  AbilityParameters<\n  T,\n  T extends AbilityTuple\n    ? IncludeField extends true\n      ? (action: T[0], subject: ExtractSubjectType<T[1]>, field?: string) => 0\n      : (action: T[0], subject: ExtractSubjectType<T[1]>) => 0\n    : never,\n  (action: Extract<T, string>) => 0\n  >;\n\nexport class RuleIndex<A extends Abilities, Conditions> {\n  private _hasPerFieldRules: boolean = false;\n  private _events?: Events<this>;\n  private _indexedRules: IndexTree<A, Conditions> = new Map();\n  private _rules: RawRuleFrom<A, Conditions>[];\n  private readonly _ruleOptions: RuleOptions<Conditions>;\n  private _detectSubjectType: this['detectSubjectType'];\n  private readonly _anyAction: string;\n  private readonly _anySubjectType: string;\n  private readonly _hasCustomSubjectTypeDetection: boolean;\n  readonly [ɵabilities]!: A;\n  readonly [ɵconditions]!: Conditions;\n\n  constructor(\n    rules: RawRuleFrom<A, Conditions>[] = [],\n    options: RuleIndexOptions<A, Conditions> = {}\n  ) {\n    this._ruleOptions = {\n      conditionsMatcher: options.conditionsMatcher,\n      fieldMatcher: options.fieldMatcher,\n      resolveAction: options.resolveAction || identity,\n    };\n    this._anyAction = options.anyAction || 'manage';\n    this._anySubjectType = options.anySubjectType || 'all';\n    this._rules = rules;\n    this._hasCustomSubjectTypeDetection = !!options.detectSubjectType;\n    this._detectSubjectType = options.detectSubjectType || (detectSubjectType as this['detectSubjectType']);\n    this._indexAndAnalyzeRules(rules);\n  }\n\n  get rules() {\n    return this._rules;\n  }\n\n  detectSubjectType(object?: Normalize<A>[1]): ExtractSubjectType<Normalize<A>[1]> {\n    if (isSubjectType(object)) return object as ExtractSubjectType<Normalize<A>[1]>;\n    if (!object) return this._anySubjectType as ExtractSubjectType<Normalize<A>[1]>;\n    return this._detectSubjectType(object as Exclude<Normalize<A>[1], SubjectType>);\n  }\n\n  update(rules: RawRuleFrom<A, Conditions>[]): Public<this> {\n    const event = {\n      rules,\n      ability: this,\n      target: this\n    } as unknown as UpdateEvent<this>;\n\n    this._emit('update', event);\n    this._rules = rules;\n    this._indexAndAnalyzeRules(rules);\n    this._emit('updated', event);\n\n    return this;\n  }\n\n  private _indexAndAnalyzeRules(rawRules: RawRuleFrom<A, Conditions>[]) {\n    const indexedRules: IndexTree<A, Conditions> = new Map();\n    let typeOfSubjectType: string | undefined;\n\n    for (let i = rawRules.length - 1; i >= 0; i--) {\n      const priority = rawRules.length - i - 1;\n      const rule = new Rule(rawRules[i], this._ruleOptions, priority);\n      const actions = wrapArray(rule.action);\n      const subjects = wrapArray(rule.subject || this._anySubjectType);\n      if (!this._hasPerFieldRules && rule.fields) this._hasPerFieldRules = true;\n\n      for (let k = 0; k < subjects.length; k++) {\n        const subjectRules = getOrDefault(indexedRules, subjects[k], defaultSubjectEntry);\n        if (typeOfSubjectType === undefined) {\n          typeOfSubjectType = typeof subjects[k];\n        }\n        if (typeof subjects[k] !== typeOfSubjectType && typeOfSubjectType !== 'mixed') {\n          typeOfSubjectType = 'mixed';\n        }\n\n        for (let j = 0; j < actions.length; j++) {\n          getOrDefault(subjectRules, actions[j], defaultActionEntry).rules.push(rule);\n        }\n      }\n    }\n\n    this._indexedRules = indexedRules;\n    if (typeOfSubjectType !== 'mixed' && !this._hasCustomSubjectTypeDetection) {\n      const detectSubjectType = DETECT_SUBJECT_TYPE_STRATEGY[typeOfSubjectType as 'function' | 'string'] || DETECT_SUBJECT_TYPE_STRATEGY.string;\n      this._detectSubjectType = detectSubjectType as this['detectSubjectType'];\n    }\n  }\n\n  possibleRulesFor(...args: AbilitySubjectTypeParameters<A, false>): Rule<A, Conditions>[];\n  possibleRulesFor(\n    action: string,\n    subjectType: SubjectType = this._anySubjectType\n  ): Rule<A, Conditions>[] {\n    if (!isSubjectType(subjectType)) {\n      throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    }\n\n    const subjectRules = getOrDefault(this._indexedRules, subjectType, defaultSubjectEntry);\n    const actionRules = getOrDefault(subjectRules, action, defaultActionEntry);\n\n    if (actionRules.merged) {\n      return actionRules.rules;\n    }\n\n    const anyActionRules = action !== this._anyAction && subjectRules.has(this._anyAction)\n      ? subjectRules.get(this._anyAction)!.rules\n      : undefined;\n    let rules = mergePrioritized(actionRules.rules, anyActionRules);\n\n    if (subjectType !== this._anySubjectType) {\n      rules = mergePrioritized(rules, (this as any).possibleRulesFor(action, this._anySubjectType));\n    }\n\n    actionRules.rules = rules;\n    actionRules.merged = true;\n\n    return rules;\n  }\n\n  rulesFor(...args: AbilitySubjectTypeParameters<A>): Rule<A, Conditions>[];\n  rulesFor(action: string, subjectType?: SubjectType, field?: string): Rule<A, Conditions>[] {\n    const rules: Rule<A, Conditions>[] = (this as any).possibleRulesFor(action, subjectType);\n\n    if (field && typeof field !== 'string') {\n      throw new Error('The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details');\n    }\n\n    if (!this._hasPerFieldRules) {\n      return rules;\n    }\n\n    return rules.filter(rule => rule.matchesField(field));\n  }\n\n  actionsFor(subjectType: ExtractSubjectType<Normalize<A>[1]>): string[] {\n    if (!isSubjectType(subjectType)) {\n      throw new Error('\"actionsFor\" accepts only subject types (i.e., string or class) as a parameter');\n    }\n\n    const actions = new Set<string>();\n\n    const subjectRules = this._indexedRules.get(subjectType);\n    if (subjectRules) {\n      Array.from(subjectRules.keys()).forEach(action => actions.add(action));\n    }\n\n    const anySubjectTypeRules = subjectType !== this._anySubjectType\n      ? this._indexedRules.get(this._anySubjectType)\n      : undefined;\n    if (anySubjectTypeRules) {\n      Array.from(anySubjectTypeRules.keys()).forEach(action => actions.add(action));\n    }\n\n    return Array.from(actions);\n  }\n\n  on<T extends keyof EventsMap<this>>(\n    event: T,\n    handler: EventsMap<Public<this>>[T]\n  ): Unsubscribe {\n    this._events = this._events || new Map();\n    const events = this._events;\n    const tail = events.get(event) || null;\n    const item = linkedItem(handler, tail);\n    events.set(event, item);\n\n    return () => {\n      const currentTail = events.get(event);\n\n      if (!item.next && !item.prev && currentTail === item) {\n        events.delete(event);\n      } else if (item === currentTail) {\n        events.set(event, item.prev);\n      }\n\n      unlinkItem(item);\n    };\n  }\n\n  private _emit<T extends keyof EventsMap<this>>(\n    name: T,\n    payload: Parameters<EventsMap<this>[T]>[0]\n  ) {\n    if (!this._events) return;\n\n    let current = this._events.get(name) || null;\n    while (current !== null) {\n      const prev = current.prev ? cloneLinkedItem(current.prev) : null;\n      current.value(payload);\n      current = prev;\n    }\n  }\n}\n","import { RuleIndex, RuleIndexOptions, RuleIndexOptionsOf, Public, RawRuleOf } from './RuleIndex';\nimport { Abilities, AbilityTuple, CanParameters, Subject } from './types';\nimport { Rule } from './Rule';\n\nexport interface AbilityOptions<A extends Abilities, Conditions>\n  extends RuleIndexOptions<A, Conditions> {}\nexport interface AnyAbility extends Public<PureAbility<any, any>> {}\nexport interface AbilityOptionsOf<T extends AnyAbility> extends RuleIndexOptionsOf<T> {}\n\nexport type AbilityClass<T extends AnyAbility> = new (\n  rules?: RawRuleOf<T>[],\n  options?: AbilityOptionsOf<T>\n) => T;\n\nexport type CreateAbility<T extends AnyAbility> = (\n  rules?: RawRuleOf<T>[],\n  options?: AbilityOptionsOf<T>\n) => T;\n\nexport class PureAbility<\n  A extends Abilities = AbilityTuple,\n  Conditions = unknown\n> extends RuleIndex<A, Conditions> {\n  can(...args: CanParameters<A>): boolean;\n  can(action: string, subject?: Subject, field?: string): boolean {\n    const rule = (this as PrimitiveAbility).relevantRuleFor(action, subject, field);\n    return !!rule && !rule.inverted;\n  }\n\n  relevantRuleFor(...args: CanParameters<A>): Rule<A, Conditions> | null;\n  relevantRuleFor(action: string, subject?: Subject, field?: string): Rule<A, Conditions> | null {\n    const subjectType = this.detectSubjectType(subject);\n    const rules = (this as any).rulesFor(action, subjectType, field);\n\n    for (let i = 0, length = rules.length; i < length; i++) {\n      if (rules[i].matchesConditions(subject)) {\n        return rules[i];\n      }\n    }\n\n    return null;\n  }\n\n  cannot(...args: CanParameters<A>): boolean;\n  cannot(action: string, subject?: Subject, field?: string): boolean {\n    return !(this as PrimitiveAbility).can(action, subject, field);\n  }\n}\n\n/**\n * helper interface that helps to emit js methods that have static parameters\n */\ninterface PrimitiveAbility<A extends Abilities = AbilityTuple, Conditions = unknown> {\n  can(action: string, subject?: Subject, field?: string): boolean;\n  relevantRuleFor(action: string, subject?: Subject, field?: string): Rule<A, Conditions> | null\n}\n","import {\n  $eq,\n  eq,\n  $ne,\n  ne,\n  $lt,\n  lt,\n  $lte,\n  lte,\n  $gt,\n  gt,\n  $gte,\n  gte,\n  $in,\n  within,\n  $nin,\n  nin,\n  $all,\n  all,\n  $size,\n  size,\n  $regex,\n  $options,\n  regex,\n  $elemMatch,\n  elemMatch,\n  $exists,\n  exists,\n  and,\n  createFactory,\n  BuildMongoQuery,\n  DefaultOperators,\n} from '@ucast/mongo2js';\nimport { ConditionsMatcher, AnyObject } from '../types';\nimport { Container, GenericFactory } from '../hkt';\n\nconst defaultInstructions = {\n  $eq,\n  $ne,\n  $lt,\n  $lte,\n  $gt,\n  $gte,\n  $in,\n  $nin,\n  $all,\n  $size,\n  $regex,\n  $options,\n  $elemMatch,\n  $exists,\n};\nconst defaultInterpreters = {\n  eq,\n  ne,\n  lt,\n  lte,\n  gt,\n  gte,\n  in: within,\n  nin,\n  all,\n  size,\n  regex,\n  elemMatch,\n  exists,\n  and,\n};\n\ninterface MongoQueryFactory extends GenericFactory {\n  produce: MongoQuery<this[0]>\n}\n\ntype MergeUnion<T, Keys extends keyof T = keyof T> = { [K in Keys]: T[K] };\nexport type MongoQuery<T = AnyObject> = BuildMongoQuery<MergeUnion<T>, {\n  toplevel: {},\n  field: Pick<DefaultOperators<MergeUnion<T>>['field'], keyof typeof defaultInstructions>\n}> & Container<MongoQueryFactory>;\n\ntype MongoQueryMatcherFactory =\n  (...args: Partial<Parameters<typeof createFactory>>) => ConditionsMatcher<MongoQuery>;\nexport const buildMongoQueryMatcher = ((instructions, interpreters, options) => createFactory(\n  { ...defaultInstructions, ...instructions },\n  { ...defaultInterpreters, ...interpreters },\n  options\n)) as MongoQueryMatcherFactory;\n\nexport const mongoQueryMatcher = createFactory(defaultInstructions, defaultInterpreters);\nexport type {\n  MongoQueryFieldOperators,\n  MongoQueryTopLevelOperators,\n  MongoQueryOperators,\n} from '@ucast/mongo2js';\n","import { FieldMatcher } from '../types';\n\nconst REGEXP_SPECIAL_CHARS = /[-/\\\\^$+?.()|[\\]{}]/g;\nconst REGEXP_ANY = /\\.?\\*+\\.?/g;\nconst REGEXP_STARS = /\\*+/;\nconst REGEXP_DOT = /\\./g;\n\nfunction detectRegexpPattern(match: string, index: number, string: string): string {\n  const quantifier = string[0] === '*' || match[0] === '.' && match[match.length - 1] === '.'\n    ? '+'\n    : '*';\n  const matcher = match.indexOf('**') === -1 ? '[^.]' : '.';\n  const pattern = match.replace(REGEXP_DOT, '\\\\$&')\n    .replace(REGEXP_STARS, matcher + quantifier);\n\n  return index + match.length === string.length ? `(?:${pattern})?` : pattern;\n}\n\nfunction escapeRegexp(match: string, index: number, string: string): string {\n  if (match === '.' && (string[index - 1] === '*' || string[index + 1] === '*')) {\n    return match;\n  }\n\n  return `\\\\${match}`;\n}\n\nfunction createPattern(fields: string[]) {\n  const patterns = fields.map(field => field\n    .replace(REGEXP_SPECIAL_CHARS, escapeRegexp)\n    .replace(REGEXP_ANY, detectRegexpPattern));\n  const pattern = patterns.length > 1 ? `(?:${patterns.join('|')})` : patterns[0];\n\n  return new RegExp(`^${pattern}$`);\n}\n\nexport const fieldPatternMatcher: FieldMatcher = (fields) => {\n  let pattern: RegExp | null;\n\n  return (field) => {\n    if (typeof pattern === 'undefined') {\n      pattern = fields.every(f => f.indexOf('*') === -1)\n        ? null\n        : createPattern(fields);\n    }\n\n    return pattern === null\n      ? fields.indexOf(field) !== -1\n      : pattern.test(field);\n  };\n};\n","import { PureAbility, AbilityOptions, AbilityOptionsOf } from './PureAbility';\nimport { RawRuleFrom } from './RawRule';\nimport { AbilityTuple } from './types';\nimport { MongoQuery, mongoQueryMatcher } from './matchers/conditions';\nimport { fieldPatternMatcher } from './matchers/field';\nimport { Public, RawRuleOf } from './RuleIndex';\n\n/**\n * @deprecated use createMongoAbility function instead and MongoAbility<Abilities> interface.\n * In the next major version PureAbility will be renamed to Ability and this class will be removed\n */\nexport class Ability<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n> extends PureAbility<A, C> {\n  constructor(rules: RawRuleFrom<A, C>[] = [], options: AbilityOptions<A, C> = {}) {\n    super(rules, {\n      conditionsMatcher: mongoQueryMatcher,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n\nexport interface AnyMongoAbility extends Public<PureAbility<any, MongoQuery>> {}\nexport interface MongoAbility<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n> extends PureAbility<A, C> {}\n\n/**\n * Creates Ability with MongoDB conditions matcher\n */\nexport function createMongoAbility<\n  T extends AnyMongoAbility = MongoAbility\n>(rules?: RawRuleOf<T>[], options?: AbilityOptionsOf<T>): T;\nexport function createMongoAbility<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n>(rules?: RawRuleFrom<A, C>[], options?: AbilityOptions<A, C>): MongoAbility<A, C>;\nexport function createMongoAbility(rules: any[] = [], options = {}): AnyMongoAbility {\n  return new PureAbility(rules, {\n    conditionsMatcher: mongoQueryMatcher,\n    fieldMatcher: fieldPatternMatcher,\n    ...options,\n  });\n}\n","import { AnyMongoAbility, createMongoAbility, MongoAbility } from './Ability';\nimport { ProduceGeneric } from './hkt';\nimport { AbilityOptionsOf, AnyAbility } from './PureAbility';\nimport { Generics, RawRuleOf } from './RuleIndex';\nimport {\n  AbilityTuple, AnyClass, AnyObject, ExtractSubjectType as E, Normalize, SubjectType,\n  TaggedInterface\n} from './types';\n\nfunction isAbilityClass(factory: AbilityFactory<any>): factory is AnyClass {\n  return typeof factory.prototype.possibleRulesFor === 'function';\n}\n\nclass RuleBuilder<T extends AnyAbility> {\n  public _rule!: RawRuleOf<T>;\n\n  constructor(rule: RawRuleOf<T>) {\n    this._rule = rule;\n  }\n\n  because(reason: string): this {\n    this._rule.reason = reason;\n    return this;\n  }\n}\n\ntype AbilityFactory<T extends AnyAbility> = AnyClass<T> | ((rules?: any[], options?: any) => T);\ntype InstanceOf<T extends AnyAbility, S extends SubjectType> = S extends AnyClass<infer R>\n  ? R\n  : S extends (...args: any[]) => infer O\n    ? O\n    : S extends string\n      ? Exclude<Normalize<Generics<T>['abilities']>[1], SubjectType> extends TaggedInterface<string>\n        ? Extract<Normalize<Generics<T>['abilities']>[1], TaggedInterface<S>>\n        : AnyObject\n      : never;\ntype ConditionsOf<T extends AnyAbility, I extends {}> =\n  ProduceGeneric<Generics<T>['conditions'], I>;\ntype ActionFrom<T extends AbilityTuple, S extends SubjectType> = T extends any\n  ? S extends Extract<T[1], SubjectType> ? T[0] : never\n  : never;\ntype ActionOf<T extends AnyAbility, S extends SubjectType> = ActionFrom<Generics<T>['abilities'], S>;\ntype SubjectTypeOf<T extends AnyAbility> = E<Normalize<Generics<T>['abilities']>[1]>;\n\ntype SimpleCanParams<T extends AnyAbility> = Parameters<(\n  action: Generics<T>['abilities'] | Generics<T>['abilities'][]\n) => 0>;\ntype BuilderCanParameters<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\n\ntype BuilderCanParametersWithFields<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  F extends string,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    fields?: F | F[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\ntype Keys<T> = string & keyof T;\n\ntype AddRule<T extends AnyAbility> = {\n  <\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>;\n  <\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>;\n};\n\nexport class AbilityBuilder<T extends AnyAbility> {\n  public rules: RawRuleOf<T>[] = [];\n  private readonly _createAbility: AbilityFactory<T>;\n  public can: AddRule<T>;\n  public cannot: AddRule<T>;\n  public build: (options?: AbilityOptionsOf<T>) => T;\n\n  constructor(AbilityType: AbilityFactory<T>) {\n    this._createAbility = AbilityType;\n\n    this.can = (\n      action: string | string[],\n      subject?: SubjectType | SubjectType[],\n      conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n      conditions?: Generics<T>['conditions']\n    ) => this._addRule(action, subject, conditionsOrFields, conditions, false);\n    this.cannot = (\n      action: string | string[],\n      subject?: SubjectType | SubjectType[],\n      conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n      conditions?: Generics<T>['conditions']\n    ) => this._addRule(action, subject, conditionsOrFields, conditions, true);\n\n    this.build = options => (isAbilityClass(this._createAbility)\n      ? new this._createAbility(this.rules, options)\n      : this._createAbility(this.rules, options));\n  }\n\n  private _addRule(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions'],\n    inverted?: boolean\n  ): RuleBuilder<T> {\n    const rule = { action } as RawRuleOf<T>;\n\n    if (inverted) rule.inverted = inverted;\n    if (subject) {\n      rule.subject = subject;\n\n      if (Array.isArray(conditionsOrFields) || typeof conditionsOrFields === 'string') {\n        rule.fields = conditionsOrFields;\n      } else if (typeof conditionsOrFields !== 'undefined') {\n        rule.conditions = conditionsOrFields;\n      }\n\n      if (typeof conditions !== 'undefined') {\n        rule.conditions = conditions;\n      }\n    }\n\n    this.rules.push(rule);\n    return new RuleBuilder(rule);\n  }\n}\n\ntype DSL<T extends AnyAbility, R> = (\n  can: AbilityBuilder<T>['can'],\n  cannot: AbilityBuilder<T>['cannot']\n) => R;\n\nexport function defineAbility<\n  T extends AnyMongoAbility = MongoAbility\n>(define: DSL<T, Promise<void>>, options?: AbilityOptionsOf<T>): Promise<T>;\nexport function defineAbility<\n  T extends AnyMongoAbility = MongoAbility\n>(define: DSL<T, void>, options?: AbilityOptionsOf<T>): T;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void | Promise<void>>, options?: AbilityOptionsOf<T>): T | Promise<T> {\n  const builder = new AbilityBuilder<T>(createMongoAbility);\n  const result = define(builder.can, builder.cannot);\n\n  if (result && typeof result.then === 'function') {\n    return result.then(() => builder.build(options));\n  }\n\n  return builder.build(options);\n}\n","import { AnyAbility } from './PureAbility';\nimport { Normalize, Subject } from './types';\nimport { Generics } from './RuleIndex';\nimport { getSubjectTypeName } from './utils';\n\nexport type GetErrorMessage = (error: ForbiddenError<AnyAbility>) => string;\n/** @deprecated will be removed in the next major release */\nexport const getDefaultErrorMessage: GetErrorMessage = error => `Cannot execute \"${error.action}\" on \"${error.subjectType}\"`;\n\nconst NativeError = function NError(this: Error, message: string) {\n  this.message = message;\n} as unknown as new (message: string) => Error;\n\nNativeError.prototype = Object.create(Error.prototype);\n\nexport class ForbiddenError<T extends AnyAbility> extends NativeError {\n  public readonly ability!: T;\n  public action!: Normalize<Generics<T>['abilities']>[0];\n  public subject!: Generics<T>['abilities'][1];\n  public field?: string;\n  public subjectType!: string;\n\n  static _defaultErrorMessage = getDefaultErrorMessage;\n\n  static setDefaultMessage(messageOrFn: string | GetErrorMessage) {\n    this._defaultErrorMessage = typeof messageOrFn === 'string' ? () => messageOrFn : messageOrFn;\n  }\n\n  static from<U extends AnyAbility>(ability: U): ForbiddenError<U> {\n    return new this<U>(ability);\n  }\n\n  private constructor(ability: T) {\n    super('');\n    this.ability = ability;\n\n    if (typeof Error.captureStackTrace === 'function') {\n      this.name = 'ForbiddenError';\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  setMessage(message: string): this {\n    this.message = message;\n    return this;\n  }\n\n  throwUnlessCan(...args: Parameters<T['can']>): void;\n  throwUnlessCan(action: string, subject?: Subject, field?: string): void {\n    const error = (this as any).unlessCan(action, subject, field);\n    if (error) throw error;\n  }\n\n  unlessCan(...args: Parameters<T['can']>): this | undefined;\n  unlessCan(action: string, subject?: Subject, field?: string): this | undefined {\n    const rule = this.ability.relevantRuleFor(action, subject, field);\n\n    if (rule && !rule.inverted) {\n      return;\n    }\n\n    this.action = action;\n    this.subject = subject;\n    this.subjectType = getSubjectTypeName(this.ability.detectSubjectType(subject));\n    this.field = field;\n\n    const reason = rule ? rule.reason : '';\n    // eslint-disable-next-line no-underscore-dangle\n    this.message = this.message || reason || (this.constructor as any)._defaultErrorMessage(this);\n    return this; // eslint-disable-line consistent-return\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}