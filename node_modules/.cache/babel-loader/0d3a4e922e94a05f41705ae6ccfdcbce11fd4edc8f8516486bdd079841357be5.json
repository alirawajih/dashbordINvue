{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst http2 = require(\"http2\");\nconst stream_1 = require(\"stream\");\nconst call_credentials_1 = require(\"./call-credentials\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst {\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_CONTENT_TYPE,\n  NGHTTP2_CANCEL\n} = http2.constants;\nvar ReadState;\n(function (ReadState) {\n  ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n  ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n  ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\nclass Http2CallStream extends stream_1.Duplex {\n  constructor(methodName, channel, options, filterStackFactory) {\n    super({\n      objectMode: true\n    });\n    this.methodName = methodName;\n    this.channel = channel;\n    this.options = options;\n    this.credentials = call_credentials_1.CallCredentials.createEmpty();\n    this.http2Stream = null;\n    this.pendingRead = false;\n    this.pendingWrite = null;\n    this.pendingWriteCallback = null;\n    this.pendingFinalCallback = null;\n    this.readState = ReadState.NO_DATA;\n    this.readCompressFlag = Buffer.alloc(1);\n    this.readPartialSize = Buffer.alloc(4);\n    this.readSizeRemaining = 4;\n    this.readMessageSize = 0;\n    this.readPartialMessage = [];\n    this.readMessageRemaining = 0;\n    this.isReadFilterPending = false;\n    this.canPush = false;\n    this.unpushedReadMessages = [];\n    this.unfilteredReadMessages = [];\n    // Status code mapped from :status. To be used if grpc-status is not received\n    this.mappedStatusCode = constants_1.Status.UNKNOWN;\n    // Promise objects that are re-assigned to resolving promises when headers\n    // or trailers received. Processing headers/trailers is asynchronous, so we\n    // can use these objects to await their completion. This helps us establish\n    // order of precedence when obtaining the status of the call.\n    this.handlingHeaders = Promise.resolve();\n    this.handlingTrailers = Promise.resolve();\n    // This is populated (non-null) if and only if the call has ended\n    this.finalStatus = null;\n    this.filterStack = filterStackFactory.createFilter(this);\n  }\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n  endCall(status) {\n    if (this.finalStatus === null) {\n      this.finalStatus = status;\n      this.emit('status', status);\n    }\n  }\n  handleFilterError(error) {\n    this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n  }\n  handleFilteredRead(message) {\n    /* If we the call has already ended, we don't want to do anything with\n     * this message. Dropping it on the floor is correct behavior */\n    if (this.finalStatus !== null) {\n      return;\n    }\n    this.isReadFilterPending = false;\n    if (this.canPush) {\n      if (!this.push(message)) {\n        this.canPush = false;\n        this.http2Stream.pause();\n      }\n    } else {\n      this.unpushedReadMessages.push(message);\n    }\n    if (this.unfilteredReadMessages.length > 0) {\n      /* nextMessage is guaranteed not to be undefined because\n         unfilteredReadMessages is non-empty */\n      const nextMessage = this.unfilteredReadMessages.shift();\n      this.filterReceivedMessage(nextMessage);\n    }\n  }\n  filterReceivedMessage(framedMessage) {\n    /* If we the call has already ended, we don't want to do anything with\n     * this message. Dropping it on the floor is correct behavior */\n    if (this.finalStatus !== null) {\n      return;\n    }\n    if (framedMessage === null) {\n      if (this.canPush) {\n        this.push(null);\n      } else {\n        this.unpushedReadMessages.push(null);\n      }\n      return;\n    }\n    this.isReadFilterPending = true;\n    this.filterStack.receiveMessage(Promise.resolve(framedMessage)).then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n  }\n  tryPush(messageBytes) {\n    if (this.isReadFilterPending) {\n      this.unfilteredReadMessages.push(messageBytes);\n    } else {\n      this.filterReceivedMessage(messageBytes);\n    }\n  }\n  handleTrailers(headers) {\n    const code = this.mappedStatusCode;\n    const details = '';\n    let metadata;\n    try {\n      metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new metadata_1.Metadata();\n    }\n    const status = {\n      code,\n      details,\n      metadata\n    };\n    this.handlingTrailers = (async () => {\n      let finalStatus;\n      try {\n        // Attempt to assign final status.\n        finalStatus = await this.filterStack.receiveTrailers(Promise.resolve(status));\n      } catch (error) {\n        await this.handlingHeaders;\n        // This is a no-op if the call was already ended when handling headers.\n        this.endCall({\n          code: constants_1.Status.INTERNAL,\n          details: 'Failed to process received status',\n          metadata: new metadata_1.Metadata()\n        });\n        return;\n      }\n      // It's possible that headers were received but not fully handled yet.\n      // Give the headers handler an opportunity to end the call first,\n      // if an error occurred.\n      await this.handlingHeaders;\n      // This is a no-op if the call was already ended when handling headers.\n      this.endCall(finalStatus);\n    })();\n  }\n  attachHttp2Stream(stream) {\n    if (this.finalStatus !== null) {\n      stream.close(NGHTTP2_CANCEL);\n    } else {\n      this.http2Stream = stream;\n      stream.on('response', (headers, flags) => {\n        switch (headers[HTTP2_HEADER_STATUS]) {\n          // TODO(murgatroid99): handle 100 and 101\n          case '400':\n            this.mappedStatusCode = constants_1.Status.INTERNAL;\n            break;\n          case '401':\n            this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n            break;\n          case '403':\n            this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n            break;\n          case '404':\n            this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n            break;\n          case '429':\n          case '502':\n          case '503':\n          case '504':\n            this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n            break;\n          default:\n            this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        }\n        if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n          this.handleTrailers(headers);\n        } else {\n          let metadata;\n          try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n          } catch (error) {\n            this.endCall({\n              code: constants_1.Status.UNKNOWN,\n              details: error.message,\n              metadata: new metadata_1.Metadata()\n            });\n            return;\n          }\n          this.handlingHeaders = this.filterStack.receiveMetadata(Promise.resolve(metadata)).then(finalMetadata => {\n            this.emit('metadata', finalMetadata);\n          }).catch(error => {\n            this.destroyHttp2Stream();\n            this.endCall({\n              code: constants_1.Status.UNKNOWN,\n              details: error.message,\n              metadata: new metadata_1.Metadata()\n            });\n          });\n        }\n      });\n      stream.on('trailers', this.handleTrailers.bind(this));\n      stream.on('data', data => {\n        let readHead = 0;\n        let toRead;\n        while (readHead < data.length) {\n          switch (this.readState) {\n            case ReadState.NO_DATA:\n              this.readCompressFlag = data.slice(readHead, readHead + 1);\n              readHead += 1;\n              this.readState = ReadState.READING_SIZE;\n              this.readPartialSize.fill(0);\n              this.readSizeRemaining = 4;\n              this.readMessageSize = 0;\n              this.readMessageRemaining = 0;\n              this.readPartialMessage = [];\n              break;\n            case ReadState.READING_SIZE:\n              toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n              data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n              this.readSizeRemaining -= toRead;\n              readHead += toRead;\n              // readSizeRemaining >=0 here\n              if (this.readSizeRemaining === 0) {\n                this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n                this.readMessageRemaining = this.readMessageSize;\n                if (this.readMessageRemaining > 0) {\n                  this.readState = ReadState.READING_MESSAGE;\n                } else {\n                  this.tryPush(Buffer.concat([this.readCompressFlag, this.readPartialSize]));\n                  this.readState = ReadState.NO_DATA;\n                }\n              }\n              break;\n            case ReadState.READING_MESSAGE:\n              toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n              this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n              this.readMessageRemaining -= toRead;\n              readHead += toRead;\n              // readMessageRemaining >=0 here\n              if (this.readMessageRemaining === 0) {\n                // At this point, we have read a full message\n                const framedMessageBuffers = [this.readCompressFlag, this.readPartialSize].concat(this.readPartialMessage);\n                const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n                this.tryPush(framedMessage);\n                this.readState = ReadState.NO_DATA;\n              }\n              break;\n            default:\n              throw new Error('This should never happen');\n          }\n        }\n      });\n      stream.on('end', () => {\n        this.tryPush(null);\n      });\n      stream.on('close', async errorCode => {\n        let code;\n        let details = '';\n        switch (errorCode) {\n          case http2.constants.NGHTTP2_REFUSED_STREAM:\n            code = constants_1.Status.UNAVAILABLE;\n            break;\n          case http2.constants.NGHTTP2_CANCEL:\n            code = constants_1.Status.CANCELLED;\n            break;\n          case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n            code = constants_1.Status.RESOURCE_EXHAUSTED;\n            details = 'Bandwidth exhausted';\n            break;\n          case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n            code = constants_1.Status.PERMISSION_DENIED;\n            details = 'Protocol not secure enough';\n            break;\n          default:\n            code = constants_1.Status.INTERNAL;\n        }\n        // This guarantees that if trailers were received, the value of the\n        // 'grpc-status' header takes precedence for emitted status data.\n        await this.handlingTrailers;\n        // This is a no-op if trailers were received at all.\n        // This is OK, because status codes emitted here correspond to more\n        // catastrophic issues that prevent us from receiving trailers in the\n        // first place.\n        this.endCall({\n          code,\n          details,\n          metadata: new metadata_1.Metadata()\n        });\n      });\n      stream.on('error', err => {\n        this.endCall({\n          code: constants_1.Status.INTERNAL,\n          details: 'Internal HTTP2 error',\n          metadata: new metadata_1.Metadata()\n        });\n      });\n      if (!this.pendingRead) {\n        stream.pause();\n      }\n      if (this.pendingWrite) {\n        if (!this.pendingWriteCallback) {\n          throw new Error('Invalid state in write handling code');\n        }\n        stream.write(this.pendingWrite, this.pendingWriteCallback);\n      }\n      if (this.pendingFinalCallback) {\n        stream.end(this.pendingFinalCallback);\n      }\n    }\n  }\n  sendMetadata(metadata) {\n    this.channel._startHttp2Stream(this.options.host, this.methodName, this, metadata);\n  }\n  destroyHttp2Stream() {\n    // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n    if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n      /* TODO(murgatroid99): Determine if we want to send different RST_STREAM\n       * codes based on the status code */\n      this.http2Stream.close(NGHTTP2_CANCEL);\n    }\n  }\n  cancelWithStatus(status, details) {\n    this.destroyHttp2Stream();\n    (async () => {\n      // If trailers are currently being processed, the call should be ended\n      // by handleTrailers instead.\n      await this.handlingTrailers;\n      this.endCall({\n        code: status,\n        details,\n        metadata: new metadata_1.Metadata()\n      });\n    })();\n  }\n  getDeadline() {\n    return this.options.deadline;\n  }\n  getCredentials() {\n    return this.credentials;\n  }\n  setCredentials(credentials) {\n    this.credentials = credentials;\n  }\n  getStatus() {\n    return this.finalStatus;\n  }\n  getPeer() {\n    throw new Error('Not yet implemented');\n  }\n  getMethod() {\n    return this.methodName;\n  }\n  getHost() {\n    return this.options.host;\n  }\n  _read(size) {\n    /* If we have already emitted a status, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null) {\n      this.push(null);\n      return;\n    }\n    this.canPush = true;\n    if (this.http2Stream === null) {\n      this.pendingRead = true;\n    } else {\n      while (this.unpushedReadMessages.length > 0) {\n        const nextMessage = this.unpushedReadMessages.shift();\n        this.canPush = this.push(nextMessage);\n        if (nextMessage === null || !this.canPush) {\n          this.canPush = false;\n          return;\n        }\n      }\n      /* Only resume reading from the http2Stream if we don't have any pending\n       * messages to emit, and we haven't gotten the signal to stop pushing\n       * messages */\n      this.http2Stream.resume();\n    }\n  }\n  _write(chunk, encoding, cb) {\n    this.filterStack.sendMessage(Promise.resolve(chunk)).then(message => {\n      if (this.http2Stream === null) {\n        this.pendingWrite = message.message;\n        this.pendingWriteCallback = cb;\n      } else {\n        this.http2Stream.write(message.message, cb);\n      }\n    }, this.handleFilterError.bind(this));\n  }\n  _final(cb) {\n    if (this.http2Stream === null) {\n      this.pendingFinalCallback = cb;\n    } else {\n      this.http2Stream.end(cb);\n    }\n  }\n}\nexports.Http2CallStream = Http2CallStream;","map":{"version":3,"names":["require","Object","defineProperty","exports","value","http2","stream_1","call_credentials_1","constants_1","metadata_1","HTTP2_HEADER_STATUS","HTTP2_HEADER_CONTENT_TYPE","NGHTTP2_CANCEL","constants","ReadState","Http2CallStream","Duplex","constructor","methodName","channel","options","filterStackFactory","objectMode","credentials","CallCredentials","createEmpty","http2Stream","pendingRead","pendingWrite","pendingWriteCallback","pendingFinalCallback","readState","NO_DATA","readCompressFlag","Buffer","alloc","readPartialSize","readSizeRemaining","readMessageSize","readPartialMessage","readMessageRemaining","isReadFilterPending","canPush","unpushedReadMessages","unfilteredReadMessages","mappedStatusCode","Status","UNKNOWN","handlingHeaders","Promise","resolve","handlingTrailers","finalStatus","filterStack","createFilter","endCall","status","emit","handleFilterError","error","cancelWithStatus","INTERNAL","message","handleFilteredRead","push","pause","length","nextMessage","shift","filterReceivedMessage","framedMessage","receiveMessage","then","bind","tryPush","messageBytes","handleTrailers","headers","code","details","metadata","Metadata","fromHttp2Headers","e","receiveTrailers","attachHttp2Stream","stream","close","on","flags","UNAUTHENTICATED","PERMISSION_DENIED","UNIMPLEMENTED","UNAVAILABLE","NGHTTP2_FLAG_END_STREAM","receiveMetadata","finalMetadata","catch","destroyHttp2Stream","data","readHead","toRead","slice","READING_SIZE","fill","Math","min","copy","readUInt32BE","READING_MESSAGE","concat","framedMessageBuffers","Error","errorCode","NGHTTP2_REFUSED_STREAM","CANCELLED","NGHTTP2_ENHANCE_YOUR_CALM","RESOURCE_EXHAUSTED","NGHTTP2_INADEQUATE_SECURITY","err","write","end","sendMetadata","_startHttp2Stream","host","destroyed","getDeadline","deadline","getCredentials","setCredentials","getStatus","getPeer","getMethod","getHost","_read","size","resume","_write","chunk","encoding","cb","sendMessage","_final"],"sources":["/var/www/html/project/Dash_Vuexy-master/node_modules/@grpc/grpc-js/build/src/call-stream.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http2 = require(\"http2\");\nconst stream_1 = require(\"stream\");\nconst call_credentials_1 = require(\"./call-credentials\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst { HTTP2_HEADER_STATUS, HTTP2_HEADER_CONTENT_TYPE, NGHTTP2_CANCEL } = http2.constants;\nvar ReadState;\n(function (ReadState) {\n    ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n    ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n    ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\nclass Http2CallStream extends stream_1.Duplex {\n    constructor(methodName, channel, options, filterStackFactory) {\n        super({ objectMode: true });\n        this.methodName = methodName;\n        this.channel = channel;\n        this.options = options;\n        this.credentials = call_credentials_1.CallCredentials.createEmpty();\n        this.http2Stream = null;\n        this.pendingRead = false;\n        this.pendingWrite = null;\n        this.pendingWriteCallback = null;\n        this.pendingFinalCallback = null;\n        this.readState = ReadState.NO_DATA;\n        this.readCompressFlag = Buffer.alloc(1);\n        this.readPartialSize = Buffer.alloc(4);\n        this.readSizeRemaining = 4;\n        this.readMessageSize = 0;\n        this.readPartialMessage = [];\n        this.readMessageRemaining = 0;\n        this.isReadFilterPending = false;\n        this.canPush = false;\n        this.unpushedReadMessages = [];\n        this.unfilteredReadMessages = [];\n        // Status code mapped from :status. To be used if grpc-status is not received\n        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        // Promise objects that are re-assigned to resolving promises when headers\n        // or trailers received. Processing headers/trailers is asynchronous, so we\n        // can use these objects to await their completion. This helps us establish\n        // order of precedence when obtaining the status of the call.\n        this.handlingHeaders = Promise.resolve();\n        this.handlingTrailers = Promise.resolve();\n        // This is populated (non-null) if and only if the call has ended\n        this.finalStatus = null;\n        this.filterStack = filterStackFactory.createFilter(this);\n    }\n    /**\n     * On first call, emits a 'status' event with the given StatusObject.\n     * Subsequent calls are no-ops.\n     * @param status The status of the call.\n     */\n    endCall(status) {\n        if (this.finalStatus === null) {\n            this.finalStatus = status;\n            this.emit('status', status);\n        }\n    }\n    handleFilterError(error) {\n        this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n    }\n    handleFilteredRead(message) {\n        /* If we the call has already ended, we don't want to do anything with\n         * this message. Dropping it on the floor is correct behavior */\n        if (this.finalStatus !== null) {\n            return;\n        }\n        this.isReadFilterPending = false;\n        if (this.canPush) {\n            if (!this.push(message)) {\n                this.canPush = false;\n                this.http2Stream.pause();\n            }\n        }\n        else {\n            this.unpushedReadMessages.push(message);\n        }\n        if (this.unfilteredReadMessages.length > 0) {\n            /* nextMessage is guaranteed not to be undefined because\n               unfilteredReadMessages is non-empty */\n            const nextMessage = this.unfilteredReadMessages.shift();\n            this.filterReceivedMessage(nextMessage);\n        }\n    }\n    filterReceivedMessage(framedMessage) {\n        /* If we the call has already ended, we don't want to do anything with\n         * this message. Dropping it on the floor is correct behavior */\n        if (this.finalStatus !== null) {\n            return;\n        }\n        if (framedMessage === null) {\n            if (this.canPush) {\n                this.push(null);\n            }\n            else {\n                this.unpushedReadMessages.push(null);\n            }\n            return;\n        }\n        this.isReadFilterPending = true;\n        this.filterStack.receiveMessage(Promise.resolve(framedMessage))\n            .then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n    }\n    tryPush(messageBytes) {\n        if (this.isReadFilterPending) {\n            this.unfilteredReadMessages.push(messageBytes);\n        }\n        else {\n            this.filterReceivedMessage(messageBytes);\n        }\n    }\n    handleTrailers(headers) {\n        const code = this.mappedStatusCode;\n        const details = '';\n        let metadata;\n        try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        }\n        catch (e) {\n            metadata = new metadata_1.Metadata();\n        }\n        const status = { code, details, metadata };\n        this.handlingTrailers = (async () => {\n            let finalStatus;\n            try {\n                // Attempt to assign final status.\n                finalStatus =\n                    await this.filterStack.receiveTrailers(Promise.resolve(status));\n            }\n            catch (error) {\n                await this.handlingHeaders;\n                // This is a no-op if the call was already ended when handling headers.\n                this.endCall({\n                    code: constants_1.Status.INTERNAL,\n                    details: 'Failed to process received status',\n                    metadata: new metadata_1.Metadata()\n                });\n                return;\n            }\n            // It's possible that headers were received but not fully handled yet.\n            // Give the headers handler an opportunity to end the call first,\n            // if an error occurred.\n            await this.handlingHeaders;\n            // This is a no-op if the call was already ended when handling headers.\n            this.endCall(finalStatus);\n        })();\n    }\n    attachHttp2Stream(stream) {\n        if (this.finalStatus !== null) {\n            stream.close(NGHTTP2_CANCEL);\n        }\n        else {\n            this.http2Stream = stream;\n            stream.on('response', (headers, flags) => {\n                switch (headers[HTTP2_HEADER_STATUS]) {\n                    // TODO(murgatroid99): handle 100 and 101\n                    case '400':\n                        this.mappedStatusCode = constants_1.Status.INTERNAL;\n                        break;\n                    case '401':\n                        this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n                        break;\n                    case '403':\n                        this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n                        break;\n                    case '404':\n                        this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n                        break;\n                    case '429':\n                    case '502':\n                    case '503':\n                    case '504':\n                        this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n                        break;\n                    default:\n                        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n                }\n                if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n                    this.handleTrailers(headers);\n                }\n                else {\n                    let metadata;\n                    try {\n                        metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n                    }\n                    catch (error) {\n                        this.endCall({\n                            code: constants_1.Status.UNKNOWN,\n                            details: error.message,\n                            metadata: new metadata_1.Metadata()\n                        });\n                        return;\n                    }\n                    this.handlingHeaders =\n                        this.filterStack.receiveMetadata(Promise.resolve(metadata))\n                            .then((finalMetadata) => {\n                            this.emit('metadata', finalMetadata);\n                        })\n                            .catch((error) => {\n                            this.destroyHttp2Stream();\n                            this.endCall({\n                                code: constants_1.Status.UNKNOWN,\n                                details: error.message,\n                                metadata: new metadata_1.Metadata()\n                            });\n                        });\n                }\n            });\n            stream.on('trailers', this.handleTrailers.bind(this));\n            stream.on('data', (data) => {\n                let readHead = 0;\n                let toRead;\n                while (readHead < data.length) {\n                    switch (this.readState) {\n                        case ReadState.NO_DATA:\n                            this.readCompressFlag = data.slice(readHead, readHead + 1);\n                            readHead += 1;\n                            this.readState = ReadState.READING_SIZE;\n                            this.readPartialSize.fill(0);\n                            this.readSizeRemaining = 4;\n                            this.readMessageSize = 0;\n                            this.readMessageRemaining = 0;\n                            this.readPartialMessage = [];\n                            break;\n                        case ReadState.READING_SIZE:\n                            toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n                            data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n                            this.readSizeRemaining -= toRead;\n                            readHead += toRead;\n                            // readSizeRemaining >=0 here\n                            if (this.readSizeRemaining === 0) {\n                                this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n                                this.readMessageRemaining = this.readMessageSize;\n                                if (this.readMessageRemaining > 0) {\n                                    this.readState = ReadState.READING_MESSAGE;\n                                }\n                                else {\n                                    this.tryPush(Buffer.concat([this.readCompressFlag, this.readPartialSize]));\n                                    this.readState = ReadState.NO_DATA;\n                                }\n                            }\n                            break;\n                        case ReadState.READING_MESSAGE:\n                            toRead =\n                                Math.min(data.length - readHead, this.readMessageRemaining);\n                            this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n                            this.readMessageRemaining -= toRead;\n                            readHead += toRead;\n                            // readMessageRemaining >=0 here\n                            if (this.readMessageRemaining === 0) {\n                                // At this point, we have read a full message\n                                const framedMessageBuffers = [\n                                    this.readCompressFlag, this.readPartialSize\n                                ].concat(this.readPartialMessage);\n                                const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n                                this.tryPush(framedMessage);\n                                this.readState = ReadState.NO_DATA;\n                            }\n                            break;\n                        default:\n                            throw new Error('This should never happen');\n                    }\n                }\n            });\n            stream.on('end', () => {\n                this.tryPush(null);\n            });\n            stream.on('close', async (errorCode) => {\n                let code;\n                let details = '';\n                switch (errorCode) {\n                    case http2.constants.NGHTTP2_REFUSED_STREAM:\n                        code = constants_1.Status.UNAVAILABLE;\n                        break;\n                    case http2.constants.NGHTTP2_CANCEL:\n                        code = constants_1.Status.CANCELLED;\n                        break;\n                    case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n                        code = constants_1.Status.RESOURCE_EXHAUSTED;\n                        details = 'Bandwidth exhausted';\n                        break;\n                    case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n                        code = constants_1.Status.PERMISSION_DENIED;\n                        details = 'Protocol not secure enough';\n                        break;\n                    default:\n                        code = constants_1.Status.INTERNAL;\n                }\n                // This guarantees that if trailers were received, the value of the\n                // 'grpc-status' header takes precedence for emitted status data.\n                await this.handlingTrailers;\n                // This is a no-op if trailers were received at all.\n                // This is OK, because status codes emitted here correspond to more\n                // catastrophic issues that prevent us from receiving trailers in the\n                // first place.\n                this.endCall({ code, details, metadata: new metadata_1.Metadata() });\n            });\n            stream.on('error', (err) => {\n                this.endCall({\n                    code: constants_1.Status.INTERNAL,\n                    details: 'Internal HTTP2 error',\n                    metadata: new metadata_1.Metadata()\n                });\n            });\n            if (!this.pendingRead) {\n                stream.pause();\n            }\n            if (this.pendingWrite) {\n                if (!this.pendingWriteCallback) {\n                    throw new Error('Invalid state in write handling code');\n                }\n                stream.write(this.pendingWrite, this.pendingWriteCallback);\n            }\n            if (this.pendingFinalCallback) {\n                stream.end(this.pendingFinalCallback);\n            }\n        }\n    }\n    sendMetadata(metadata) {\n        this.channel._startHttp2Stream(this.options.host, this.methodName, this, metadata);\n    }\n    destroyHttp2Stream() {\n        // The http2 stream could already have been destroyed if cancelWithStatus\n        // is called in response to an internal http2 error.\n        if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n            /* TODO(murgatroid99): Determine if we want to send different RST_STREAM\n             * codes based on the status code */\n            this.http2Stream.close(NGHTTP2_CANCEL);\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.destroyHttp2Stream();\n        (async () => {\n            // If trailers are currently being processed, the call should be ended\n            // by handleTrailers instead.\n            await this.handlingTrailers;\n            this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });\n        })();\n    }\n    getDeadline() {\n        return this.options.deadline;\n    }\n    getCredentials() {\n        return this.credentials;\n    }\n    setCredentials(credentials) {\n        this.credentials = credentials;\n    }\n    getStatus() {\n        return this.finalStatus;\n    }\n    getPeer() {\n        throw new Error('Not yet implemented');\n    }\n    getMethod() {\n        return this.methodName;\n    }\n    getHost() {\n        return this.options.host;\n    }\n    _read(size) {\n        /* If we have already emitted a status, we should not emit any more\n         * messages and we should communicate that the stream has ended */\n        if (this.finalStatus !== null) {\n            this.push(null);\n            return;\n        }\n        this.canPush = true;\n        if (this.http2Stream === null) {\n            this.pendingRead = true;\n        }\n        else {\n            while (this.unpushedReadMessages.length > 0) {\n                const nextMessage = this.unpushedReadMessages.shift();\n                this.canPush = this.push(nextMessage);\n                if (nextMessage === null || (!this.canPush)) {\n                    this.canPush = false;\n                    return;\n                }\n            }\n            /* Only resume reading from the http2Stream if we don't have any pending\n             * messages to emit, and we haven't gotten the signal to stop pushing\n             * messages */\n            this.http2Stream.resume();\n        }\n    }\n    _write(chunk, encoding, cb) {\n        this.filterStack.sendMessage(Promise.resolve(chunk)).then((message) => {\n            if (this.http2Stream === null) {\n                this.pendingWrite = message.message;\n                this.pendingWriteCallback = cb;\n            }\n            else {\n                this.http2Stream.write(message.message, cb);\n            }\n        }, this.handleFilterError.bind(this));\n    }\n    _final(cb) {\n        if (this.http2Stream === null) {\n            this.pendingFinalCallback = cb;\n        }\n        else {\n            this.http2Stream.end(cb);\n        }\n    }\n}\nexports.Http2CallStream = Http2CallStream;\n//# sourceMappingURL=call-stream.js.map"],"mappings":"AAAA,YAAY;;AAACA,OAAA;AACbC,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,MAAMC,KAAK,GAAGL,OAAO,CAAC,OAAO,CAAC;AAC9B,MAAMM,QAAQ,GAAGN,OAAO,CAAC,QAAQ,CAAC;AAClC,MAAMO,kBAAkB,GAAGP,OAAO,CAAC,oBAAoB,CAAC;AACxD,MAAMQ,WAAW,GAAGR,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAMS,UAAU,GAAGT,OAAO,CAAC,YAAY,CAAC;AACxC,MAAM;EAAEU,mBAAmB;EAAEC,yBAAyB;EAAEC;AAAe,CAAC,GAAGP,KAAK,CAACQ,SAAS;AAC1F,IAAIC,SAAS;AACb,CAAC,UAAUA,SAAS,EAAE;EAClBA,SAAS,CAACA,SAAS,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EAC/CA,SAAS,CAACA,SAAS,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,GAAG,cAAc;EACzDA,SAAS,CAACA,SAAS,CAAC,iBAAiB,CAAC,GAAG,CAAC,CAAC,GAAG,iBAAiB;AACnE,CAAC,EAAEA,SAAS,KAAKA,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;AACjC,MAAMC,eAAe,SAAST,QAAQ,CAACU,MAAM,CAAC;EAC1CC,WAAWA,CAACC,UAAU,EAAEC,OAAO,EAAEC,OAAO,EAAEC,kBAAkB,EAAE;IAC1D,KAAK,CAAC;MAAEC,UAAU,EAAE;IAAK,CAAC,CAAC;IAC3B,IAAI,CAACJ,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACG,WAAW,GAAGhB,kBAAkB,CAACiB,eAAe,CAACC,WAAW,EAAE;IACnE,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB,IAAI,CAACC,YAAY,GAAG,IAAI;IACxB,IAAI,CAACC,oBAAoB,GAAG,IAAI;IAChC,IAAI,CAACC,oBAAoB,GAAG,IAAI;IAChC,IAAI,CAACC,SAAS,GAAGjB,SAAS,CAACkB,OAAO;IAClC,IAAI,CAACC,gBAAgB,GAAGC,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;IACvC,IAAI,CAACC,eAAe,GAAGF,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;IACtC,IAAI,CAACE,iBAAiB,GAAG,CAAC;IAC1B,IAAI,CAACC,eAAe,GAAG,CAAC;IACxB,IAAI,CAACC,kBAAkB,GAAG,EAAE;IAC5B,IAAI,CAACC,oBAAoB,GAAG,CAAC;IAC7B,IAAI,CAACC,mBAAmB,GAAG,KAAK;IAChC,IAAI,CAACC,OAAO,GAAG,KAAK;IACpB,IAAI,CAACC,oBAAoB,GAAG,EAAE;IAC9B,IAAI,CAACC,sBAAsB,GAAG,EAAE;IAChC;IACA,IAAI,CAACC,gBAAgB,GAAGrC,WAAW,CAACsC,MAAM,CAACC,OAAO;IAClD;IACA;IACA;IACA;IACA,IAAI,CAACC,eAAe,GAAGC,OAAO,CAACC,OAAO,EAAE;IACxC,IAAI,CAACC,gBAAgB,GAAGF,OAAO,CAACC,OAAO,EAAE;IACzC;IACA,IAAI,CAACE,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,WAAW,GAAGhC,kBAAkB,CAACiC,YAAY,CAAC,IAAI,CAAC;EAC5D;EACA;AACJ;AACA;AACA;AACA;EACIC,OAAOA,CAACC,MAAM,EAAE;IACZ,IAAI,IAAI,CAACJ,WAAW,KAAK,IAAI,EAAE;MAC3B,IAAI,CAACA,WAAW,GAAGI,MAAM;MACzB,IAAI,CAACC,IAAI,CAAC,QAAQ,EAAED,MAAM,CAAC;IAC/B;EACJ;EACAE,iBAAiBA,CAACC,KAAK,EAAE;IACrB,IAAI,CAACC,gBAAgB,CAACpD,WAAW,CAACsC,MAAM,CAACe,QAAQ,EAAEF,KAAK,CAACG,OAAO,CAAC;EACrE;EACAC,kBAAkBA,CAACD,OAAO,EAAE;IACxB;AACR;IACQ,IAAI,IAAI,CAACV,WAAW,KAAK,IAAI,EAAE;MAC3B;IACJ;IACA,IAAI,CAACX,mBAAmB,GAAG,KAAK;IAChC,IAAI,IAAI,CAACC,OAAO,EAAE;MACd,IAAI,CAAC,IAAI,CAACsB,IAAI,CAACF,OAAO,CAAC,EAAE;QACrB,IAAI,CAACpB,OAAO,GAAG,KAAK;QACpB,IAAI,CAAChB,WAAW,CAACuC,KAAK,EAAE;MAC5B;IACJ,CAAC,MACI;MACD,IAAI,CAACtB,oBAAoB,CAACqB,IAAI,CAACF,OAAO,CAAC;IAC3C;IACA,IAAI,IAAI,CAAClB,sBAAsB,CAACsB,MAAM,GAAG,CAAC,EAAE;MACxC;AACZ;MACY,MAAMC,WAAW,GAAG,IAAI,CAACvB,sBAAsB,CAACwB,KAAK,EAAE;MACvD,IAAI,CAACC,qBAAqB,CAACF,WAAW,CAAC;IAC3C;EACJ;EACAE,qBAAqBA,CAACC,aAAa,EAAE;IACjC;AACR;IACQ,IAAI,IAAI,CAAClB,WAAW,KAAK,IAAI,EAAE;MAC3B;IACJ;IACA,IAAIkB,aAAa,KAAK,IAAI,EAAE;MACxB,IAAI,IAAI,CAAC5B,OAAO,EAAE;QACd,IAAI,CAACsB,IAAI,CAAC,IAAI,CAAC;MACnB,CAAC,MACI;QACD,IAAI,CAACrB,oBAAoB,CAACqB,IAAI,CAAC,IAAI,CAAC;MACxC;MACA;IACJ;IACA,IAAI,CAACvB,mBAAmB,GAAG,IAAI;IAC/B,IAAI,CAACY,WAAW,CAACkB,cAAc,CAACtB,OAAO,CAACC,OAAO,CAACoB,aAAa,CAAC,CAAC,CAC1DE,IAAI,CAAC,IAAI,CAACT,kBAAkB,CAACU,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAACf,iBAAiB,CAACe,IAAI,CAAC,IAAI,CAAC,CAAC;EACpF;EACAC,OAAOA,CAACC,YAAY,EAAE;IAClB,IAAI,IAAI,CAAClC,mBAAmB,EAAE;MAC1B,IAAI,CAACG,sBAAsB,CAACoB,IAAI,CAACW,YAAY,CAAC;IAClD,CAAC,MACI;MACD,IAAI,CAACN,qBAAqB,CAACM,YAAY,CAAC;IAC5C;EACJ;EACAC,cAAcA,CAACC,OAAO,EAAE;IACpB,MAAMC,IAAI,GAAG,IAAI,CAACjC,gBAAgB;IAClC,MAAMkC,OAAO,GAAG,EAAE;IAClB,IAAIC,QAAQ;IACZ,IAAI;MACAA,QAAQ,GAAGvE,UAAU,CAACwE,QAAQ,CAACC,gBAAgB,CAACL,OAAO,CAAC;IAC5D,CAAC,CACD,OAAOM,CAAC,EAAE;MACNH,QAAQ,GAAG,IAAIvE,UAAU,CAACwE,QAAQ,EAAE;IACxC;IACA,MAAMzB,MAAM,GAAG;MAAEsB,IAAI;MAAEC,OAAO;MAAEC;IAAS,CAAC;IAC1C,IAAI,CAAC7B,gBAAgB,GAAG,CAAC,YAAY;MACjC,IAAIC,WAAW;MACf,IAAI;QACA;QACAA,WAAW,GACP,MAAM,IAAI,CAACC,WAAW,CAAC+B,eAAe,CAACnC,OAAO,CAACC,OAAO,CAACM,MAAM,CAAC,CAAC;MACvE,CAAC,CACD,OAAOG,KAAK,EAAE;QACV,MAAM,IAAI,CAACX,eAAe;QAC1B;QACA,IAAI,CAACO,OAAO,CAAC;UACTuB,IAAI,EAAEtE,WAAW,CAACsC,MAAM,CAACe,QAAQ;UACjCkB,OAAO,EAAE,mCAAmC;UAC5CC,QAAQ,EAAE,IAAIvE,UAAU,CAACwE,QAAQ;QACrC,CAAC,CAAC;QACF;MACJ;MACA;MACA;MACA;MACA,MAAM,IAAI,CAACjC,eAAe;MAC1B;MACA,IAAI,CAACO,OAAO,CAACH,WAAW,CAAC;IAC7B,CAAC,GAAG;EACR;EACAiC,iBAAiBA,CAACC,MAAM,EAAE;IACtB,IAAI,IAAI,CAAClC,WAAW,KAAK,IAAI,EAAE;MAC3BkC,MAAM,CAACC,KAAK,CAAC3E,cAAc,CAAC;IAChC,CAAC,MACI;MACD,IAAI,CAACc,WAAW,GAAG4D,MAAM;MACzBA,MAAM,CAACE,EAAE,CAAC,UAAU,EAAE,CAACX,OAAO,EAAEY,KAAK,KAAK;QACtC,QAAQZ,OAAO,CAACnE,mBAAmB,CAAC;UAChC;UACA,KAAK,KAAK;YACN,IAAI,CAACmC,gBAAgB,GAAGrC,WAAW,CAACsC,MAAM,CAACe,QAAQ;YACnD;UACJ,KAAK,KAAK;YACN,IAAI,CAAChB,gBAAgB,GAAGrC,WAAW,CAACsC,MAAM,CAAC4C,eAAe;YAC1D;UACJ,KAAK,KAAK;YACN,IAAI,CAAC7C,gBAAgB,GAAGrC,WAAW,CAACsC,MAAM,CAAC6C,iBAAiB;YAC5D;UACJ,KAAK,KAAK;YACN,IAAI,CAAC9C,gBAAgB,GAAGrC,WAAW,CAACsC,MAAM,CAAC8C,aAAa;YACxD;UACJ,KAAK,KAAK;UACV,KAAK,KAAK;UACV,KAAK,KAAK;UACV,KAAK,KAAK;YACN,IAAI,CAAC/C,gBAAgB,GAAGrC,WAAW,CAACsC,MAAM,CAAC+C,WAAW;YACtD;UACJ;YACI,IAAI,CAAChD,gBAAgB,GAAGrC,WAAW,CAACsC,MAAM,CAACC,OAAO;QAAC;QAE3D,IAAI0C,KAAK,GAAGpF,KAAK,CAACQ,SAAS,CAACiF,uBAAuB,EAAE;UACjD,IAAI,CAAClB,cAAc,CAACC,OAAO,CAAC;QAChC,CAAC,MACI;UACD,IAAIG,QAAQ;UACZ,IAAI;YACAA,QAAQ,GAAGvE,UAAU,CAACwE,QAAQ,CAACC,gBAAgB,CAACL,OAAO,CAAC;UAC5D,CAAC,CACD,OAAOlB,KAAK,EAAE;YACV,IAAI,CAACJ,OAAO,CAAC;cACTuB,IAAI,EAAEtE,WAAW,CAACsC,MAAM,CAACC,OAAO;cAChCgC,OAAO,EAAEpB,KAAK,CAACG,OAAO;cACtBkB,QAAQ,EAAE,IAAIvE,UAAU,CAACwE,QAAQ;YACrC,CAAC,CAAC;YACF;UACJ;UACA,IAAI,CAACjC,eAAe,GAChB,IAAI,CAACK,WAAW,CAAC0C,eAAe,CAAC9C,OAAO,CAACC,OAAO,CAAC8B,QAAQ,CAAC,CAAC,CACtDR,IAAI,CAAEwB,aAAa,IAAK;YACzB,IAAI,CAACvC,IAAI,CAAC,UAAU,EAAEuC,aAAa,CAAC;UACxC,CAAC,CAAC,CACGC,KAAK,CAAEtC,KAAK,IAAK;YAClB,IAAI,CAACuC,kBAAkB,EAAE;YACzB,IAAI,CAAC3C,OAAO,CAAC;cACTuB,IAAI,EAAEtE,WAAW,CAACsC,MAAM,CAACC,OAAO;cAChCgC,OAAO,EAAEpB,KAAK,CAACG,OAAO;cACtBkB,QAAQ,EAAE,IAAIvE,UAAU,CAACwE,QAAQ;YACrC,CAAC,CAAC;UACN,CAAC,CAAC;QACV;MACJ,CAAC,CAAC;MACFK,MAAM,CAACE,EAAE,CAAC,UAAU,EAAE,IAAI,CAACZ,cAAc,CAACH,IAAI,CAAC,IAAI,CAAC,CAAC;MACrDa,MAAM,CAACE,EAAE,CAAC,MAAM,EAAGW,IAAI,IAAK;QACxB,IAAIC,QAAQ,GAAG,CAAC;QAChB,IAAIC,MAAM;QACV,OAAOD,QAAQ,GAAGD,IAAI,CAACjC,MAAM,EAAE;UAC3B,QAAQ,IAAI,CAACnC,SAAS;YAClB,KAAKjB,SAAS,CAACkB,OAAO;cAClB,IAAI,CAACC,gBAAgB,GAAGkE,IAAI,CAACG,KAAK,CAACF,QAAQ,EAAEA,QAAQ,GAAG,CAAC,CAAC;cAC1DA,QAAQ,IAAI,CAAC;cACb,IAAI,CAACrE,SAAS,GAAGjB,SAAS,CAACyF,YAAY;cACvC,IAAI,CAACnE,eAAe,CAACoE,IAAI,CAAC,CAAC,CAAC;cAC5B,IAAI,CAACnE,iBAAiB,GAAG,CAAC;cAC1B,IAAI,CAACC,eAAe,GAAG,CAAC;cACxB,IAAI,CAACE,oBAAoB,GAAG,CAAC;cAC7B,IAAI,CAACD,kBAAkB,GAAG,EAAE;cAC5B;YACJ,KAAKzB,SAAS,CAACyF,YAAY;cACvBF,MAAM,GAAGI,IAAI,CAACC,GAAG,CAACP,IAAI,CAACjC,MAAM,GAAGkC,QAAQ,EAAE,IAAI,CAAC/D,iBAAiB,CAAC;cACjE8D,IAAI,CAACQ,IAAI,CAAC,IAAI,CAACvE,eAAe,EAAE,CAAC,GAAG,IAAI,CAACC,iBAAiB,EAAE+D,QAAQ,EAAEA,QAAQ,GAAGC,MAAM,CAAC;cACxF,IAAI,CAAChE,iBAAiB,IAAIgE,MAAM;cAChCD,QAAQ,IAAIC,MAAM;cAClB;cACA,IAAI,IAAI,CAAChE,iBAAiB,KAAK,CAAC,EAAE;gBAC9B,IAAI,CAACC,eAAe,GAAG,IAAI,CAACF,eAAe,CAACwE,YAAY,CAAC,CAAC,CAAC;gBAC3D,IAAI,CAACpE,oBAAoB,GAAG,IAAI,CAACF,eAAe;gBAChD,IAAI,IAAI,CAACE,oBAAoB,GAAG,CAAC,EAAE;kBAC/B,IAAI,CAACT,SAAS,GAAGjB,SAAS,CAAC+F,eAAe;gBAC9C,CAAC,MACI;kBACD,IAAI,CAACnC,OAAO,CAACxC,MAAM,CAAC4E,MAAM,CAAC,CAAC,IAAI,CAAC7E,gBAAgB,EAAE,IAAI,CAACG,eAAe,CAAC,CAAC,CAAC;kBAC1E,IAAI,CAACL,SAAS,GAAGjB,SAAS,CAACkB,OAAO;gBACtC;cACJ;cACA;YACJ,KAAKlB,SAAS,CAAC+F,eAAe;cAC1BR,MAAM,GACFI,IAAI,CAACC,GAAG,CAACP,IAAI,CAACjC,MAAM,GAAGkC,QAAQ,EAAE,IAAI,CAAC5D,oBAAoB,CAAC;cAC/D,IAAI,CAACD,kBAAkB,CAACyB,IAAI,CAACmC,IAAI,CAACG,KAAK,CAACF,QAAQ,EAAEA,QAAQ,GAAGC,MAAM,CAAC,CAAC;cACrE,IAAI,CAAC7D,oBAAoB,IAAI6D,MAAM;cACnCD,QAAQ,IAAIC,MAAM;cAClB;cACA,IAAI,IAAI,CAAC7D,oBAAoB,KAAK,CAAC,EAAE;gBACjC;gBACA,MAAMuE,oBAAoB,GAAG,CACzB,IAAI,CAAC9E,gBAAgB,EAAE,IAAI,CAACG,eAAe,CAC9C,CAAC0E,MAAM,CAAC,IAAI,CAACvE,kBAAkB,CAAC;gBACjC,MAAM+B,aAAa,GAAGpC,MAAM,CAAC4E,MAAM,CAACC,oBAAoB,EAAE,IAAI,CAACzE,eAAe,GAAG,CAAC,CAAC;gBACnF,IAAI,CAACoC,OAAO,CAACJ,aAAa,CAAC;gBAC3B,IAAI,CAACvC,SAAS,GAAGjB,SAAS,CAACkB,OAAO;cACtC;cACA;YACJ;cACI,MAAM,IAAIgF,KAAK,CAAC,0BAA0B,CAAC;UAAC;QAExD;MACJ,CAAC,CAAC;MACF1B,MAAM,CAACE,EAAE,CAAC,KAAK,EAAE,MAAM;QACnB,IAAI,CAACd,OAAO,CAAC,IAAI,CAAC;MACtB,CAAC,CAAC;MACFY,MAAM,CAACE,EAAE,CAAC,OAAO,EAAE,MAAOyB,SAAS,IAAK;QACpC,IAAInC,IAAI;QACR,IAAIC,OAAO,GAAG,EAAE;QAChB,QAAQkC,SAAS;UACb,KAAK5G,KAAK,CAACQ,SAAS,CAACqG,sBAAsB;YACvCpC,IAAI,GAAGtE,WAAW,CAACsC,MAAM,CAAC+C,WAAW;YACrC;UACJ,KAAKxF,KAAK,CAACQ,SAAS,CAACD,cAAc;YAC/BkE,IAAI,GAAGtE,WAAW,CAACsC,MAAM,CAACqE,SAAS;YACnC;UACJ,KAAK9G,KAAK,CAACQ,SAAS,CAACuG,yBAAyB;YAC1CtC,IAAI,GAAGtE,WAAW,CAACsC,MAAM,CAACuE,kBAAkB;YAC5CtC,OAAO,GAAG,qBAAqB;YAC/B;UACJ,KAAK1E,KAAK,CAACQ,SAAS,CAACyG,2BAA2B;YAC5CxC,IAAI,GAAGtE,WAAW,CAACsC,MAAM,CAAC6C,iBAAiB;YAC3CZ,OAAO,GAAG,4BAA4B;YACtC;UACJ;YACID,IAAI,GAAGtE,WAAW,CAACsC,MAAM,CAACe,QAAQ;QAAC;QAE3C;QACA;QACA,MAAM,IAAI,CAACV,gBAAgB;QAC3B;QACA;QACA;QACA;QACA,IAAI,CAACI,OAAO,CAAC;UAAEuB,IAAI;UAAEC,OAAO;UAAEC,QAAQ,EAAE,IAAIvE,UAAU,CAACwE,QAAQ;QAAG,CAAC,CAAC;MACxE,CAAC,CAAC;MACFK,MAAM,CAACE,EAAE,CAAC,OAAO,EAAG+B,GAAG,IAAK;QACxB,IAAI,CAAChE,OAAO,CAAC;UACTuB,IAAI,EAAEtE,WAAW,CAACsC,MAAM,CAACe,QAAQ;UACjCkB,OAAO,EAAE,sBAAsB;UAC/BC,QAAQ,EAAE,IAAIvE,UAAU,CAACwE,QAAQ;QACrC,CAAC,CAAC;MACN,CAAC,CAAC;MACF,IAAI,CAAC,IAAI,CAACtD,WAAW,EAAE;QACnB2D,MAAM,CAACrB,KAAK,EAAE;MAClB;MACA,IAAI,IAAI,CAACrC,YAAY,EAAE;QACnB,IAAI,CAAC,IAAI,CAACC,oBAAoB,EAAE;UAC5B,MAAM,IAAImF,KAAK,CAAC,sCAAsC,CAAC;QAC3D;QACA1B,MAAM,CAACkC,KAAK,CAAC,IAAI,CAAC5F,YAAY,EAAE,IAAI,CAACC,oBAAoB,CAAC;MAC9D;MACA,IAAI,IAAI,CAACC,oBAAoB,EAAE;QAC3BwD,MAAM,CAACmC,GAAG,CAAC,IAAI,CAAC3F,oBAAoB,CAAC;MACzC;IACJ;EACJ;EACA4F,YAAYA,CAAC1C,QAAQ,EAAE;IACnB,IAAI,CAAC7D,OAAO,CAACwG,iBAAiB,CAAC,IAAI,CAACvG,OAAO,CAACwG,IAAI,EAAE,IAAI,CAAC1G,UAAU,EAAE,IAAI,EAAE8D,QAAQ,CAAC;EACtF;EACAkB,kBAAkBA,CAAA,EAAG;IACjB;IACA;IACA,IAAI,IAAI,CAACxE,WAAW,KAAK,IAAI,IAAI,CAAC,IAAI,CAACA,WAAW,CAACmG,SAAS,EAAE;MAC1D;AACZ;MACY,IAAI,CAACnG,WAAW,CAAC6D,KAAK,CAAC3E,cAAc,CAAC;IAC1C;EACJ;EACAgD,gBAAgBA,CAACJ,MAAM,EAAEuB,OAAO,EAAE;IAC9B,IAAI,CAACmB,kBAAkB,EAAE;IACzB,CAAC,YAAY;MACT;MACA;MACA,MAAM,IAAI,CAAC/C,gBAAgB;MAC3B,IAAI,CAACI,OAAO,CAAC;QAAEuB,IAAI,EAAEtB,MAAM;QAAEuB,OAAO;QAAEC,QAAQ,EAAE,IAAIvE,UAAU,CAACwE,QAAQ;MAAG,CAAC,CAAC;IAChF,CAAC,GAAG;EACR;EACA6C,WAAWA,CAAA,EAAG;IACV,OAAO,IAAI,CAAC1G,OAAO,CAAC2G,QAAQ;EAChC;EACAC,cAAcA,CAAA,EAAG;IACb,OAAO,IAAI,CAACzG,WAAW;EAC3B;EACA0G,cAAcA,CAAC1G,WAAW,EAAE;IACxB,IAAI,CAACA,WAAW,GAAGA,WAAW;EAClC;EACA2G,SAASA,CAAA,EAAG;IACR,OAAO,IAAI,CAAC9E,WAAW;EAC3B;EACA+E,OAAOA,CAAA,EAAG;IACN,MAAM,IAAInB,KAAK,CAAC,qBAAqB,CAAC;EAC1C;EACAoB,SAASA,CAAA,EAAG;IACR,OAAO,IAAI,CAAClH,UAAU;EAC1B;EACAmH,OAAOA,CAAA,EAAG;IACN,OAAO,IAAI,CAACjH,OAAO,CAACwG,IAAI;EAC5B;EACAU,KAAKA,CAACC,IAAI,EAAE;IACR;AACR;IACQ,IAAI,IAAI,CAACnF,WAAW,KAAK,IAAI,EAAE;MAC3B,IAAI,CAACY,IAAI,CAAC,IAAI,CAAC;MACf;IACJ;IACA,IAAI,CAACtB,OAAO,GAAG,IAAI;IACnB,IAAI,IAAI,CAAChB,WAAW,KAAK,IAAI,EAAE;MAC3B,IAAI,CAACC,WAAW,GAAG,IAAI;IAC3B,CAAC,MACI;MACD,OAAO,IAAI,CAACgB,oBAAoB,CAACuB,MAAM,GAAG,CAAC,EAAE;QACzC,MAAMC,WAAW,GAAG,IAAI,CAACxB,oBAAoB,CAACyB,KAAK,EAAE;QACrD,IAAI,CAAC1B,OAAO,GAAG,IAAI,CAACsB,IAAI,CAACG,WAAW,CAAC;QACrC,IAAIA,WAAW,KAAK,IAAI,IAAK,CAAC,IAAI,CAACzB,OAAQ,EAAE;UACzC,IAAI,CAACA,OAAO,GAAG,KAAK;UACpB;QACJ;MACJ;MACA;AACZ;AACA;MACY,IAAI,CAAChB,WAAW,CAAC8G,MAAM,EAAE;IAC7B;EACJ;EACAC,MAAMA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,EAAE,EAAE;IACxB,IAAI,CAACvF,WAAW,CAACwF,WAAW,CAAC5F,OAAO,CAACC,OAAO,CAACwF,KAAK,CAAC,CAAC,CAAClE,IAAI,CAAEV,OAAO,IAAK;MACnE,IAAI,IAAI,CAACpC,WAAW,KAAK,IAAI,EAAE;QAC3B,IAAI,CAACE,YAAY,GAAGkC,OAAO,CAACA,OAAO;QACnC,IAAI,CAACjC,oBAAoB,GAAG+G,EAAE;MAClC,CAAC,MACI;QACD,IAAI,CAAClH,WAAW,CAAC8F,KAAK,CAAC1D,OAAO,CAACA,OAAO,EAAE8E,EAAE,CAAC;MAC/C;IACJ,CAAC,EAAE,IAAI,CAAClF,iBAAiB,CAACe,IAAI,CAAC,IAAI,CAAC,CAAC;EACzC;EACAqE,MAAMA,CAACF,EAAE,EAAE;IACP,IAAI,IAAI,CAAClH,WAAW,KAAK,IAAI,EAAE;MAC3B,IAAI,CAACI,oBAAoB,GAAG8G,EAAE;IAClC,CAAC,MACI;MACD,IAAI,CAAClH,WAAW,CAAC+F,GAAG,CAACmB,EAAE,CAAC;IAC5B;EACJ;AACJ;AACAzI,OAAO,CAACY,eAAe,GAAGA,eAAe"},"metadata":{},"sourceType":"script","externalDependencies":[]}