{"ast":null,"code":"/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * Client Interceptors\n *\n * This module describes the interceptor framework for clients.\n * An interceptor is a function which takes an options object and a nextCall\n * function and returns an InterceptingCall:\n *\n * ```\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options));\n * }\n * ```\n *\n * The interceptor function must return an InterceptingCall object. Returning\n * `new InterceptingCall(nextCall(options))` will satisfy the contract (but\n * provide no interceptor functionality). `nextCall` is a function which will\n * generate the next interceptor in the chain.\n *\n * To implement interceptor functionality, create a requester and pass it to\n * the InterceptingCall constructor:\n *\n * `return new InterceptingCall(nextCall(options), requester);`\n *\n * A requester is a POJO with zero or more of the following methods:\n *\n * `start(metadata, listener, next)`\n * * To continue, call next(metadata, listener). Listeners are described\n * * below.\n *\n * `sendMessage(message, next)`\n * * To continue, call next(message).\n *\n * `halfClose(next)`\n * * To continue, call next().\n *\n * `cancel(message, next)`\n * * To continue, call next().\n *\n * A listener is a POJO with one or more of the following methods:\n *\n * `onReceiveMetadata(metadata, next)`\n * * To continue, call next(metadata)\n *\n * `onReceiveMessage(message, next)`\n * * To continue, call next(message)\n *\n * `onReceiveStatus(status, next)`\n * * To continue, call next(status)\n *\n * A listener is provided by the requester's `start` method. The provided\n * listener implements all the inbound interceptor methods, which can be called\n * to short-circuit the gRPC call.\n *\n * Three usage patterns are supported for listeners:\n * 1) Pass the listener along without modification: `next(metadata, listener)`.\n *   In this case the interceptor declines to intercept any inbound operations.\n * 2) Create a new listener with one or more inbound interceptor methods and\n *   pass it to `next`. In this case the interceptor will fire on the inbound\n *   operations implemented in the new listener.\n * 3) Make direct inbound calls to the provided listener's methods. This\n *   short-circuits the interceptor stack.\n *\n * Do not modify the listener passed in. Either pass it along unmodified,\n * ignore it, or call methods on it to short-circuit the call.\n *\n * To intercept errors, implement the `onReceiveStatus` method and test for\n * `status.code !== grpc.status.OK`.\n *\n * To intercept trailers, examine `status.metadata` in the `onReceiveStatus`\n * method.\n *\n * This is a trivial implementation of all interceptor methods:\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options), {\n *     start: function(metadata, listener, next) {\n *       next(metadata, {\n *         onReceiveMetadata: function (metadata, next) {\n *           next(metadata);\n *         },\n *         onReceiveMessage: function (message, next) {\n *           next(message);\n *         },\n *         onReceiveStatus: function (status, next) {\n *           next(status);\n *         },\n *       });\n *     },\n *     sendMessage: function(message, next) {\n *       next(message);\n *     },\n *     halfClose: function(next) {\n *       next();\n *     },\n *     cancel: function(message, next) {\n *       next();\n *     }\n *   });\n * };\n *\n * This is an interceptor with a single method:\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options), {\n *     sendMessage: function(message, next) {\n *       next(message);\n *     }\n *   });\n * };\n *\n * Builders are provided for convenience: StatusBuilder, ListenerBuilder,\n * and RequesterBuilder\n *\n * gRPC client operations use this mapping to interceptor methods:\n *\n * grpc.opType.SEND_INITIAL_METADATA -> start\n * grpc.opType.SEND_MESSAGE -> sendMessage\n * grpc.opType.SEND_CLOSE_FROM_CLIENT -> halfClose\n * grpc.opType.RECV_INITIAL_METADATA -> onReceiveMetadata\n * grpc.opType.RECV_MESSAGE -> onReceiveMessage\n * grpc.opType.RECV_STATUS_ON_CLIENT -> onReceiveStatus\n *\n * @module\n */\n\n'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.regexp.flags.js\");\nvar grpc = require('./grpc_extension');\nvar Metadata = require('./metadata');\nvar constants = require('./constants');\nvar common = require('./common');\nvar methodTypes = constants.methodTypes;\nvar EventEmitter = require('events').EventEmitter;\n\n/**\n * A custom error thrown when interceptor configuration fails.\n * @param {string} message The error message\n * @param {object=} extra\n * @constructor\n */\nvar InterceptorConfigurationError = function InterceptorConfigurationError(message, extra) {\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = message;\n  this.extra = extra;\n};\nrequire('util').inherits(InterceptorConfigurationError, Error);\n\n/**\n * A builder for gRPC status objects.\n * @constructor\n */\nfunction StatusBuilder() {\n  this.code = null;\n  this.details = null;\n  this.metadata = null;\n}\n\n/**\n * Adds a status code to the builder.\n * @param {number} code The status code.\n * @return {StatusBuilder}\n */\nStatusBuilder.prototype.withCode = function (code) {\n  this.code = code;\n  return this;\n};\n\n/**\n * Adds details to the builder.\n * @param {string} details A status message.\n * @return {StatusBuilder}\n */\nStatusBuilder.prototype.withDetails = function (details) {\n  this.details = details;\n  return this;\n};\n\n/**\n * Adds metadata to the builder.\n * @param {Metadata} metadata The gRPC status metadata.\n * @return {StatusBuilder}\n */\nStatusBuilder.prototype.withMetadata = function (metadata) {\n  this.metadata = metadata;\n  return this;\n};\n\n/**\n * Builds the status object.\n * @return {grpc~StatusObject} A gRPC status.\n */\nStatusBuilder.prototype.build = function () {\n  var status = {};\n  if (this.code !== undefined) {\n    status.code = this.code;\n  }\n  if (this.details) {\n    status.details = this.details;\n  }\n  if (this.metadata) {\n    status.metadata = this.metadata;\n  }\n  return status;\n};\n\n/**\n * A builder for listener interceptors.\n * @constructor\n */\nfunction ListenerBuilder() {\n  this.metadata = null;\n  this.message = null;\n  this.status = null;\n}\n\n/**\n * Adds an onReceiveMetadata method to the builder.\n * @param {MetadataListener} on_receive_metadata A listener method for\n * receiving metadata.\n * @return {ListenerBuilder}\n */\nListenerBuilder.prototype.withOnReceiveMetadata = function (on_receive_metadata) {\n  this.metadata = on_receive_metadata;\n  return this;\n};\n\n/**\n * Adds an onReceiveMessage method to the builder.\n * @param {MessageListener} on_receive_message A listener method for receiving\n * messages.\n * @return {ListenerBuilder}\n */\nListenerBuilder.prototype.withOnReceiveMessage = function (on_receive_message) {\n  this.message = on_receive_message;\n  return this;\n};\n\n/**\n * Adds an onReceiveStatus method to the builder.\n * @param {StatusListener} on_receive_status A listener method for receiving\n * status.\n * @return {ListenerBuilder}\n */\nListenerBuilder.prototype.withOnReceiveStatus = function (on_receive_status) {\n  this.status = on_receive_status;\n  return this;\n};\n\n/**\n * Builds the call listener.\n * @return {grpc~Listener}\n */\nListenerBuilder.prototype.build = function () {\n  var self = this;\n  var listener = {};\n  listener.onReceiveMetadata = self.metadata;\n  listener.onReceiveMessage = self.message;\n  listener.onReceiveStatus = self.status;\n  return listener;\n};\n\n/**\n * A builder for the outbound methods of an interceptor.\n * @constructor\n */\nfunction RequesterBuilder() {\n  this.start = null;\n  this.message = null;\n  this.half_close = null;\n  this.cancel = null;\n}\n\n/**\n * Add a metadata requester to the builder.\n * @param {MetadataRequester} start A requester method for handling metadata.\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withStart = function (start) {\n  this.start = start;\n  return this;\n};\n\n/**\n * Add a message requester to the builder.\n * @param {MessageRequester} send_message A requester method for handling\n * messages.\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withSendMessage = function (send_message) {\n  this.message = send_message;\n  return this;\n};\n\n/**\n * Add a close requester to the builder.\n * @param {CloseRequester} half_close A requester method for handling client\n * close.\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withHalfClose = function (half_close) {\n  this.half_close = half_close;\n  return this;\n};\n\n/**\n * Add a cancel requester to the builder.\n * @param {CancelRequester} cancel A requester method for handling `cancel`\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withCancel = function (cancel) {\n  this.cancel = cancel;\n  return this;\n};\n\n/**\n * Builds the requester's interceptor methods.\n * @return {grpc~Requester}\n */\nRequesterBuilder.prototype.build = function () {\n  var requester = {};\n  requester.start = this.start;\n  requester.sendMessage = this.message;\n  requester.halfClose = this.half_close;\n  requester.cancel = this.cancel;\n  return requester;\n};\n\n/**\n * Transforms a list of interceptor providers into interceptors.\n * @param {InterceptorProvider[]} providers\n * @param {grpc~MethodDefinition} method_definition\n * @return {null|Interceptor[]}\n */\nvar resolveInterceptorProviders = function (providers, method_definition) {\n  if (!Array.isArray(providers)) {\n    return null;\n  }\n  var interceptors = [];\n  for (var i = 0; i < providers.length; i++) {\n    var provider = providers[i];\n    var interceptor = provider(method_definition);\n    if (interceptor) {\n      interceptors.push(interceptor);\n    }\n  }\n  return interceptors;\n};\n\n/**\n * A chainable gRPC call proxy which will delegate to an optional requester\n * object. By default, interceptor methods will chain to next_call. If a\n * requester is provided which implements an interceptor method, that\n * requester method will be executed as part of the chain.\n * @param {InterceptingCall|null} next_call The next call in the chain\n * @param {grpc~Requester=} requester Interceptor methods to handle request\n * operations.\n * @constructor\n */\nfunction InterceptingCall(next_call, requester) {\n  this.next_call = next_call;\n  this.requester = requester;\n}\nconst emptyNext = function () {};\n\n/**\n * Get the next method in the chain or a no-op function if we are at the end\n * of the chain\n * @param {string} method_name\n * @return {function} The next method in the chain\n * @private\n */\nInterceptingCall.prototype._getNextCall = function (method_name) {\n  return this.next_call ? this.next_call[method_name].bind(this.next_call) : emptyNext;\n};\n\n/**\n * Call the next method in the chain. This will either be on the next\n * InterceptingCall (next_call), or the requester if the requester\n * implements the method.\n * @param {string} method_name The name of the interceptor method\n * @param {array=} args Payload arguments for the operation\n * @param {function=} next The next InterceptingCall's method\n * @return {null}\n * @private\n */\nInterceptingCall.prototype._callNext = function (method_name, args, next) {\n  var args_array = args || [];\n  var next_call = next ? next : this._getNextCall(method_name);\n  if (this.requester && this.requester[method_name]) {\n    // Avoid using expensive `apply` calls\n    var num_args = args_array.length;\n    switch (num_args) {\n      case 0:\n        return this.requester[method_name](next_call);\n      case 1:\n        return this.requester[method_name](args_array[0], next_call);\n      case 2:\n        return this.requester[method_name](args_array[0], args_array[1], next_call);\n    }\n  } else {\n    if (next_call === emptyNext) {\n      throw new Error('Interceptor call chain terminated unexpectedly');\n    }\n    return next_call(args_array[0], args_array[1]);\n  }\n};\n\n/**\n * Starts a call through the outbound interceptor chain and adds an element to\n * the reciprocal inbound listener chain.\n * @param {grpc.Metadata} metadata The outgoing metadata.\n * @param {grpc~Listener} listener An intercepting listener for inbound\n * operations.\n */\nInterceptingCall.prototype.start = function (metadata, listener) {\n  var self = this;\n\n  // If the listener provided is an InterceptingListener, use it. Otherwise, we\n  // must be at the end of the listener chain, and any listener operations\n  // should be terminated in an EndListener.\n  var next_listener = _getInterceptingListener(listener, new EndListener());\n\n  // Build the next method in the interceptor chain\n  var next = function (metadata, current_listener) {\n    // If there is a next call in the chain, run it. Otherwise do nothing.\n    if (self.next_call) {\n      // Wire together any listener provided with the next listener\n      var listener = _getInterceptingListener(current_listener, next_listener);\n      self.next_call.start(metadata, listener);\n    }\n  };\n  this._callNext('start', [metadata, next_listener], next);\n};\n\n/**\n * Pass a message through the interceptor chain.\n * @param {jspb.Message} message\n */\nInterceptingCall.prototype.sendMessage = function (message) {\n  this._callNext('sendMessage', [message]);\n};\n\n/**\n * Run a close operation through the interceptor chain\n */\nInterceptingCall.prototype.halfClose = function () {\n  this._callNext('halfClose');\n};\n\n/**\n * Run a cancel operation through the interceptor chain\n */\nInterceptingCall.prototype.cancel = function () {\n  this._callNext('cancel');\n};\n\n/**\n * Run a cancelWithStatus operation through the interceptor chain.\n * @param {number} code\n * @param {string} details\n */\nInterceptingCall.prototype.cancelWithStatus = function (code, details) {\n  this._callNext('cancelWithStatus', [code, details]);\n};\n\n/**\n * Pass a getPeer call down to the base gRPC call (should not be intercepted)\n * @return {object}\n */\nInterceptingCall.prototype.getPeer = function () {\n  return this._callNext('getPeer');\n};\n\n/**\n * For streaming calls, we need to transparently pass the stream's context\n * through the interceptor chain. Passes the context between InterceptingCalls\n * but hides it from any requester implementations.\n * @param {object} context Carries objects needed for streaming operations.\n * @param {jspb.Message} message The message to send.\n */\nInterceptingCall.prototype.sendMessageWithContext = function (context, message) {\n  var next = this.next_call ? this.next_call.sendMessageWithContext.bind(this.next_call, context) : context;\n  this._callNext('sendMessage', [message], next);\n};\n\n/**\n * For receiving streaming messages, we need to seed the base interceptor with\n * the streaming context to create a RECV_MESSAGE batch.\n * @param {object} context Carries objects needed for streaming operations\n */\nInterceptingCall.prototype.recvMessageWithContext = function (context) {\n  this._callNext('recvMessageWithContext', [context]);\n};\n\n/**\n * A chain-able listener object which will delegate to a custom listener when\n * appropriate.\n * @param {InterceptingListener|null} next_listener The next\n * InterceptingListener in the chain\n * @param {grpc~Listener=} delegate A custom listener object which may implement\n * specific operations\n * @constructor\n */\nfunction InterceptingListener(next_listener, delegate) {\n  this.delegate = delegate || {};\n  this.next_listener = next_listener;\n}\n\n/**\n * Get the next method in the chain or a no-op function if we are at the end\n * of the chain.\n * @param {string} method_name The name of the listener method.\n * @return {function} The next method in the chain\n * @private\n */\nInterceptingListener.prototype._getNextListener = function (method_name) {\n  return this.next_listener ? this.next_listener[method_name].bind(this.next_listener) : function () {};\n};\n\n/**\n * Call the next method in the chain. This will either be on the next\n * InterceptingListener (next_listener), or the requester if the requester\n * implements the method.\n * @param {string} method_name The name of the interceptor method\n * @param {array=} args Payload arguments for the operation\n * @param {function=} next The next InterceptingListener's method\n * @return {null}\n * @private\n */\nInterceptingListener.prototype._callNext = function (method_name, args, next) {\n  var args_array = args || [];\n  var next_listener = next ? next : this._getNextListener(method_name);\n  if (this.delegate && this.delegate[method_name]) {\n    // Avoid using expensive `apply` calls\n    var num_args = args_array.length;\n    switch (num_args) {\n      case 0:\n        return this.delegate[method_name](next_listener);\n      case 1:\n        return this.delegate[method_name](args_array[0], next_listener);\n      case 2:\n        return this.delegate[method_name](args_array[0], args_array[1], next_listener);\n    }\n  } else {\n    return next_listener(args_array[0], args_array[1]);\n  }\n};\n/**\n * Inbound metadata receiver.\n * @param {Metadata} metadata\n */\nInterceptingListener.prototype.onReceiveMetadata = function (metadata) {\n  this._callNext('onReceiveMetadata', [metadata]);\n};\n\n/**\n * Inbound message receiver.\n * @param {jspb.Message} message\n */\nInterceptingListener.prototype.onReceiveMessage = function (message) {\n  this._callNext('onReceiveMessage', [message]);\n};\n\n/**\n * When intercepting streaming message, we need to pass the streaming context\n * transparently along the chain. Hides the context from the delegate listener\n * methods.\n * @param {object} context Carries objects needed for streaming operations.\n * @param {jspb.Message} message The message received.\n */\nInterceptingListener.prototype.recvMessageWithContext = function (context, message) {\n  var fallback = this.next_listener.recvMessageWithContext;\n  var next_method = this.next_listener ? fallback.bind(this.next_listener, context) : context;\n  if (this.delegate.onReceiveMessage) {\n    this.delegate.onReceiveMessage(message, next_method, context);\n  } else {\n    next_method(message);\n  }\n};\n\n/**\n * Inbound status receiver.\n * @param {grpc~StatusObject} status\n */\nInterceptingListener.prototype.onReceiveStatus = function (status) {\n  this._callNext('onReceiveStatus', [status]);\n};\n\n/**\n * A dead-end listener used to terminate a call chain. Used when an interceptor\n * creates a branch chain, when the branch returns the listener chain will\n * terminate here.\n * @constructor\n */\nfunction EndListener() {}\nEndListener.prototype.onReceiveMetadata = function () {};\nEndListener.prototype.onReceiveMessage = function () {};\nEndListener.prototype.onReceiveStatus = function () {};\nEndListener.prototype.recvMessageWithContext = function () {};\n\n/**\n * Get a call object built with the provided options.\n * @param {grpc.Channel} channel\n * @param {string} path\n * @param {grpc.Client~CallOptions=} options Options object.\n */\nfunction getCall(channel, path, options) {\n  var deadline;\n  var host;\n  var parent;\n  var propagate_flags;\n  var credentials;\n  if (options) {\n    deadline = options.deadline;\n    host = options.host;\n    parent = options.parent ? options.parent.call : undefined;\n    propagate_flags = options.propagate_flags;\n    credentials = options.credentials;\n  }\n  if (deadline === undefined) {\n    deadline = Infinity;\n  }\n  var call = channel.createCall(path, deadline, host, parent, propagate_flags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\nvar OP_DEPENDENCIES = {\n  [grpc.opType.SEND_MESSAGE]: [grpc.opType.SEND_INITIAL_METADATA],\n  [grpc.opType.SEND_CLOSE_FROM_CLIENT]: [grpc.opType.SEND_MESSAGE],\n  [grpc.opType.RECV_MESSAGE]: [grpc.opType.SEND_INITIAL_METADATA]\n};\n\n/**\n * Produces a callback triggered by streaming response messages.\n * @private\n * @param {EventEmitter} emitter\n * @param {grpc.internal~Call} call\n * @param {function} get_listener Returns a grpc~Listener.\n * @param {grpc~deserialize} deserialize\n * @return {Function}\n */\nfunction _getStreamReadCallback(emitter, call, get_listener, deserialize) {\n  return function (err, response) {\n    if (err) {\n      // Something has gone wrong. Stop reading and wait for status\n      emitter.finished = true;\n      emitter._readsDone();\n      return;\n    }\n    var data = response.read;\n    var deserialized;\n    try {\n      deserialized = deserialize(data);\n    } catch (e) {\n      common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n      emitter._readsDone({\n        code: constants.status.INTERNAL,\n        details: 'Failed to parse server response'\n      });\n      return;\n    }\n    if (data === null) {\n      emitter._readsDone();\n      return;\n    }\n    var listener = get_listener();\n    var context = {\n      call: call,\n      listener: listener\n    };\n    listener.recvMessageWithContext(context, deserialized);\n  };\n}\n\n/**\n * Tests whether a batch can be started.\n * @private\n * @param {number[]} batch_ops The operations in the batch we are checking.\n * @param {number[]} completed_ops Previously completed operations.\n * @return {boolean}\n */\nfunction _areBatchRequirementsMet(batch_ops, completed_ops) {\n  var dependencies = common.flatMap(batch_ops, function (op) {\n    return OP_DEPENDENCIES[op] || [];\n  });\n  for (var i = 0; i < dependencies.length; i++) {\n    var required_dep = dependencies[i];\n    if (batch_ops.indexOf(required_dep) === -1 && completed_ops.indexOf(required_dep) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Enforces the order of operations for synchronous requests. If a batch's\n * operations cannot be started because required operations have not started\n * yet, the batch is deferred until requirements are met.\n * @private\n * @param {grpc.Client~Call} call\n * @param {object} batch\n * @param {object} batch_state\n * @param {number[]} [batch_state.completed_ops] The ops already sent.\n * @param {object} [batch_state.deferred_batches] Batches to be sent after\n *     their dependencies are fulfilled.\n * @param {function} callback\n * @return {object}\n */\nfunction _startBatchIfReady(call, batch, batch_state, callback) {\n  var completed_ops = batch_state.completed_ops;\n  var deferred_batches = batch_state.deferred_batches;\n  var batch_ops = Object.keys(batch).map(Number);\n  if (_areBatchRequirementsMet(batch_ops, completed_ops)) {\n    // Dependencies are met, start the batch and any deferred batches whose\n    // dependencies are met as a result.\n    call.startBatch(batch, callback);\n    completed_ops = Array.from(new Set(completed_ops.concat(batch_ops)));\n    deferred_batches = common.flatMap(deferred_batches, function (deferred_batch) {\n      var deferred_batch_ops = Object.keys(deferred_batch).map(Number);\n      if (_areBatchRequirementsMet(deferred_batch_ops, completed_ops)) {\n        call.startBatch(deferred_batch.batch, deferred_batch.callback);\n        return [];\n      }\n      return [deferred_batch];\n    });\n  } else {\n    // Dependencies are not met, defer the batch\n    deferred_batches = deferred_batches.concat({\n      batch: batch,\n      callback: callback\n    });\n  }\n  return {\n    completed_ops: completed_ops,\n    deferred_batches: deferred_batches\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for unary calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {Interceptor}\n */\nfunction _getUnaryInterceptor(method_definition, channel, emitter, callback) {\n  var serialize = method_definition.requestSerialize;\n  var deserialize = method_definition.responseDeserialize;\n  return function (options) {\n    var call = getCall(channel, method_definition.path, options);\n    var first_listener;\n    var final_requester = {};\n    var batch_state = {\n      completed_ops: [],\n      deferred_batches: []\n    };\n    final_requester.start = function (metadata, listener) {\n      var batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation()\n      };\n      first_listener = listener;\n      batch_state = _startBatchIfReady(call, batch, batch_state, function () {});\n    };\n    final_requester.sendMessage = function (message) {\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: serialize(message)\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state, function () {});\n    };\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true,\n        [grpc.opType.RECV_INITIAL_METADATA]: true,\n        [grpc.opType.RECV_MESSAGE]: true,\n        [grpc.opType.RECV_STATUS_ON_CLIENT]: true\n      };\n      var callback = function (err, response) {\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        var status = response.status;\n        var deserialized;\n        if (status.code === constants.status.OK) {\n          if (err) {\n            // Got a batch error, but OK status. Something went wrong\n            callback(err);\n            return;\n          } else {\n            try {\n              deserialized = deserialize(response.read);\n            } catch (e) {\n              common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n              /* Change status to indicate bad server response. This\n               * will result in passing an error to the callback */\n              status = {\n                code: constants.status.INTERNAL,\n                details: 'Failed to parse server response'\n              };\n            }\n          }\n        }\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        first_listener.onReceiveMetadata(response.metadata);\n        first_listener.onReceiveMessage(deserialized);\n        first_listener.onReceiveStatus(status);\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state, callback);\n    };\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function (code, details) {\n      call.cancelWithStatus(code, details);\n    };\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for client streaming\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {Interceptor}\n */\nfunction _getClientStreamingInterceptor(method_definition, channel, emitter, callback) {\n  var serialize = common.wrapIgnoreNull(method_definition.requestSerialize);\n  var deserialize = method_definition.responseDeserialize;\n  return function (options) {\n    var first_listener;\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n    final_requester.start = function (metadata, listener) {\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      first_listener = listener;\n      call.startBatch(metadata_batch, function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        listener.onReceiveMetadata(response.metadata);\n      });\n      var recv_batch = {};\n      recv_batch[grpc.opType.RECV_MESSAGE] = true;\n      recv_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n      call.startBatch(recv_batch, function (err, response) {\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        var status = response.status;\n        var deserialized;\n        if (status.code === constants.status.OK) {\n          if (err) {\n            // Got a batch error, but OK status. Something went wrong\n            callback(err);\n            return;\n          } else {\n            try {\n              deserialized = deserialize(response.read);\n            } catch (e) {\n              common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n              /* Change status to indicate bad server response. This will result\n               * in passing an error to the callback */\n              status = {\n                code: constants.status.INTERNAL,\n                details: 'Failed to parse server response'\n              };\n            }\n          }\n        }\n        listener.onReceiveMessage(deserialized);\n        listener.onReceiveStatus(status);\n      });\n    };\n    final_requester.sendMessage = function (chunk, context) {\n      var message;\n      var callback = context && context.callback ? context.callback : function () {};\n      var encoding = context && context.encoding ? context.encoding : '';\n      try {\n        message = serialize(chunk);\n      } catch (e) {\n        common.log(constants.logVerbosity.ERROR, `Request serialization failed: ${e.message}`);\n        /* Sending this error to the server and emitting it immediately on the\n           client may put the call in a slightly weird state on the client side,\n           but passing an object that causes a serialization failure is a misuse\n           of the API anyway, so that's OK. The primary purpose here is to give\n           the programmer a useful error and to stop the stream properly */\n        call.cancelWithStatus(constants.status.INTERNAL, 'Serialization failure');\n        callback(e);\n        return;\n      }\n      if (Number.isFinite(encoding)) {\n        /* Attach the encoding if it is a finite number. This is the closest we\n         * can get to checking that it is valid flags */\n        message.grpcWriteFlags = encoding;\n      }\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      call.startBatch(batch, function (err, event) {\n        callback(err, event);\n      });\n    };\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      call.startBatch(batch, function () {});\n    };\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function (code, details) {\n      call.cancelWithStatus(code, details);\n    };\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for server streaming\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @return {Interceptor}\n */\nfunction _getServerStreamingInterceptor(method_definition, channel, emitter) {\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  var serialize = method_definition.requestSerialize;\n  return function (options) {\n    var batch_state = {\n      completed_ops: [],\n      deferred_batches: []\n    };\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n    var first_listener;\n    var get_listener = function () {\n      return first_listener;\n    };\n    final_requester.start = function (metadata, listener) {\n      first_listener = listener;\n      metadata = metadata.clone();\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      var callback = function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n        first_listener.onReceiveMetadata(Metadata._fromCoreRepresentation(response.metadata));\n      };\n      batch_state = _startBatchIfReady(call, metadata_batch, batch_state, callback);\n      var status_batch = {\n        [grpc.opType.RECV_STATUS_ON_CLIENT]: true\n      };\n      call.startBatch(status_batch, function (err, response) {\n        if (err) {\n          emitter.emit('error', err);\n          return;\n        }\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        first_listener.onReceiveStatus(response.status);\n      });\n    };\n    final_requester.sendMessage = function (argument) {\n      var message = serialize(argument);\n      if (options) {\n        message.grpcWriteFlags = options.flags;\n      }\n      var send_batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      var callback = function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n      };\n      batch_state = _startBatchIfReady(call, send_batch, batch_state, callback);\n    };\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state, function () {});\n    };\n    final_requester.recvMessageWithContext = function (context) {\n      var recv_batch = {\n        [grpc.opType.RECV_MESSAGE]: true\n      };\n      var callback = _getStreamReadCallback(emitter, call, get_listener, deserialize);\n      batch_state = _startBatchIfReady(call, recv_batch, batch_state, callback);\n    };\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function (code, details) {\n      call.cancelWithStatus(code, details);\n    };\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for bi-directional\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @return {Interceptor}\n */\nfunction _getBidiStreamingInterceptor(method_definition, channel, emitter) {\n  var serialize = common.wrapIgnoreNull(method_definition.requestSerialize);\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  return function (options) {\n    var first_listener;\n    var get_listener = function () {\n      return first_listener;\n    };\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n    final_requester.start = function (metadata, listener) {\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      first_listener = listener;\n      call.startBatch(metadata_batch, function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        listener.onReceiveMetadata(response.metadata);\n      });\n      var recv_batch = {};\n      recv_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n      call.startBatch(recv_batch, function (err, response) {\n        var status = response.status;\n        if (status.code === constants.status.OK) {\n          if (err) {\n            emitter.emit('error', err);\n            return;\n          }\n        }\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        listener.onReceiveStatus(status);\n      });\n    };\n    final_requester.sendMessage = function (chunk, context) {\n      var message;\n      var callback = context && context.callback ? context.callback : function () {};\n      var encoding = context && context.encoding ? context.encoding : '';\n      try {\n        message = serialize(chunk);\n      } catch (e) {\n        common.log(constants.logVerbosity.ERROR, `Request serialization failed: ${e.message}`);\n        /* Sending this error to the server and emitting it immediately on the\n           client may put the call in a slightly weird state on the client side,\n           but passing an object that causes a serialization failure is a misuse\n           of the API anyway, so that's OK. The primary purpose here is to give\n           the programmer a useful error and to stop the stream properly */\n        call.cancelWithStatus(constants.status.INTERNAL, 'Serialization failure');\n        callback(e);\n        return;\n      }\n      if (Number.isFinite(encoding)) {\n        /* Attach the encoding if it is a finite number. This is the closest we\n         * can get to checking that it is valid flags */\n        message.grpcWriteFlags = encoding;\n      }\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      call.startBatch(batch, function (err, event) {\n        callback(err, event);\n      });\n    };\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      call.startBatch(batch, function () {});\n    };\n    final_requester.recvMessageWithContext = function (context) {\n      var recv_batch = {\n        [grpc.opType.RECV_MESSAGE]: true\n      };\n      call.startBatch(recv_batch, _getStreamReadCallback(emitter, call, get_listener, deserialize));\n    };\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function (code, details) {\n      call.cancelWithStatus(code, details);\n    };\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces a listener for responding to callers of unary RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {grpc~Listener}\n */\nfunction _getUnaryListener(method_definition, emitter, callback) {\n  var resultMessage;\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message) {\n      resultMessage = message;\n    },\n    onReceiveStatus: function (status) {\n      if (status.code !== constants.status.OK) {\n        var error = common.createStatusError(status);\n        callback(error);\n      } else {\n        callback(null, resultMessage);\n      }\n      emitter.emit('status', status);\n    }\n  };\n}\n\n/**\n * Produces a listener for responding to callers of client streaming RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {grpc~Listener}\n */\nfunction _getClientStreamingListener(method_definition, emitter, callback) {\n  var resultMessage;\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message) {\n      resultMessage = message;\n    },\n    onReceiveStatus: function (status) {\n      if (status.code !== constants.status.OK) {\n        var error = common.createStatusError(status);\n        callback(error);\n      } else {\n        callback(null, resultMessage);\n      }\n      emitter.emit('status', status);\n    }\n  };\n}\n\n/**\n * Produces a listener for responding to callers of server streaming RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @return {grpc~Listener}\n */\nfunction _getServerStreamingListener(method_definition, emitter) {\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message, next, context) {\n      if (emitter.push(message) && message !== null) {\n        var call = context.call;\n        var get_listener = function () {\n          return context.listener;\n        };\n        var read_batch = {};\n        read_batch[grpc.opType.RECV_MESSAGE] = true;\n        call.startBatch(read_batch, _getStreamReadCallback(emitter, call, get_listener, deserialize));\n      } else {\n        emitter.reading = false;\n      }\n    },\n    onReceiveStatus: function (status) {\n      emitter._receiveStatus(status);\n    }\n  };\n}\n\n/**\n * Produces a listener for responding to callers of bi-directional RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @return {grpc~Listener}\n */\nfunction _getBidiStreamingListener(method_definition, emitter) {\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message, next, context) {\n      if (emitter.push(message) && message !== null) {\n        var call = context.call;\n        var get_listener = function () {\n          return context.listener;\n        };\n        var read_batch = {};\n        read_batch[grpc.opType.RECV_MESSAGE] = true;\n        call.startBatch(read_batch, _getStreamReadCallback(emitter, call, get_listener, deserialize));\n      } else {\n        emitter.reading = false;\n      }\n    },\n    onReceiveStatus: function (status) {\n      emitter._receiveStatus(status);\n    }\n  };\n}\nvar interceptorGenerators = {\n  [methodTypes.UNARY]: _getUnaryInterceptor,\n  [methodTypes.CLIENT_STREAMING]: _getClientStreamingInterceptor,\n  [methodTypes.SERVER_STREAMING]: _getServerStreamingInterceptor,\n  [methodTypes.BIDI_STREAMING]: _getBidiStreamingInterceptor\n};\nvar listenerGenerators = {\n  [methodTypes.UNARY]: _getUnaryListener,\n  [methodTypes.CLIENT_STREAMING]: _getClientStreamingListener,\n  [methodTypes.SERVER_STREAMING]: _getServerStreamingListener,\n  [methodTypes.BIDI_STREAMING]: _getBidiStreamingListener\n};\n\n/**\n * Creates the last listener in an interceptor stack.\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function=} callback\n * @return {grpc~Listener}\n */\nfunction getLastListener(method_definition, emitter, callback) {\n  if (typeof emitter === 'function') {\n    callback = emitter;\n    callback = function () {};\n  }\n  if (typeof callback !== 'function') {\n    callback = function () {};\n  }\n  if (!(emitter instanceof EventEmitter && typeof callback === 'function')) {\n    throw new Error('Argument mismatch in getLastListener');\n  }\n  var method_type = common.getMethodType(method_definition);\n  var generator = listenerGenerators[method_type];\n  return generator(method_definition, emitter, callback);\n}\n\n/**\n *\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Client~CallOptions} options\n * @param {Interceptor[]} interceptors\n * @param {grpc.Channel} channel\n * @param {function|EventEmitter} responder\n */\nfunction getInterceptingCall(method_definition, options, interceptors, channel, responder) {\n  var last_interceptor = _getLastInterceptor(method_definition, channel, responder);\n  var all_interceptors = interceptors.concat(last_interceptor);\n  return _buildChain(all_interceptors, options);\n}\n\n/**\n * Creates the last interceptor in an interceptor stack.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {function|EventEmitter} responder\n * @return {Interceptor}\n */\nfunction _getLastInterceptor(method_definition, channel, responder) {\n  var callback = typeof responder === 'function' ? responder : function () {};\n  var emitter = responder instanceof EventEmitter ? responder : new EventEmitter();\n  var method_type = common.getMethodType(method_definition);\n  var generator = interceptorGenerators[method_type];\n  return generator(method_definition, channel, emitter, callback);\n}\n\n/**\n * Chain a list of interceptors together and return the first InterceptingCall.\n * @private\n * @param {Interceptor[]} interceptors An interceptor stack.\n * @param {grpc.Client~CallOptions} options Call options.\n * @return {InterceptingCall}\n */\nfunction _buildChain(interceptors, options) {\n  var next = function (interceptors) {\n    if (interceptors.length === 0) {\n      return function (options) {};\n    }\n    var head_interceptor = interceptors[0];\n    var rest_interceptors = interceptors.slice(1);\n    return function (options) {\n      return head_interceptor(options, next(rest_interceptors));\n    };\n  };\n  var chain = next(interceptors)(options);\n  return new InterceptingCall(chain);\n}\n\n/**\n * Wraps a plain listener object in an InterceptingListener if it isn't an\n * InterceptingListener already.\n * @param {InterceptingListener|object|null} current_listener\n * @param {InterceptingListener|EndListener} next_listener\n * @return {InterceptingListener|null}\n * @private\n */\nfunction _getInterceptingListener(current_listener, next_listener) {\n  if (!_isInterceptingListener(current_listener)) {\n    return new InterceptingListener(next_listener, current_listener);\n  }\n  return current_listener;\n}\n\n/**\n * Test if the listener exists and is an InterceptingListener.\n * @param listener\n * @return {boolean}\n * @private\n */\nfunction _isInterceptingListener(listener) {\n  return listener && listener.constructor.name === 'InterceptingListener';\n}\nexports.resolveInterceptorProviders = resolveInterceptorProviders;\nexports.InterceptingCall = InterceptingCall;\nexports.ListenerBuilder = ListenerBuilder;\nexports.RequesterBuilder = RequesterBuilder;\nexports.StatusBuilder = StatusBuilder;\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nexports.getInterceptingCall = getInterceptingCall;\nexports.getLastListener = getLastListener;","map":{"version":3,"names":["require","grpc","Metadata","constants","common","methodTypes","EventEmitter","InterceptorConfigurationError","message","extra","Error","captureStackTrace","constructor","name","inherits","StatusBuilder","code","details","metadata","prototype","withCode","withDetails","withMetadata","build","status","undefined","ListenerBuilder","withOnReceiveMetadata","on_receive_metadata","withOnReceiveMessage","on_receive_message","withOnReceiveStatus","on_receive_status","self","listener","onReceiveMetadata","onReceiveMessage","onReceiveStatus","RequesterBuilder","start","half_close","cancel","withStart","withSendMessage","send_message","withHalfClose","withCancel","requester","sendMessage","halfClose","resolveInterceptorProviders","providers","method_definition","Array","isArray","interceptors","i","length","provider","interceptor","push","InterceptingCall","next_call","emptyNext","_getNextCall","method_name","bind","_callNext","args","next","args_array","num_args","next_listener","_getInterceptingListener","EndListener","current_listener","cancelWithStatus","getPeer","sendMessageWithContext","context","recvMessageWithContext","InterceptingListener","delegate","_getNextListener","fallback","next_method","getCall","channel","path","options","deadline","host","parent","propagate_flags","credentials","call","Infinity","createCall","setCredentials","OP_DEPENDENCIES","opType","SEND_MESSAGE","SEND_INITIAL_METADATA","SEND_CLOSE_FROM_CLIENT","RECV_MESSAGE","_getStreamReadCallback","emitter","get_listener","deserialize","err","response","finished","_readsDone","data","read","deserialized","e","log","logVerbosity","ERROR","INTERNAL","_areBatchRequirementsMet","batch_ops","completed_ops","dependencies","flatMap","op","required_dep","indexOf","_startBatchIfReady","batch","batch_state","callback","deferred_batches","Object","keys","map","Number","startBatch","from","Set","concat","deferred_batch","deferred_batch_ops","_getUnaryInterceptor","serialize","requestSerialize","responseDeserialize","first_listener","final_requester","_getCoreRepresentation","RECV_INITIAL_METADATA","RECV_STATUS_ON_CLIENT","_fromCoreRepresentation","OK","_getClientStreamingInterceptor","wrapIgnoreNull","metadata_batch","recv_batch","chunk","encoding","isFinite","grpcWriteFlags","event","_getServerStreamingInterceptor","clone","status_batch","emit","argument","flags","send_batch","_getBidiStreamingInterceptor","_getUnaryListener","resultMessage","error","createStatusError","_getClientStreamingListener","_getServerStreamingListener","read_batch","reading","_receiveStatus","_getBidiStreamingListener","interceptorGenerators","UNARY","CLIENT_STREAMING","SERVER_STREAMING","BIDI_STREAMING","listenerGenerators","getLastListener","method_type","getMethodType","generator","getInterceptingCall","responder","last_interceptor","_getLastInterceptor","all_interceptors","_buildChain","head_interceptor","rest_interceptors","slice","chain","_isInterceptingListener","exports"],"sources":["/var/www/html/project/Dash_Vuexy-master/node_modules/grpc/src/client_interceptors.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * Client Interceptors\n *\n * This module describes the interceptor framework for clients.\n * An interceptor is a function which takes an options object and a nextCall\n * function and returns an InterceptingCall:\n *\n * ```\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options));\n * }\n * ```\n *\n * The interceptor function must return an InterceptingCall object. Returning\n * `new InterceptingCall(nextCall(options))` will satisfy the contract (but\n * provide no interceptor functionality). `nextCall` is a function which will\n * generate the next interceptor in the chain.\n *\n * To implement interceptor functionality, create a requester and pass it to\n * the InterceptingCall constructor:\n *\n * `return new InterceptingCall(nextCall(options), requester);`\n *\n * A requester is a POJO with zero or more of the following methods:\n *\n * `start(metadata, listener, next)`\n * * To continue, call next(metadata, listener). Listeners are described\n * * below.\n *\n * `sendMessage(message, next)`\n * * To continue, call next(message).\n *\n * `halfClose(next)`\n * * To continue, call next().\n *\n * `cancel(message, next)`\n * * To continue, call next().\n *\n * A listener is a POJO with one or more of the following methods:\n *\n * `onReceiveMetadata(metadata, next)`\n * * To continue, call next(metadata)\n *\n * `onReceiveMessage(message, next)`\n * * To continue, call next(message)\n *\n * `onReceiveStatus(status, next)`\n * * To continue, call next(status)\n *\n * A listener is provided by the requester's `start` method. The provided\n * listener implements all the inbound interceptor methods, which can be called\n * to short-circuit the gRPC call.\n *\n * Three usage patterns are supported for listeners:\n * 1) Pass the listener along without modification: `next(metadata, listener)`.\n *   In this case the interceptor declines to intercept any inbound operations.\n * 2) Create a new listener with one or more inbound interceptor methods and\n *   pass it to `next`. In this case the interceptor will fire on the inbound\n *   operations implemented in the new listener.\n * 3) Make direct inbound calls to the provided listener's methods. This\n *   short-circuits the interceptor stack.\n *\n * Do not modify the listener passed in. Either pass it along unmodified,\n * ignore it, or call methods on it to short-circuit the call.\n *\n * To intercept errors, implement the `onReceiveStatus` method and test for\n * `status.code !== grpc.status.OK`.\n *\n * To intercept trailers, examine `status.metadata` in the `onReceiveStatus`\n * method.\n *\n * This is a trivial implementation of all interceptor methods:\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options), {\n *     start: function(metadata, listener, next) {\n *       next(metadata, {\n *         onReceiveMetadata: function (metadata, next) {\n *           next(metadata);\n *         },\n *         onReceiveMessage: function (message, next) {\n *           next(message);\n *         },\n *         onReceiveStatus: function (status, next) {\n *           next(status);\n *         },\n *       });\n *     },\n *     sendMessage: function(message, next) {\n *       next(message);\n *     },\n *     halfClose: function(next) {\n *       next();\n *     },\n *     cancel: function(message, next) {\n *       next();\n *     }\n *   });\n * };\n *\n * This is an interceptor with a single method:\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options), {\n *     sendMessage: function(message, next) {\n *       next(message);\n *     }\n *   });\n * };\n *\n * Builders are provided for convenience: StatusBuilder, ListenerBuilder,\n * and RequesterBuilder\n *\n * gRPC client operations use this mapping to interceptor methods:\n *\n * grpc.opType.SEND_INITIAL_METADATA -> start\n * grpc.opType.SEND_MESSAGE -> sendMessage\n * grpc.opType.SEND_CLOSE_FROM_CLIENT -> halfClose\n * grpc.opType.RECV_INITIAL_METADATA -> onReceiveMetadata\n * grpc.opType.RECV_MESSAGE -> onReceiveMessage\n * grpc.opType.RECV_STATUS_ON_CLIENT -> onReceiveStatus\n *\n * @module\n */\n\n'use strict';\n\nvar grpc = require('./grpc_extension');\nvar Metadata = require('./metadata');\nvar constants = require('./constants');\nvar common = require('./common');\nvar methodTypes = constants.methodTypes;\nvar EventEmitter = require('events').EventEmitter;\n\n/**\n * A custom error thrown when interceptor configuration fails.\n * @param {string} message The error message\n * @param {object=} extra\n * @constructor\n */\nvar InterceptorConfigurationError =\n  function InterceptorConfigurationError(message, extra) {\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.message = message;\n    this.extra = extra;\n  };\n\nrequire('util').inherits(InterceptorConfigurationError, Error);\n\n/**\n * A builder for gRPC status objects.\n * @constructor\n */\nfunction StatusBuilder() {\n  this.code = null;\n  this.details = null;\n  this.metadata = null;\n}\n\n/**\n * Adds a status code to the builder.\n * @param {number} code The status code.\n * @return {StatusBuilder}\n */\nStatusBuilder.prototype.withCode = function(code) {\n  this.code = code;\n  return this;\n};\n\n/**\n * Adds details to the builder.\n * @param {string} details A status message.\n * @return {StatusBuilder}\n */\nStatusBuilder.prototype.withDetails = function(details) {\n  this.details = details;\n  return this;\n};\n\n/**\n * Adds metadata to the builder.\n * @param {Metadata} metadata The gRPC status metadata.\n * @return {StatusBuilder}\n */\nStatusBuilder.prototype.withMetadata = function(metadata) {\n  this.metadata = metadata;\n  return this;\n};\n\n/**\n * Builds the status object.\n * @return {grpc~StatusObject} A gRPC status.\n */\nStatusBuilder.prototype.build = function() {\n  var status = {};\n  if (this.code !== undefined) {\n    status.code = this.code;\n  }\n  if (this.details) {\n    status.details = this.details;\n  }\n  if (this.metadata) {\n    status.metadata = this.metadata;\n  }\n  return status;\n};\n\n/**\n * A builder for listener interceptors.\n * @constructor\n */\nfunction ListenerBuilder() {\n  this.metadata = null;\n  this.message = null;\n  this.status = null;\n}\n\n/**\n * Adds an onReceiveMetadata method to the builder.\n * @param {MetadataListener} on_receive_metadata A listener method for\n * receiving metadata.\n * @return {ListenerBuilder}\n */\nListenerBuilder.prototype.withOnReceiveMetadata =\n  function(on_receive_metadata) {\n    this.metadata = on_receive_metadata;\n    return this;\n  };\n\n/**\n * Adds an onReceiveMessage method to the builder.\n * @param {MessageListener} on_receive_message A listener method for receiving\n * messages.\n * @return {ListenerBuilder}\n */\nListenerBuilder.prototype.withOnReceiveMessage = function(on_receive_message) {\n  this.message = on_receive_message;\n  return this;\n};\n\n/**\n * Adds an onReceiveStatus method to the builder.\n * @param {StatusListener} on_receive_status A listener method for receiving\n * status.\n * @return {ListenerBuilder}\n */\nListenerBuilder.prototype.withOnReceiveStatus = function(on_receive_status) {\n  this.status = on_receive_status;\n  return this;\n};\n\n/**\n * Builds the call listener.\n * @return {grpc~Listener}\n */\nListenerBuilder.prototype.build = function() {\n  var self = this;\n  var listener = {};\n  listener.onReceiveMetadata = self.metadata;\n  listener.onReceiveMessage = self.message;\n  listener.onReceiveStatus = self.status;\n  return listener;\n};\n\n/**\n * A builder for the outbound methods of an interceptor.\n * @constructor\n */\nfunction RequesterBuilder() {\n  this.start = null;\n  this.message = null;\n  this.half_close = null;\n  this.cancel = null;\n}\n\n/**\n * Add a metadata requester to the builder.\n * @param {MetadataRequester} start A requester method for handling metadata.\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withStart = function(start) {\n  this.start = start;\n  return this;\n};\n\n/**\n * Add a message requester to the builder.\n * @param {MessageRequester} send_message A requester method for handling\n * messages.\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withSendMessage = function(send_message) {\n  this.message = send_message;\n  return this;\n};\n\n/**\n * Add a close requester to the builder.\n * @param {CloseRequester} half_close A requester method for handling client\n * close.\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withHalfClose = function(half_close) {\n  this.half_close = half_close;\n  return this;\n};\n\n/**\n * Add a cancel requester to the builder.\n * @param {CancelRequester} cancel A requester method for handling `cancel`\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withCancel = function(cancel) {\n  this.cancel = cancel;\n  return this;\n};\n\n/**\n * Builds the requester's interceptor methods.\n * @return {grpc~Requester}\n */\nRequesterBuilder.prototype.build = function() {\n  var requester = {};\n  requester.start = this.start;\n  requester.sendMessage = this.message;\n  requester.halfClose = this.half_close;\n  requester.cancel = this.cancel;\n  return requester;\n};\n\n/**\n * Transforms a list of interceptor providers into interceptors.\n * @param {InterceptorProvider[]} providers\n * @param {grpc~MethodDefinition} method_definition\n * @return {null|Interceptor[]}\n */\nvar resolveInterceptorProviders = function(providers, method_definition) {\n  if (!Array.isArray(providers)) {\n    return null;\n  }\n  var interceptors = [];\n  for (var i = 0; i < providers.length; i++) {\n    var provider = providers[i];\n    var interceptor = provider(method_definition);\n    if (interceptor) {\n      interceptors.push(interceptor);\n    }\n  }\n  return interceptors;\n};\n\n/**\n * A chainable gRPC call proxy which will delegate to an optional requester\n * object. By default, interceptor methods will chain to next_call. If a\n * requester is provided which implements an interceptor method, that\n * requester method will be executed as part of the chain.\n * @param {InterceptingCall|null} next_call The next call in the chain\n * @param {grpc~Requester=} requester Interceptor methods to handle request\n * operations.\n * @constructor\n */\nfunction InterceptingCall(next_call, requester) {\n  this.next_call = next_call;\n  this.requester = requester;\n}\n\nconst emptyNext = function() {};\n\n/**\n * Get the next method in the chain or a no-op function if we are at the end\n * of the chain\n * @param {string} method_name\n * @return {function} The next method in the chain\n * @private\n */\nInterceptingCall.prototype._getNextCall = function(method_name) {\n  return this.next_call ?\n    this.next_call[method_name].bind(this.next_call) :\n    emptyNext;\n};\n\n/**\n * Call the next method in the chain. This will either be on the next\n * InterceptingCall (next_call), or the requester if the requester\n * implements the method.\n * @param {string} method_name The name of the interceptor method\n * @param {array=} args Payload arguments for the operation\n * @param {function=} next The next InterceptingCall's method\n * @return {null}\n * @private\n */\nInterceptingCall.prototype._callNext = function(method_name, args, next) {\n  var args_array = args || [];\n  var next_call = next ? next : this._getNextCall(method_name);\n  if (this.requester && this.requester[method_name]) {\n    // Avoid using expensive `apply` calls\n    var num_args = args_array.length;\n    switch (num_args) {\n      case 0:\n        return this.requester[method_name](next_call);\n      case 1:\n        return this.requester[method_name](args_array[0], next_call);\n      case 2:\n        return this.requester[method_name](args_array[0], args_array[1],\n                                           next_call);\n    }\n  } else {\n    if (next_call === emptyNext) {\n      throw new Error('Interceptor call chain terminated unexpectedly');\n    }\n    return next_call(args_array[0], args_array[1]);\n  }\n};\n\n/**\n * Starts a call through the outbound interceptor chain and adds an element to\n * the reciprocal inbound listener chain.\n * @param {grpc.Metadata} metadata The outgoing metadata.\n * @param {grpc~Listener} listener An intercepting listener for inbound\n * operations.\n */\nInterceptingCall.prototype.start = function(metadata, listener) {\n  var self = this;\n\n  // If the listener provided is an InterceptingListener, use it. Otherwise, we\n  // must be at the end of the listener chain, and any listener operations\n  // should be terminated in an EndListener.\n  var next_listener = _getInterceptingListener(listener, new EndListener());\n\n  // Build the next method in the interceptor chain\n  var next = function(metadata, current_listener) {\n    // If there is a next call in the chain, run it. Otherwise do nothing.\n    if (self.next_call) {\n      // Wire together any listener provided with the next listener\n      var listener = _getInterceptingListener(current_listener, next_listener);\n      self.next_call.start(metadata, listener);\n    }\n  };\n  this._callNext('start', [metadata, next_listener], next);\n};\n\n/**\n * Pass a message through the interceptor chain.\n * @param {jspb.Message} message\n */\nInterceptingCall.prototype.sendMessage = function(message) {\n  this._callNext('sendMessage', [message]);\n};\n\n/**\n * Run a close operation through the interceptor chain\n */\nInterceptingCall.prototype.halfClose = function() {\n  this._callNext('halfClose');\n};\n\n/**\n * Run a cancel operation through the interceptor chain\n */\nInterceptingCall.prototype.cancel = function() {\n  this._callNext('cancel');\n};\n\n/**\n * Run a cancelWithStatus operation through the interceptor chain.\n * @param {number} code\n * @param {string} details\n */\nInterceptingCall.prototype.cancelWithStatus = function(code, details) {\n  this._callNext('cancelWithStatus', [code, details]);\n};\n\n/**\n * Pass a getPeer call down to the base gRPC call (should not be intercepted)\n * @return {object}\n */\nInterceptingCall.prototype.getPeer = function() {\n  return this._callNext('getPeer');\n};\n\n/**\n * For streaming calls, we need to transparently pass the stream's context\n * through the interceptor chain. Passes the context between InterceptingCalls\n * but hides it from any requester implementations.\n * @param {object} context Carries objects needed for streaming operations.\n * @param {jspb.Message} message The message to send.\n */\nInterceptingCall.prototype.sendMessageWithContext = function(context, message) {\n  var next = this.next_call ?\n    this.next_call.sendMessageWithContext.bind(this.next_call, context) :\n    context;\n  this._callNext('sendMessage', [message], next);\n};\n\n/**\n * For receiving streaming messages, we need to seed the base interceptor with\n * the streaming context to create a RECV_MESSAGE batch.\n * @param {object} context Carries objects needed for streaming operations\n */\nInterceptingCall.prototype.recvMessageWithContext = function(context) {\n  this._callNext('recvMessageWithContext', [context]);\n};\n\n/**\n * A chain-able listener object which will delegate to a custom listener when\n * appropriate.\n * @param {InterceptingListener|null} next_listener The next\n * InterceptingListener in the chain\n * @param {grpc~Listener=} delegate A custom listener object which may implement\n * specific operations\n * @constructor\n */\nfunction InterceptingListener(next_listener, delegate) {\n  this.delegate = delegate || {};\n  this.next_listener = next_listener;\n}\n\n/**\n * Get the next method in the chain or a no-op function if we are at the end\n * of the chain.\n * @param {string} method_name The name of the listener method.\n * @return {function} The next method in the chain\n * @private\n */\nInterceptingListener.prototype._getNextListener = function(method_name) {\n  return this.next_listener ?\n    this.next_listener[method_name].bind(this.next_listener) :\n    function(){};\n};\n\n/**\n * Call the next method in the chain. This will either be on the next\n * InterceptingListener (next_listener), or the requester if the requester\n * implements the method.\n * @param {string} method_name The name of the interceptor method\n * @param {array=} args Payload arguments for the operation\n * @param {function=} next The next InterceptingListener's method\n * @return {null}\n * @private\n */\nInterceptingListener.prototype._callNext = function(method_name, args, next) {\n  var args_array = args || [];\n  var next_listener = next ? next : this._getNextListener(method_name);\n  if (this.delegate && this.delegate[method_name]) {\n    // Avoid using expensive `apply` calls\n    var num_args = args_array.length;\n    switch (num_args) {\n      case 0:\n        return this.delegate[method_name](next_listener);\n      case 1:\n        return this.delegate[method_name](args_array[0], next_listener);\n      case 2:\n        return this.delegate[method_name](args_array[0], args_array[1],\n                                          next_listener);\n    }\n  } else {\n    return next_listener(args_array[0], args_array[1]);\n  }\n};\n/**\n * Inbound metadata receiver.\n * @param {Metadata} metadata\n */\nInterceptingListener.prototype.onReceiveMetadata = function(metadata) {\n  this._callNext('onReceiveMetadata', [metadata]);\n};\n\n/**\n * Inbound message receiver.\n * @param {jspb.Message} message\n */\nInterceptingListener.prototype.onReceiveMessage = function(message) {\n  this._callNext('onReceiveMessage', [message]);\n};\n\n/**\n * When intercepting streaming message, we need to pass the streaming context\n * transparently along the chain. Hides the context from the delegate listener\n * methods.\n * @param {object} context Carries objects needed for streaming operations.\n * @param {jspb.Message} message The message received.\n */\nInterceptingListener.prototype.recvMessageWithContext = function(context,\n                                                                 message) {\n  var fallback = this.next_listener.recvMessageWithContext;\n  var next_method = this.next_listener ?\n    fallback.bind(this.next_listener, context) :\n    context;\n  if (this.delegate.onReceiveMessage) {\n    this.delegate.onReceiveMessage(message, next_method, context);\n  } else {\n    next_method(message);\n  }\n};\n\n/**\n * Inbound status receiver.\n * @param {grpc~StatusObject} status\n */\nInterceptingListener.prototype.onReceiveStatus = function(status) {\n  this._callNext('onReceiveStatus', [status]);\n};\n\n/**\n * A dead-end listener used to terminate a call chain. Used when an interceptor\n * creates a branch chain, when the branch returns the listener chain will\n * terminate here.\n * @constructor\n */\nfunction EndListener() {}\nEndListener.prototype.onReceiveMetadata = function(){};\nEndListener.prototype.onReceiveMessage = function(){};\nEndListener.prototype.onReceiveStatus = function(){};\nEndListener.prototype.recvMessageWithContext = function(){};\n\n/**\n * Get a call object built with the provided options.\n * @param {grpc.Channel} channel\n * @param {string} path\n * @param {grpc.Client~CallOptions=} options Options object.\n */\nfunction getCall(channel, path, options) {\n  var deadline;\n  var host;\n  var parent;\n  var propagate_flags;\n  var credentials;\n  if (options) {\n    deadline = options.deadline;\n    host = options.host;\n    parent = options.parent ? options.parent.call : undefined;\n    propagate_flags = options.propagate_flags;\n    credentials = options.credentials;\n  }\n  if (deadline === undefined) {\n    deadline = Infinity;\n  }\n  var call = channel.createCall(path, deadline, host,\n                                parent, propagate_flags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\n\nvar OP_DEPENDENCIES = {\n  [grpc.opType.SEND_MESSAGE]: [grpc.opType.SEND_INITIAL_METADATA],\n  [grpc.opType.SEND_CLOSE_FROM_CLIENT]: [grpc.opType.SEND_MESSAGE],\n  [grpc.opType.RECV_MESSAGE]: [grpc.opType.SEND_INITIAL_METADATA]\n};\n\n/**\n * Produces a callback triggered by streaming response messages.\n * @private\n * @param {EventEmitter} emitter\n * @param {grpc.internal~Call} call\n * @param {function} get_listener Returns a grpc~Listener.\n * @param {grpc~deserialize} deserialize\n * @return {Function}\n */\nfunction _getStreamReadCallback(emitter, call, get_listener, deserialize) {\n  return function (err, response) {\n    if (err) {\n      // Something has gone wrong. Stop reading and wait for status\n      emitter.finished = true;\n      emitter._readsDone();\n      return;\n    }\n    var data = response.read;\n    var deserialized;\n    try {\n      deserialized = deserialize(data);\n    } catch (e) {\n      common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n      emitter._readsDone({\n        code: constants.status.INTERNAL,\n        details: 'Failed to parse server response'\n      });\n      return;\n    }\n    if (data === null) {\n      emitter._readsDone();\n      return;\n    }\n    var listener = get_listener();\n    var context = {\n      call: call,\n      listener: listener\n    };\n    listener.recvMessageWithContext(context, deserialized);\n  };\n}\n\n/**\n * Tests whether a batch can be started.\n * @private\n * @param {number[]} batch_ops The operations in the batch we are checking.\n * @param {number[]} completed_ops Previously completed operations.\n * @return {boolean}\n */\nfunction _areBatchRequirementsMet(batch_ops, completed_ops) {\n  var dependencies = common.flatMap(batch_ops, function(op) {\n    return OP_DEPENDENCIES[op] || [];\n  });\n  for (var i = 0; i < dependencies.length; i++) {\n    var required_dep = dependencies[i];\n    if (batch_ops.indexOf(required_dep) === -1 &&\n        completed_ops.indexOf(required_dep) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Enforces the order of operations for synchronous requests. If a batch's\n * operations cannot be started because required operations have not started\n * yet, the batch is deferred until requirements are met.\n * @private\n * @param {grpc.Client~Call} call\n * @param {object} batch\n * @param {object} batch_state\n * @param {number[]} [batch_state.completed_ops] The ops already sent.\n * @param {object} [batch_state.deferred_batches] Batches to be sent after\n *     their dependencies are fulfilled.\n * @param {function} callback\n * @return {object}\n */\nfunction _startBatchIfReady(call, batch, batch_state, callback) {\n  var completed_ops = batch_state.completed_ops;\n  var deferred_batches = batch_state.deferred_batches;\n  var batch_ops = Object.keys(batch).map(Number);\n  if (_areBatchRequirementsMet(batch_ops, completed_ops)) {\n    // Dependencies are met, start the batch and any deferred batches whose\n    // dependencies are met as a result.\n    call.startBatch(batch, callback);\n    completed_ops = Array.from(new Set(completed_ops.concat(batch_ops)));\n    deferred_batches = common.flatMap(deferred_batches, function(deferred_batch) {\n      var deferred_batch_ops = Object.keys(deferred_batch).map(Number);\n      if (_areBatchRequirementsMet(deferred_batch_ops, completed_ops)) {\n        call.startBatch(deferred_batch.batch, deferred_batch.callback);\n        return [];\n      }\n      return [deferred_batch];\n    });\n  } else {\n    // Dependencies are not met, defer the batch\n    deferred_batches = deferred_batches.concat({\n      batch: batch,\n      callback: callback\n    });\n  }\n  return {\n    completed_ops: completed_ops,\n    deferred_batches: deferred_batches\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for unary calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {Interceptor}\n */\nfunction _getUnaryInterceptor(method_definition, channel, emitter, callback) {\n  var serialize = method_definition.requestSerialize;\n  var deserialize = method_definition.responseDeserialize;\n  return function (options) {\n    var call = getCall(channel, method_definition.path, options);\n    var first_listener;\n    var final_requester = {};\n    var batch_state = {\n      completed_ops: [],\n      deferred_batches: []\n    };\n    final_requester.start = function (metadata, listener) {\n      var batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]:\n          metadata._getCoreRepresentation(),\n      };\n      first_listener = listener;\n      batch_state = _startBatchIfReady(call, batch, batch_state,\n                                       function() {});\n    };\n    final_requester.sendMessage = function (message) {\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: serialize(message),\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state,\n                                         function() {});\n    };\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true,\n        [grpc.opType.RECV_INITIAL_METADATA]: true,\n        [grpc.opType.RECV_MESSAGE]: true,\n        [grpc.opType.RECV_STATUS_ON_CLIENT]: true\n      };\n      var callback = function (err, response) {\n        response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n        var status = response.status;\n        var deserialized;\n        if (status.code === constants.status.OK) {\n          if (err) {\n            // Got a batch error, but OK status. Something went wrong\n            callback(err);\n            return;\n          } else {\n            try {\n              deserialized = deserialize(response.read);\n            } catch (e) {\n              common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n              /* Change status to indicate bad server response. This\n               * will result in passing an error to the callback */\n              status = {\n                code: constants.status.INTERNAL,\n                details: 'Failed to parse server response'\n              };\n            }\n          }\n        }\n        response.metadata =\n          Metadata._fromCoreRepresentation(response.metadata);\n        first_listener.onReceiveMetadata(response.metadata);\n        first_listener.onReceiveMessage(deserialized);\n        first_listener.onReceiveStatus(status);\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state, callback);\n    };\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function(code, details) {\n      call.cancelWithStatus(code, details)\n    };\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for client streaming\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {Interceptor}\n */\nfunction _getClientStreamingInterceptor(method_definition, channel, emitter,\n  callback) {\n  var serialize = common.wrapIgnoreNull(method_definition.requestSerialize);\n  var deserialize = method_definition.responseDeserialize;\n  return function (options) {\n    var first_listener;\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n    final_requester.start = function (metadata, listener) {\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      first_listener = listener;\n      call.startBatch(metadata_batch, function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        listener.onReceiveMetadata(response.metadata);\n      });\n      var recv_batch = {};\n      recv_batch[grpc.opType.RECV_MESSAGE] = true;\n      recv_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n      call.startBatch(recv_batch, function (err, response) {\n        response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n        var status = response.status;\n        var deserialized;\n        if (status.code === constants.status.OK) {\n          if (err) {\n            // Got a batch error, but OK status. Something went wrong\n            callback(err);\n            return;\n          } else {\n            try {\n              deserialized = deserialize(response.read);\n            } catch (e) {\n              common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n              /* Change status to indicate bad server response. This will result\n               * in passing an error to the callback */\n              status = {\n                code: constants.status.INTERNAL,\n                details: 'Failed to parse server response'\n              };\n            }\n          }\n        }\n        listener.onReceiveMessage(deserialized);\n        listener.onReceiveStatus(status);\n      });\n    };\n    final_requester.sendMessage = function (chunk, context) {\n      var message;\n      var callback = (context && context.callback) ?\n        context.callback :\n        function () { };\n      var encoding = (context && context.encoding) ?\n        context.encoding :\n        '';\n      try {\n        message = serialize(chunk);\n      } catch (e) {\n        common.log(constants.logVerbosity.ERROR, `Request serialization failed: ${e.message}`);\n        /* Sending this error to the server and emitting it immediately on the\n           client may put the call in a slightly weird state on the client side,\n           but passing an object that causes a serialization failure is a misuse\n           of the API anyway, so that's OK. The primary purpose here is to give\n           the programmer a useful error and to stop the stream properly */\n        call.cancelWithStatus(constants.status.INTERNAL,\n          'Serialization failure');\n        callback(e);\n        return;\n      }\n      if (Number.isFinite(encoding)) {\n        /* Attach the encoding if it is a finite number. This is the closest we\n         * can get to checking that it is valid flags */\n        message.grpcWriteFlags = encoding;\n      }\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      call.startBatch(batch, function (err, event) {\n        callback(err, event);\n      });\n    };\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      call.startBatch(batch, function () { });\n    };\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function(code, details) {\n      call.cancelWithStatus(code, details)\n    };\n    final_requester.getPeer = function() {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for server streaming\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @return {Interceptor}\n */\nfunction _getServerStreamingInterceptor(method_definition, channel, emitter) {\n  var deserialize = common.wrapIgnoreNull(\n    method_definition.responseDeserialize);\n  var serialize = method_definition.requestSerialize;\n  return function (options) {\n    var batch_state = {\n      completed_ops: [],\n      deferred_batches: []\n    };\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n    var first_listener;\n    var get_listener = function() {\n      return first_listener;\n    };\n    final_requester.start = function(metadata, listener) {\n      first_listener = listener;\n      metadata = metadata.clone();\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      var callback = function(err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n        first_listener.onReceiveMetadata(\n          Metadata._fromCoreRepresentation(response.metadata));\n      };\n      batch_state = _startBatchIfReady(call, metadata_batch, batch_state,\n                                       callback);\n      var status_batch = {\n        [grpc.opType.RECV_STATUS_ON_CLIENT]: true\n      };\n      call.startBatch(status_batch, function(err, response) {\n        if (err) {\n          emitter.emit('error', err);\n          return;\n        }\n        response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n        first_listener.onReceiveStatus(response.status);\n      });\n    };\n    final_requester.sendMessage = function(argument) {\n      var message = serialize(argument);\n      if (options) {\n        message.grpcWriteFlags = options.flags;\n      }\n      var send_batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      var callback = function(err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n      };\n      batch_state = _startBatchIfReady(call, send_batch, batch_state, callback);\n    };\n    final_requester.halfClose = function() {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state, function() {});\n    };\n    final_requester.recvMessageWithContext = function(context) {\n      var recv_batch = {\n        [grpc.opType.RECV_MESSAGE]: true\n      };\n      var callback = _getStreamReadCallback(emitter, call,\n        get_listener, deserialize);\n      batch_state = _startBatchIfReady(call, recv_batch, batch_state, callback);\n    };\n    final_requester.cancel = function() {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function(code, details) {\n      call.cancelWithStatus(code, details)\n    };\n    final_requester.getPeer = function() {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for bi-directional\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @return {Interceptor}\n */\nfunction _getBidiStreamingInterceptor(method_definition, channel, emitter) {\n  var serialize = common.wrapIgnoreNull(method_definition.requestSerialize);\n  var deserialize = common.wrapIgnoreNull(\n    method_definition.responseDeserialize);\n  return function (options) {\n    var first_listener;\n    var get_listener = function() {\n      return first_listener;\n    };\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n    final_requester.start = function (metadata, listener) {\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      first_listener = listener;\n      call.startBatch(metadata_batch, function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        listener.onReceiveMetadata(response.metadata);\n      });\n      var recv_batch = {};\n      recv_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n      call.startBatch(recv_batch, function (err, response) {\n        var status = response.status;\n        if (status.code === constants.status.OK) {\n          if (err) {\n            emitter.emit('error', err);\n            return;\n          }\n        }\n        response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n        listener.onReceiveStatus(status);\n      });\n    };\n    final_requester.sendMessage = function (chunk, context) {\n      var message;\n      var callback = (context && context.callback) ?\n        context.callback :\n        function() {};\n      var encoding = (context && context.encoding) ?\n        context.encoding :\n        '';\n      try {\n        message = serialize(chunk);\n      } catch (e) {\n        common.log(constants.logVerbosity.ERROR, `Request serialization failed: ${e.message}`);\n        /* Sending this error to the server and emitting it immediately on the\n           client may put the call in a slightly weird state on the client side,\n           but passing an object that causes a serialization failure is a misuse\n           of the API anyway, so that's OK. The primary purpose here is to give\n           the programmer a useful error and to stop the stream properly */\n        call.cancelWithStatus(constants.status.INTERNAL,\n          'Serialization failure');\n        callback(e);\n        return;\n      }\n      if (Number.isFinite(encoding)) {\n        /* Attach the encoding if it is a finite number. This is the closest we\n         * can get to checking that it is valid flags */\n        message.grpcWriteFlags = encoding;\n      }\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      call.startBatch(batch, function (err, event) {\n        callback(err, event);\n      });\n    };\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      call.startBatch(batch, function () { });\n    };\n    final_requester.recvMessageWithContext = function(context) {\n      var recv_batch = {\n        [grpc.opType.RECV_MESSAGE]: true\n      };\n      call.startBatch(recv_batch, _getStreamReadCallback(emitter, call,\n        get_listener, deserialize));\n    };\n    final_requester.cancel = function() {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function(code, details) {\n      call.cancelWithStatus(code, details)\n    };\n    final_requester.getPeer = function() {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces a listener for responding to callers of unary RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {grpc~Listener}\n */\nfunction _getUnaryListener(method_definition, emitter, callback) {\n  var resultMessage;\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message) {\n      resultMessage = message;\n    },\n    onReceiveStatus: function (status) {\n      if (status.code !== constants.status.OK) {\n        var error = common.createStatusError(status);\n        callback(error);\n      } else {\n        callback(null, resultMessage);\n      }\n      emitter.emit('status', status);\n    }\n  };\n}\n\n/**\n * Produces a listener for responding to callers of client streaming RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {grpc~Listener}\n */\nfunction _getClientStreamingListener(method_definition, emitter, callback) {\n  var resultMessage;\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message) {\n      resultMessage = message;\n    },\n    onReceiveStatus: function (status) {\n      if (status.code !== constants.status.OK) {\n        var error = common.createStatusError(status);\n        callback(error);\n      } else {\n        callback(null, resultMessage);\n      }\n      emitter.emit('status', status);\n    }\n  };\n}\n\n/**\n * Produces a listener for responding to callers of server streaming RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @return {grpc~Listener}\n */\nfunction _getServerStreamingListener(method_definition, emitter) {\n  var deserialize = common.wrapIgnoreNull(\n    method_definition.responseDeserialize);\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function(message, next, context) {\n      if (emitter.push(message) && message !== null) {\n        var call = context.call;\n        var get_listener = function() {\n          return context.listener;\n        };\n        var read_batch = {};\n        read_batch[grpc.opType.RECV_MESSAGE] = true;\n        call.startBatch(read_batch, _getStreamReadCallback(emitter, call,\n          get_listener, deserialize));\n      } else {\n        emitter.reading = false;\n      }\n    },\n    onReceiveStatus: function (status) {\n      emitter._receiveStatus(status);\n    }\n  };\n}\n\n/**\n * Produces a listener for responding to callers of bi-directional RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @return {grpc~Listener}\n */\nfunction _getBidiStreamingListener(method_definition, emitter) {\n  var deserialize = common.wrapIgnoreNull(\n    method_definition.responseDeserialize);\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function(message, next, context) {\n      if (emitter.push(message) && message !== null) {\n        var call = context.call;\n        var get_listener = function() {\n          return context.listener;\n        };\n        var read_batch = {};\n        read_batch[grpc.opType.RECV_MESSAGE] = true;\n        call.startBatch(read_batch, _getStreamReadCallback(emitter, call,\n          get_listener, deserialize));\n      } else {\n        emitter.reading = false;\n      }\n    },\n    onReceiveStatus: function (status) {\n      emitter._receiveStatus(status);\n    }\n  };\n}\n\nvar interceptorGenerators = {\n  [methodTypes.UNARY]: _getUnaryInterceptor,\n  [methodTypes.CLIENT_STREAMING]: _getClientStreamingInterceptor,\n  [methodTypes.SERVER_STREAMING]: _getServerStreamingInterceptor,\n  [methodTypes.BIDI_STREAMING]: _getBidiStreamingInterceptor\n};\n\nvar listenerGenerators = {\n  [methodTypes.UNARY]: _getUnaryListener,\n  [methodTypes.CLIENT_STREAMING]: _getClientStreamingListener,\n  [methodTypes.SERVER_STREAMING]: _getServerStreamingListener,\n  [methodTypes.BIDI_STREAMING]: _getBidiStreamingListener\n};\n\n/**\n * Creates the last listener in an interceptor stack.\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function=} callback\n * @return {grpc~Listener}\n */\nfunction getLastListener(method_definition, emitter, callback) {\n  if (typeof emitter === 'function') {\n    callback = emitter;\n    callback = function() {};\n  }\n  if (typeof callback !== 'function') {\n    callback = function() {};\n  }\n  if (!((emitter instanceof EventEmitter) &&\n       (typeof callback === 'function'))) {\n    throw new Error('Argument mismatch in getLastListener');\n  }\n  var method_type = common.getMethodType(method_definition);\n  var generator = listenerGenerators[method_type];\n  return generator(method_definition, emitter, callback);\n}\n\n/**\n *\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Client~CallOptions} options\n * @param {Interceptor[]} interceptors\n * @param {grpc.Channel} channel\n * @param {function|EventEmitter} responder\n */\nfunction getInterceptingCall(method_definition, options,\n                             interceptors, channel, responder) {\n  var last_interceptor = _getLastInterceptor(method_definition, channel,\n                                            responder);\n  var all_interceptors = interceptors.concat(last_interceptor);\n  return _buildChain(all_interceptors, options);\n}\n\n/**\n * Creates the last interceptor in an interceptor stack.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {function|EventEmitter} responder\n * @return {Interceptor}\n */\nfunction _getLastInterceptor(method_definition, channel, responder) {\n  var callback = typeof responder === 'function' ? responder : function() {};\n  var emitter = (responder instanceof EventEmitter) ? responder :\n                                                      new EventEmitter();\n  var method_type = common.getMethodType(method_definition);\n  var generator = interceptorGenerators[method_type];\n  return generator(method_definition, channel, emitter, callback);\n}\n\n/**\n * Chain a list of interceptors together and return the first InterceptingCall.\n * @private\n * @param {Interceptor[]} interceptors An interceptor stack.\n * @param {grpc.Client~CallOptions} options Call options.\n * @return {InterceptingCall}\n */\nfunction _buildChain(interceptors, options) {\n  var next = function(interceptors) {\n    if (interceptors.length === 0) {\n      return function (options) {};\n    }\n    var head_interceptor = interceptors[0];\n    var rest_interceptors = interceptors.slice(1);\n    return function (options) {\n      return head_interceptor(options, next(rest_interceptors));\n    };\n  };\n  var chain = next(interceptors)(options);\n  return new InterceptingCall(chain);\n}\n\n/**\n * Wraps a plain listener object in an InterceptingListener if it isn't an\n * InterceptingListener already.\n * @param {InterceptingListener|object|null} current_listener\n * @param {InterceptingListener|EndListener} next_listener\n * @return {InterceptingListener|null}\n * @private\n */\nfunction _getInterceptingListener(current_listener, next_listener) {\n  if (!_isInterceptingListener(current_listener)) {\n    return new InterceptingListener(next_listener, current_listener);\n  }\n  return current_listener;\n}\n\n/**\n * Test if the listener exists and is an InterceptingListener.\n * @param listener\n * @return {boolean}\n * @private\n */\nfunction _isInterceptingListener(listener) {\n  return listener && listener.constructor.name === 'InterceptingListener';\n}\n\nexports.resolveInterceptorProviders = resolveInterceptorProviders;\n\nexports.InterceptingCall = InterceptingCall;\nexports.ListenerBuilder = ListenerBuilder;\nexports.RequesterBuilder = RequesterBuilder;\nexports.StatusBuilder = StatusBuilder;\n\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\n\nexports.getInterceptingCall = getInterceptingCall;\nexports.getLastListener = getLastListener;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAACA,OAAA;AAAAA,OAAA;AAEb,IAAIC,IAAI,GAAGD,OAAO,CAAC,kBAAkB,CAAC;AACtC,IAAIE,QAAQ,GAAGF,OAAO,CAAC,YAAY,CAAC;AACpC,IAAIG,SAAS,GAAGH,OAAO,CAAC,aAAa,CAAC;AACtC,IAAII,MAAM,GAAGJ,OAAO,CAAC,UAAU,CAAC;AAChC,IAAIK,WAAW,GAAGF,SAAS,CAACE,WAAW;AACvC,IAAIC,YAAY,GAAGN,OAAO,CAAC,QAAQ,CAAC,CAACM,YAAY;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,6BAA6B,GAC/B,SAASA,6BAA6BA,CAACC,OAAO,EAAEC,KAAK,EAAE;EACrDC,KAAK,CAACC,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAACC,WAAW,CAAC;EAC/C,IAAI,CAACC,IAAI,GAAG,IAAI,CAACD,WAAW,CAA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}