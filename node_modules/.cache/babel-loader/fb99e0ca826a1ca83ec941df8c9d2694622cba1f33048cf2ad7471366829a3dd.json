{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst filter_1 = require(\"./filter\");\nclass CallCredentialsFilter extends filter_1.BaseFilter {\n  constructor(channel, stream) {\n    super();\n    this.channel = channel;\n    this.stream = stream;\n    this.channel = channel;\n    this.stream = stream;\n    const splitPath = stream.getMethod().split('/');\n    let serviceName = '';\n    /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n     * by '/', the first item should be empty and the second should be the\n     * service name */\n    if (splitPath.length >= 2) {\n      serviceName = splitPath[1];\n    }\n    /* Currently, call credentials are only allowed on HTTPS connections, so we\n     * can assume that the scheme is \"https\" */\n    this.serviceUrl = `https://${stream.getHost()}/${serviceName}`;\n  }\n  async sendMetadata(metadata) {\n    const channelCredentials = this.channel.credentials._getCallCredentials();\n    const streamCredentials = this.stream.getCredentials();\n    const credentials = channelCredentials.compose(streamCredentials);\n    const credsMetadata = credentials.generateMetadata({\n      service_url: this.serviceUrl\n    });\n    const resultMetadata = await metadata;\n    resultMetadata.merge(await credsMetadata);\n    return resultMetadata;\n  }\n}\nexports.CallCredentialsFilter = CallCredentialsFilter;\nclass CallCredentialsFilterFactory {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  createFilter(callStream) {\n    return new CallCredentialsFilter(this.channel, callStream);\n  }\n}\nexports.CallCredentialsFilterFactory = CallCredentialsFilterFactory;","map":{"version":3,"names":["Object","defineProperty","exports","value","filter_1","require","CallCredentialsFilter","BaseFilter","constructor","channel","stream","splitPath","getMethod","split","serviceName","length","serviceUrl","getHost","sendMetadata","metadata","channelCredentials","credentials","_getCallCredentials","streamCredentials","getCredentials","compose","credsMetadata","generateMetadata","service_url","resultMetadata","merge","CallCredentialsFilterFactory","createFilter","callStream"],"sources":["/var/www/html/project/Dash_Vuexy-master/node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst filter_1 = require(\"./filter\");\nclass CallCredentialsFilter extends filter_1.BaseFilter {\n    constructor(channel, stream) {\n        super();\n        this.channel = channel;\n        this.stream = stream;\n        this.channel = channel;\n        this.stream = stream;\n        const splitPath = stream.getMethod().split('/');\n        let serviceName = '';\n        /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n         * by '/', the first item should be empty and the second should be the\n         * service name */\n        if (splitPath.length >= 2) {\n            serviceName = splitPath[1];\n        }\n        /* Currently, call credentials are only allowed on HTTPS connections, so we\n         * can assume that the scheme is \"https\" */\n        this.serviceUrl = `https://${stream.getHost()}/${serviceName}`;\n    }\n    async sendMetadata(metadata) {\n        const channelCredentials = this.channel.credentials._getCallCredentials();\n        const streamCredentials = this.stream.getCredentials();\n        const credentials = channelCredentials.compose(streamCredentials);\n        const credsMetadata = credentials.generateMetadata({ service_url: this.serviceUrl });\n        const resultMetadata = await metadata;\n        resultMetadata.merge(await credsMetadata);\n        return resultMetadata;\n    }\n}\nexports.CallCredentialsFilter = CallCredentialsFilter;\nclass CallCredentialsFilterFactory {\n    constructor(channel) {\n        this.channel = channel;\n    }\n    createFilter(callStream) {\n        return new CallCredentialsFilter(this.channel, callStream);\n    }\n}\nexports.CallCredentialsFilterFactory = CallCredentialsFilterFactory;\n//# sourceMappingURL=call-credentials-filter.js.map"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,MAAMC,QAAQ,GAAGC,OAAO,CAAC,UAAU,CAAC;AACpC,MAAMC,qBAAqB,SAASF,QAAQ,CAACG,UAAU,CAAC;EACpDC,WAAWA,CAACC,OAAO,EAAEC,MAAM,EAAE;IACzB,KAAK,EAAE;IACP,IAAI,CAACD,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACD,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,MAAMC,SAAS,GAAGD,MAAM,CAACE,SAAS,EAAE,CAACC,KAAK,CAAC,GAAG,CAAC;IAC/C,IAAIC,WAAW,GAAG,EAAE;IACpB;AACR;AACA;IACQ,IAAIH,SAAS,CAACI,MAAM,IAAI,CAAC,EAAE;MACvBD,WAAW,GAAGH,SAAS,CAAC,CAAC,CAAC;IAC9B;IACA;AACR;IACQ,IAAI,CAACK,UAAU,GAAI,WAAUN,MAAM,CAACO,OAAO,EAAG,IAAGH,WAAY,EAAC;EAClE;EACA,MAAMI,YAAYA,CAACC,QAAQ,EAAE;IACzB,MAAMC,kBAAkB,GAAG,IAAI,CAACX,OAAO,CAACY,WAAW,CAACC,mBAAmB,EAAE;IACzE,MAAMC,iBAAiB,GAAG,IAAI,CAACb,MAAM,CAACc,cAAc,EAAE;IACtD,MAAMH,WAAW,GAAGD,kBAAkB,CAACK,OAAO,CAACF,iBAAiB,CAAC;IACjE,MAAMG,aAAa,GAAGL,WAAW,CAACM,gBAAgB,CAAC;MAAEC,WAAW,EAAE,IAAI,CAACZ;IAAW,CAAC,CAAC;IACpF,MAAMa,cAAc,GAAG,MAAMV,QAAQ;IACrCU,cAAc,CAACC,KAAK,CAAC,MAAMJ,aAAa,CAAC;IACzC,OAAOG,cAAc;EACzB;AACJ;AACA3B,OAAO,CAACI,qBAAqB,GAAGA,qBAAqB;AACrD,MAAMyB,4BAA4B,CAAC;EAC/BvB,WAAWA,CAACC,OAAO,EAAE;IACjB,IAAI,CAACA,OAAO,GAAGA,OAAO;EAC1B;EACAuB,YAAYA,CAACC,UAAU,EAAE;IACrB,OAAO,IAAI3B,qBAAqB,CAAC,IAAI,CAACG,OAAO,EAAEwB,UAAU,CAAC;EAC9D;AACJ;AACA/B,OAAO,CAAC6B,4BAA4B,GAAGA,4BAA4B"},"metadata":{},"sourceType":"script","externalDependencies":[]}