{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst jws = require(\"jws\");\nconst LRU = require(\"lru-cache\");\nconst messages = require(\"../messages\");\nconst DEFAULT_HEADER = {\n  alg: 'RS256',\n  typ: 'JWT'\n};\nclass JWTAccess {\n  /**\n   * JWTAccess service account credentials.\n   *\n   * Create a new access token by using the credential to create a new JWT token\n   * that's recognized as the access token.\n   *\n   * @param email the service account email address.\n   * @param key the private key that will be used to sign the token.\n   * @param keyId the ID of the private key used to sign the token.\n   */\n  constructor(email, key, keyId) {\n    this.cache = new LRU({\n      max: 500,\n      maxAge: 60 * 60 * 1000\n    });\n    this.email = email;\n    this.key = key;\n    this.keyId = keyId;\n  }\n  /**\n   * Indicates whether the credential requires scopes to be created by calling\n   * createdScoped before use.\n   * @deprecated\n   * @return always false\n   */\n  createScopedRequired() {\n    // JWT Header authentication does not use scopes.\n    messages.warn(messages.JWT_ACCESS_CREATE_SCOPED_DEPRECATED);\n    return false;\n  }\n  /**\n   * Get a non-expired access token, after refreshing if necessary.\n   *\n   * @param authURI The URI being authorized.\n   * @param additionalClaims An object with a set of additional claims to\n   * include in the payload.\n   * @deprecated Please use `getRequestHeaders` instead.\n   * @returns An object that includes the authorization header.\n   */\n  getRequestMetadata(url, additionalClaims) {\n    messages.warn(messages.JWT_ACCESS_GET_REQUEST_METADATA_DEPRECATED);\n    return {\n      headers: this.getRequestHeaders(url, additionalClaims)\n    };\n  }\n  /**\n   * Get a non-expired access token, after refreshing if necessary.\n   *\n   * @param url The URI being authorized.\n   * @param additionalClaims An object with a set of additional claims to\n   * include in the payload.\n   * @returns An object that includes the authorization header.\n   */\n  getRequestHeaders(url, additionalClaims) {\n    const cachedToken = this.cache.get(url);\n    if (cachedToken) {\n      return cachedToken;\n    }\n    const iat = Math.floor(new Date().getTime() / 1000);\n    const exp = iat + 3600; // 3600 seconds = 1 hour\n    // The payload used for signed JWT headers has:\n    // iss == sub == <client email>\n    // aud == <the authorization uri>\n    const defaultClaims = {\n      iss: this.email,\n      sub: this.email,\n      aud: url,\n      exp,\n      iat\n    };\n    // if additionalClaims are provided, ensure they do not collide with\n    // other required claims.\n    if (additionalClaims) {\n      for (const claim in defaultClaims) {\n        if (additionalClaims[claim]) {\n          throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);\n        }\n      }\n    }\n    const header = this.keyId ? Object.assign({}, DEFAULT_HEADER, {\n      kid: this.keyId\n    }) : DEFAULT_HEADER;\n    const payload = Object.assign(defaultClaims, additionalClaims);\n    // Sign the jwt and add it to the cache\n    const signedJWT = jws.sign({\n      header,\n      payload,\n      secret: this.key\n    });\n    const headers = {\n      Authorization: `Bearer ${signedJWT}`\n    };\n    this.cache.set(url, headers);\n    return headers;\n  }\n  /**\n   * Create a JWTAccess credentials instance using the given input options.\n   * @param json The input object.\n   */\n  fromJSON(json) {\n    if (!json) {\n      throw new Error('Must pass in a JSON object containing the service account auth settings.');\n    }\n    if (!json.client_email) {\n      throw new Error('The incoming JSON object does not contain a client_email field');\n    }\n    if (!json.private_key) {\n      throw new Error('The incoming JSON object does not contain a private_key field');\n    }\n    // Extract the relevant information from the json key file.\n    this.email = json.client_email;\n    this.key = json.private_key;\n    this.keyId = json.private_key_id;\n    this.projectId = json.project_id;\n  }\n  fromStream(inputStream, callback) {\n    if (callback) {\n      this.fromStreamAsync(inputStream).then(r => callback(), callback);\n    } else {\n      return this.fromStreamAsync(inputStream);\n    }\n  }\n  fromStreamAsync(inputStream) {\n    return new Promise((resolve, reject) => {\n      if (!inputStream) {\n        reject(new Error('Must pass in a stream containing the service account auth settings.'));\n      }\n      let s = '';\n      inputStream.setEncoding('utf8').on('data', chunk => s += chunk).on('error', reject).on('end', () => {\n        try {\n          const data = JSON.parse(s);\n          this.fromJSON(data);\n          resolve();\n        } catch (err) {\n          reject(err);\n        }\n      });\n    });\n  }\n}\nexports.JWTAccess = JWTAccess;","map":{"version":3,"names":["Object","defineProperty","exports","value","jws","require","LRU","messages","DEFAULT_HEADER","alg","typ","JWTAccess","constructor","email","key","keyId","cache","max","maxAge","createScopedRequired","warn","JWT_ACCESS_CREATE_SCOPED_DEPRECATED","getRequestMetadata","url","additionalClaims","JWT_ACCESS_GET_REQUEST_METADATA_DEPRECATED","headers","getRequestHeaders","cachedToken","get","iat","Math","floor","Date","getTime","exp","defaultClaims","iss","sub","aud","claim","Error","header","assign","kid","payload","signedJWT","sign","secret","Authorization","set","fromJSON","json","client_email","private_key","private_key_id","projectId","project_id","fromStream","inputStream","callback","fromStreamAsync","then","r","Promise","resolve","reject","s","setEncoding","on","chunk","data","JSON","parse","err"],"sources":["/var/www/html/project/Dash_Vuexy-master/node_modules/google-auth-library/build/src/auth/jwtaccess.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst jws = require(\"jws\");\nconst LRU = require(\"lru-cache\");\nconst messages = require(\"../messages\");\nconst DEFAULT_HEADER = {\n    alg: 'RS256',\n    typ: 'JWT'\n};\nclass JWTAccess {\n    /**\n     * JWTAccess service account credentials.\n     *\n     * Create a new access token by using the credential to create a new JWT token\n     * that's recognized as the access token.\n     *\n     * @param email the service account email address.\n     * @param key the private key that will be used to sign the token.\n     * @param keyId the ID of the private key used to sign the token.\n     */\n    constructor(email, key, keyId) {\n        this.cache = new LRU({ max: 500, maxAge: 60 * 60 * 1000 });\n        this.email = email;\n        this.key = key;\n        this.keyId = keyId;\n    }\n    /**\n     * Indicates whether the credential requires scopes to be created by calling\n     * createdScoped before use.\n     * @deprecated\n     * @return always false\n     */\n    createScopedRequired() {\n        // JWT Header authentication does not use scopes.\n        messages.warn(messages.JWT_ACCESS_CREATE_SCOPED_DEPRECATED);\n        return false;\n    }\n    /**\n     * Get a non-expired access token, after refreshing if necessary.\n     *\n     * @param authURI The URI being authorized.\n     * @param additionalClaims An object with a set of additional claims to\n     * include in the payload.\n     * @deprecated Please use `getRequestHeaders` instead.\n     * @returns An object that includes the authorization header.\n     */\n    getRequestMetadata(url, additionalClaims) {\n        messages.warn(messages.JWT_ACCESS_GET_REQUEST_METADATA_DEPRECATED);\n        return { headers: this.getRequestHeaders(url, additionalClaims) };\n    }\n    /**\n     * Get a non-expired access token, after refreshing if necessary.\n     *\n     * @param url The URI being authorized.\n     * @param additionalClaims An object with a set of additional claims to\n     * include in the payload.\n     * @returns An object that includes the authorization header.\n     */\n    getRequestHeaders(url, additionalClaims) {\n        const cachedToken = this.cache.get(url);\n        if (cachedToken) {\n            return cachedToken;\n        }\n        const iat = Math.floor(new Date().getTime() / 1000);\n        const exp = iat + 3600; // 3600 seconds = 1 hour\n        // The payload used for signed JWT headers has:\n        // iss == sub == <client email>\n        // aud == <the authorization uri>\n        const defaultClaims = { iss: this.email, sub: this.email, aud: url, exp, iat };\n        // if additionalClaims are provided, ensure they do not collide with\n        // other required claims.\n        if (additionalClaims) {\n            for (const claim in defaultClaims) {\n                if (additionalClaims[claim]) {\n                    throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);\n                }\n            }\n        }\n        const header = this.keyId ? Object.assign({}, DEFAULT_HEADER, { kid: this.keyId }) : DEFAULT_HEADER;\n        const payload = Object.assign(defaultClaims, additionalClaims);\n        // Sign the jwt and add it to the cache\n        const signedJWT = jws.sign({ header, payload, secret: this.key });\n        const headers = { Authorization: `Bearer ${signedJWT}` };\n        this.cache.set(url, headers);\n        return headers;\n    }\n    /**\n     * Create a JWTAccess credentials instance using the given input options.\n     * @param json The input object.\n     */\n    fromJSON(json) {\n        if (!json) {\n            throw new Error('Must pass in a JSON object containing the service account auth settings.');\n        }\n        if (!json.client_email) {\n            throw new Error('The incoming JSON object does not contain a client_email field');\n        }\n        if (!json.private_key) {\n            throw new Error('The incoming JSON object does not contain a private_key field');\n        }\n        // Extract the relevant information from the json key file.\n        this.email = json.client_email;\n        this.key = json.private_key;\n        this.keyId = json.private_key_id;\n        this.projectId = json.project_id;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(r => callback(), callback);\n        }\n        else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject) => {\n            if (!inputStream) {\n                reject(new Error('Must pass in a stream containing the service account auth settings.'));\n            }\n            let s = '';\n            inputStream.setEncoding('utf8')\n                .on('data', (chunk) => s += chunk)\n                .on('error', reject)\n                .on('end', () => {\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    resolve();\n                }\n                catch (err) {\n                    reject(err);\n                }\n            });\n        });\n    }\n}\nexports.JWTAccess = JWTAccess;\n//# sourceMappingURL=jwtaccess.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}