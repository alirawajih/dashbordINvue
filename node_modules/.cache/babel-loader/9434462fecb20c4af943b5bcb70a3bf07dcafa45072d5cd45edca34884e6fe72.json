{"ast":null,"code":"/**\n * @license\n * Copyright 2016 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * @module\n * @private\n */\n\n'use strict';\n\nvar binary = require('@mapbox/node-pre-gyp/lib/pre-binding');\nvar path = require('path');\nvar binding_path = binary.find(path.resolve(path.join(__dirname, '../package.json')));\nvar binding;\ntry {\n  binding = require(binding_path);\n} catch (e) {\n  let fs = require('fs');\n  let searchPath = path.dirname(path.dirname(binding_path));\n  let searchName = path.basename(path.dirname(binding_path));\n  let foundNames;\n  try {\n    foundNames = fs.readdirSync(searchPath);\n  } catch (readDirError) {\n    let message = `The gRPC binary module was not installed. This may be fixed by running \"npm rebuild\"\nOriginal error: ${e.message}`;\n    let error = new Error(message);\n    error.code = e.code;\n    throw error;\n  }\n  if (foundNames.indexOf(searchName) === -1) {\n    let message = `Failed to load gRPC binary module because it was not installed for the current system\nExpected directory: ${searchName}\nFound: [${foundNames.join(', ')}]\nThis problem can often be fixed by running \"npm rebuild\" on the current system\nOriginal error: ${e.message}`;\n    let error = new Error(message);\n    error.code = e.code;\n    throw error;\n  } else {\n    e.message = `Failed to load ${binding_path}. ${e.message}`;\n    throw e;\n  }\n}\nmodule.exports = binding;","map":{"version":3,"names":["binary","require","path","binding_path","find","resolve","join","__dirname","binding","e","fs","searchPath","dirname","searchName","basename","foundNames","readdirSync","readDirError","message","error","Error","code","indexOf","module","exports"],"sources":["/var/www/html/project/Dash_Vuexy-master/node_modules/grpc/src/grpc_extension.js"],"sourcesContent":["/**\n * @license\n * Copyright 2016 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * @module\n * @private\n */\n\n'use strict';\n\nvar binary = require('@mapbox/node-pre-gyp/lib/pre-binding');\nvar path = require('path');\nvar binding_path =\n    binary.find(path.resolve(path.join(__dirname, '../package.json')));\nvar binding;\ntry {\n  binding = require(binding_path);\n} catch (e) {\n  let fs = require('fs');\n  let searchPath = path.dirname(path.dirname(binding_path));\n  let searchName = path.basename(path.dirname(binding_path));\n  let foundNames;\n  try {\n    foundNames = fs.readdirSync(searchPath);\n  } catch (readDirError) {\n    let message = `The gRPC binary module was not installed. This may be fixed by running \"npm rebuild\"\nOriginal error: ${e.message}`;\n    let error = new Error(message);\n    error.code = e.code;\n    throw error;\n  }\n  if (foundNames.indexOf(searchName) === -1) {\n    let message = `Failed to load gRPC binary module because it was not installed for the current system\nExpected directory: ${searchName}\nFound: [${foundNames.join(', ')}]\nThis problem can often be fixed by running \"npm rebuild\" on the current system\nOriginal error: ${e.message}`;\n    let error = new Error(message);\n    error.code = e.code;\n    throw error;\n  } else {\n    e.message = `Failed to load ${binding_path}. ${e.message}`;\n    throw e;\n  }\n}\n\nmodule.exports = binding;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,sCAAsC,CAAC;AAC5D,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC1B,IAAIE,YAAY,GACZH,MAAM,CAACI,IAAI,CAACF,IAAI,CAACG,OAAO,CAACH,IAAI,CAACI,IAAI,CAACC,SAAS,EAAE,iBAAiB,CAAC,CAAC,CAAC;AACtE,IAAIC,OAAO;AACX,IAAI;EACFA,OAAO,GAAGP,OAAO,CAACE,YAAY,CAAC;AACjC,CAAC,CAAC,OAAOM,CAAC,EAAE;EACV,IAAIC,EAAE,GAAGT,OAAO,CAAC,IAAI,CAAC;EACtB,IAAIU,UAAU,GAAGT,IAAI,CAACU,OAAO,CAACV,IAAI,CAACU,OAAO,CAACT,YAAY,CAAC,CAAC;EACzD,IAAIU,UAAU,GAAGX,IAAI,CAACY,QAAQ,CAACZ,IAAI,CAACU,OAAO,CAACT,YAAY,CAAC,CAAC;EAC1D,IAAIY,UAAU;EACd,IAAI;IACFA,UAAU,GAAGL,EAAE,CAACM,WAAW,CAACL,UAAU,CAAC;EACzC,CAAC,CAAC,OAAOM,YAAY,EAAE;IACrB,IAAIC,OAAO,GAAI;AACnB,kBAAkBT,CAAC,CAACS,OAAQ,EAAC;IACzB,IAAIC,KAAK,GAAG,IAAIC,KAAK,CAACF,OAAO,CAAC;IAC9BC,KAAK,CAACE,IAAI,GAAGZ,CAAC,CAACY,IAAI;IACnB,MAAMF,KAAK;EACb;EACA,IAAIJ,UAAU,CAACO,OAAO,CAACT,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE;IACzC,IAAIK,OAAO,GAAI;AACnB,sBAAsBL,UAAW;AACjC,UAAUE,UAAU,CAACT,IAAI,CAAC,IAAI,CAAE;AAChC;AACA,kBAAkBG,CAAC,CAACS,OAAQ,EAAC;IACzB,IAAIC,KAAK,GAAG,IAAIC,KAAK,CAACF,OAAO,CAAC;IAC9BC,KAAK,CAACE,IAAI,GAAGZ,CAAC,CAACY,IAAI;IACnB,MAAMF,KAAK;EACb,CAAC,MAAM;IACLV,CAAC,CAACS,OAAO,GAAI,kBAAiBf,YAAa,KAAIM,CAAC,CAACS,OAAQ,EAAC;IAC1D,MAAMT,CAAC;EACT;AACF;AAEAc,MAAM,CAACC,OAAO,GAAGhB,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}