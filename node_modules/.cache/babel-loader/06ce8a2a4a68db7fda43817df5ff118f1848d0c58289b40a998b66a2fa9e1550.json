{"ast":null,"code":"/**\n * @license\n * Copyright 2015 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * Client module\n *\n * This module contains the factory method for creating Client classes, and the\n * method calling code for all types of methods.\n *\n * @example <caption>Create a client and call a method on it</caption>\n *\n * var proto_obj = grpc.load(proto_file_path);\n * var Client = proto_obj.package.subpackage.ServiceName;\n * var client = new Client(server_address, client_credentials);\n * var call = client.unaryMethod(arguments, callback);\n */\n\n'use strict';\n\nrequire(\"core-js/modules/web.immediate.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nvar client_interceptors = require('./client_interceptors');\nvar grpc = require('./grpc_extension');\nvar common = require('./common');\nvar Metadata = require('./metadata');\nvar constants = require('./constants');\nvar EventEmitter = require('events').EventEmitter;\nvar stream = require('stream');\nvar Readable = stream.Readable;\nvar Writable = stream.Writable;\nvar Duplex = stream.Duplex;\nvar methodTypes = constants.methodTypes;\nvar util = require('util');\nvar version = require('../package.json').version;\n\n/**\n * Initial response metadata sent by the server when it starts processing the\n * call\n * @event grpc~ClientUnaryCall#metadata\n * @type {grpc.Metadata}\n */\n\n/**\n * Status of the call when it has completed.\n * @event grpc~ClientUnaryCall#status\n * @type grpc~StatusObject\n */\n\nutil.inherits(ClientUnaryCall, EventEmitter);\n\n/**\n * An EventEmitter. Used for unary calls.\n * @constructor grpc~ClientUnaryCall\n * @extends external:EventEmitter\n * @param {grpc.internal~Call} call The call object associated with the request\n */\nfunction ClientUnaryCall(call) {\n  EventEmitter.call(this);\n  this.call = call;\n}\nutil.inherits(ClientWritableStream, Writable);\n\n/**\n * A stream that the client can write to. Used for calls that are streaming from\n * the client side.\n * @constructor grpc~ClientWritableStream\n * @extends external:Writable\n * @borrows grpc~ClientUnaryCall#cancel as grpc~ClientWritableStream#cancel\n * @borrows grpc~ClientUnaryCall#getPeer as grpc~ClientWritableStream#getPeer\n * @borrows grpc~ClientUnaryCall#event:metadata as\n *     grpc~ClientWritableStream#metadata\n * @borrows grpc~ClientUnaryCall#event:status as\n *     grpc~ClientWritableStream#status\n * @param {InterceptingCall} call Exposes gRPC request operations, processed by\n *     an interceptor stack.\n */\nfunction ClientWritableStream(call) {\n  Writable.call(this, {\n    objectMode: true\n  });\n  this.call = call;\n  var self = this;\n  this.on('finish', function () {\n    self.call.halfClose();\n  });\n}\n\n/**\n * Write a message to the request stream. If serializing the argument fails,\n * the call will be cancelled and the stream will end with an error.\n * @name grpc~ClientWritableStream#write\n * @kind function\n * @override\n * @param {*} message The message to write. Must be a valid argument to the\n *     serialize function of the corresponding method\n * @param {grpc.writeFlags} flags Flags to modify how the message is written\n * @param {Function} callback Callback for when this chunk of data is flushed\n * @return {boolean} As defined for [Writable]{@link external:Writable}\n */\n\n/**\n * Attempt to write the given chunk. Calls the callback when done. This is an\n * implementation of a method needed for implementing stream.Writable.\n * @private\n * @param {*} chunk The chunk to write\n * @param {grpc.writeFlags} encoding Used to pass write flags\n * @param {function(Error=)} callback Called when the write is complete\n */\nfunction _write(chunk, encoding, callback) {\n  /* jshint validthis: true */\n  var self = this;\n  if (this.writeFailed) {\n    /* Once a write fails, just call the callback immediately to let the caller\n       flush any pending writes. */\n    setImmediate(callback);\n    return;\n  }\n  var outerCallback = function (err, event) {\n    if (err) {\n      /* Assume that the call is complete and that writing failed because a\n         status was received. In that case, set a flag to discard all future\n         writes */\n      self.writeFailed = true;\n    }\n    callback();\n  };\n  var context = {\n    encoding: encoding,\n    callback: outerCallback\n  };\n  this.call.sendMessageWithContext(context, chunk);\n}\nClientWritableStream.prototype._write = _write;\nutil.inherits(ClientReadableStream, Readable);\n\n/**\n * A stream that the client can read from. Used for calls that are streaming\n * from the server side.\n * @constructor grpc~ClientReadableStream\n * @extends external:Readable\n * @borrows grpc~ClientUnaryCall#cancel as grpc~ClientReadableStream#cancel\n * @borrows grpc~ClientUnaryCall#getPeer as grpc~ClientReadableStream#getPeer\n * @borrows grpc~ClientUnaryCall#event:metadata as\n *     grpc~ClientReadableStream#metadata\n * @borrows grpc~ClientUnaryCall#event:status as\n *     grpc~ClientReadableStream#status\n * @param {InterceptingCall} call Exposes gRPC request operations, processed by\n *     an interceptor stack.\n */\nfunction ClientReadableStream(call) {\n  Readable.call(this, {\n    objectMode: true\n  });\n  this.call = call;\n  this.finished = false;\n  this.reading = false;\n  /* Status generated from reading messages from the server. Overrides the\n   * status from the server if not OK */\n  this.read_status = null;\n  /* Status received from the server. */\n  this.received_status = null;\n}\n\n/**\n * Called when all messages from the server have been processed. The status\n * parameter indicates that the call should end with that status. status\n * defaults to OK if not provided.\n * @param {Object!} status The status that the call should end with\n * @private\n */\nfunction _readsDone(status) {\n  /* jshint validthis: true */\n  if (!status) {\n    status = {\n      code: constants.status.OK,\n      details: 'OK'\n    };\n  }\n  if (status.code !== constants.status.OK) {\n    this.call.cancelWithStatus(status.code, status.details);\n  }\n  this.finished = true;\n  this.read_status = status;\n  this._emitStatusIfDone();\n}\nClientReadableStream.prototype._readsDone = _readsDone;\n\n/**\n * Called to indicate that we have received a status from the server.\n * @private\n */\nfunction _receiveStatus(status) {\n  /* jshint validthis: true */\n  this.received_status = status;\n  this._emitStatusIfDone();\n}\nClientReadableStream.prototype._receiveStatus = _receiveStatus;\n\n/**\n * If we have both processed all incoming messages and received the status from\n * the server, emit the status. Otherwise, do nothing.\n * @private\n */\nfunction _emitStatusIfDone() {\n  /* jshint validthis: true */\n  var status;\n  if (this.read_status && this.received_status) {\n    if (this.read_status.code !== constants.status.OK) {\n      status = this.read_status;\n    } else {\n      status = this.received_status;\n    }\n    if (status.code === constants.status.OK) {\n      this.push(null);\n    } else {\n      var error = common.createStatusError(status);\n      this.emit('error', error);\n    }\n    this.emit('status', status);\n  }\n}\nClientReadableStream.prototype._emitStatusIfDone = _emitStatusIfDone;\n\n/**\n * Read the next object from the stream.\n * @private\n * @param {*} size Ignored because we use objectMode=true\n */\nfunction _read(size) {\n  /* jshint validthis: true */\n  if (this.finished) {\n    this.push(null);\n  } else {\n    if (!this.reading) {\n      this.reading = true;\n      var context = {\n        stream: this\n      };\n      this.call.recvMessageWithContext(context);\n    }\n  }\n}\nClientReadableStream.prototype._read = _read;\nutil.inherits(ClientDuplexStream, Duplex);\n\n/**\n * A stream that the client can read from or write to. Used for calls with\n * duplex streaming.\n * @constructor grpc~ClientDuplexStream\n * @extends external:Duplex\n * @borrows grpc~ClientUnaryCall#cancel as grpc~ClientDuplexStream#cancel\n * @borrows grpc~ClientUnaryCall#getPeer as grpc~ClientDuplexStream#getPeer\n * @borrows grpc~ClientWritableStream#write as grpc~ClientDuplexStream#write\n * @borrows grpc~ClientUnaryCall#event:metadata as\n *     grpc~ClientDuplexStream#metadata\n * @borrows grpc~ClientUnaryCall#event:status as\n *     grpc~ClientDuplexStream#status\n * @param {InterceptingCall} call Exposes gRPC request operations, processed by\n *     an interceptor stack.\n */\nfunction ClientDuplexStream(call) {\n  Duplex.call(this, {\n    objectMode: true\n  });\n  this.call = call;\n  /* Status generated from reading messages from the server. Overrides the\n   * status from the server if not OK */\n  this.read_status = null;\n  /* Status received from the server. */\n  this.received_status = null;\n  var self = this;\n  this.on('finish', function () {\n    self.call.halfClose();\n  });\n}\nClientDuplexStream.prototype._readsDone = _readsDone;\nClientDuplexStream.prototype._receiveStatus = _receiveStatus;\nClientDuplexStream.prototype._emitStatusIfDone = _emitStatusIfDone;\nClientDuplexStream.prototype._read = _read;\nClientDuplexStream.prototype._write = _write;\n\n/**\n * Cancel the ongoing call. Results in the call ending with a CANCELLED status,\n * unless it has already ended with some other status.\n * @alias grpc~ClientUnaryCall#cancel\n */\nfunction cancel() {\n  /* jshint validthis: true */\n  this.call.cancel();\n}\nClientUnaryCall.prototype.cancel = cancel;\nClientReadableStream.prototype.cancel = cancel;\nClientWritableStream.prototype.cancel = cancel;\nClientDuplexStream.prototype.cancel = cancel;\n\n/**\n * Get the endpoint this call/stream is connected to.\n * @return {string} The URI of the endpoint\n * @alias grpc~ClientUnaryCall#getPeer\n */\nfunction getPeer() {\n  /* jshint validthis: true */\n  return this.call.getPeer();\n}\nClientUnaryCall.prototype.getPeer = getPeer;\nClientReadableStream.prototype.getPeer = getPeer;\nClientWritableStream.prototype.getPeer = getPeer;\nClientDuplexStream.prototype.getPeer = getPeer;\n\n/**\n * Any client call type\n * @typedef {(grpc~ClientUnaryCall|grpc~ClientReadableStream|\n *            grpc~ClientWritableStream|grpc~ClientDuplexStream)}\n *     grpc.Client~Call\n */\n\n/**\n * Options that can be set on a call.\n * @typedef {Object} grpc.Client~CallOptions\n * @property {grpc~Deadline} deadline The deadline for the entire call to\n *     complete.\n * @property {string} host Server hostname to set on the call. Only meaningful\n *     if different from the server address used to construct the client.\n * @property {grpc.Client~Call} parent Parent call. Used in servers when\n *     making a call as part of the process of handling a call. Used to\n *     propagate some information automatically, as specified by\n *     propagate_flags.\n * @property {number} propagate_flags Indicates which properties of a parent\n *     call should propagate to this call. Bitwise combination of flags in\n *     {@link grpc.propagate}.\n * @property {grpc.credentials~CallCredentials} credentials The credentials that\n *     should be used to make this particular call.\n */\n\n/**\n * Properties of a call, for use with a {@link grpc.Client~callInvocationTransformer}.\n * @typedef {Object} grpc.Client~CallProperties\n * @property {*} argument The call argument. Only preset if the method is unary or server streaming.\n * @property {grpc.Metadata} metadata The request metadata\n * @property {grpc~Call} call The call object that will be returned by the client method\n * @property {grpc.Channel} channel The channel that will be used to make a request\n * @property {grpc~MethodDefinition} methodDefinition The MethodDefinition object that describes this method\n * @property {grpc.Client~CallOptions} options The call options passed when making this request\n * @property {grpc.Client~requestCallback} callback The callback that will handle the response.\n *     Only present if this method is unary or client streaming.\n */\n\n/**\n * Call invocation transformer. Has access to the full call properties before a\n * call is processed and can modify most of those properties. Some modifications\n * will have no effect or may cause problems.\n * @name grpc.Client~callInvocationTransformer\n * @function\n * @param {grpc.Client~CallProperties} callProperties The original call properties\n * @return {grpc.Client~CallProperties} The modified call properties.\n */\n\n/**\n * A function that functionally replaces the Channel constructor.\n * @name grpc.Client~channelFactory\n * @function\n * @param {string} target The address of the server to connect to\n * @param {grpc.ChannelCredentials} credentials Channel credentials to use when connecting\n * @param {grpc~ChannelOptions} options A map of channel options that will be passed to the core.\n *     The available options are listed in\n *     [this document]{@link https://grpc.github.io/grpc/core/group__grpc__arg__keys.html}.\n * @returns {grpc.Channel} This can either be an actual channel object, or an object with the\n *     same API.\n */\n\n/**\n * A generic gRPC client. Primarily useful as a base class for generated clients\n * @memberof grpc\n * @constructor\n * @param {string} address Server address to connect to\n * @param {grpc.credentials~ChannelCredentials} credentials Credentials to use\n *     to connect to the server\n * @param {Object} options Options to apply to channel creation. Any of\n *     [the channel arguments]{@link https://grpc.github.io/grpc/core/group__grpc__arg__keys.html}\n *     can be used here in addition to specific client options.\n * @param {grpc~Interceptor[]} [options.interceptors] Interceptors to apply to each request\n * @param {grpc~InterceptorProvider[]} [options.interceptor_providers] Interceptor providers\n *     to apply interceptors to each request depending on the method definition. At most\n *     one of the interceptors and interceptor_providers options may be set.\n * @param {grpc.Client~callInvocationTransformer=} options.callInvocationTransformer\n * @param {grpc.Channel=} options.channelOverride Channel to use instead of constructing a new one.\n *     If set, the address, credentials, channel arguments options, and channelFactoryOverride\n *     option will all be ignored.\n * @param {grpc.Client~channelFactory} options.channelFactoryOverride Function to use instead of\n *     the Channel constructor when creating the Client's channel.\n */\nfunction Client(address, credentials, options) {\n  var self = this;\n  if (!options) {\n    options = {};\n  }\n\n  // Resolve interceptor options and assign interceptors to each method\n  if (Array.isArray(options.interceptor_providers) && Array.isArray(options.interceptors)) {\n    throw new client_interceptors.InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n  }\n  self.$interceptors = options.interceptors || [];\n  self.$interceptor_providers = options.interceptor_providers || [];\n  if (self.$method_definitions) {\n    Object.keys(self.$method_definitions).forEach(method_name => {\n      const method_definition = self.$method_definitions[method_name];\n      self[method_name].interceptors = client_interceptors.resolveInterceptorProviders(self.$interceptor_providers, method_definition).concat(self.$interceptors);\n    });\n  }\n  this.$callInvocationTransformer = options.callInvocationTransformer;\n  let channelOverride = options.channelOverride;\n  let channelFactoryOverride = options.channelFactoryOverride;\n  // Exclude channel options which have already been consumed\n  const ignoredKeys = ['interceptors', 'interceptor_providers', 'channelOverride', 'channelFactoryOverride', 'callInvocationTransformer'];\n  var channel_options = Object.getOwnPropertyNames(options).reduce((acc, key) => {\n    if (ignoredKeys.indexOf(key) === -1) {\n      acc[key] = options[key];\n    }\n    return acc;\n  }, {});\n  /* Private fields use $ as a prefix instead of _ because it is an invalid\n   * prefix of a method name */\n  if (channelOverride) {\n    this.$channel = options.channelOverride;\n  } else {\n    if (channelFactoryOverride) {\n      this.$channel = channelFactoryOverride(address, credentials, channel_options);\n    } else {\n      this.$channel = new grpc.Channel(address, credentials, channel_options);\n    }\n  }\n}\nexports.Client = Client;\nClient.prototype.resolveCallInterceptors = function (method_definition, interceptors, interceptor_providers) {\n  if (Array.isArray(interceptors) && Array.isArray(interceptor_providers)) {\n    throw new client_interceptors.InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' + 'options. Only one of these is allowed.');\n  }\n  if (Array.isArray(interceptors) || Array.isArray(interceptor_providers)) {\n    interceptors = interceptors || [];\n    interceptor_providers = interceptor_providers || [];\n    return client_interceptors.resolveInterceptorProviders(interceptor_providers, method_definition).concat(interceptors);\n  } else {\n    return client_interceptors.resolveInterceptorProviders(this.$interceptor_providers, method_definition).concat(this.$interceptors);\n  }\n};\n\n/**\n * @callback grpc.Client~requestCallback\n * @param {?grpc~ServiceError} error The error, if the call\n *     failed\n * @param {*} value The response value, if the call succeeded\n */\n\n/**\n * Make a unary request to the given method, using the given serialize\n * and deserialize functions, with the given argument.\n * @param {string} path The path of the method to request\n * @param {grpc~serialize} serialize The serialization function for\n *     inputs\n * @param {grpc~deserialize} deserialize The deserialization\n *     function for outputs\n * @param {*} argument The argument to the call. Should be serializable with\n *     serialize\n * @param {grpc.Metadata=} metadata Metadata to add to the call\n * @param {grpc.Client~CallOptions=} options Options map\n * @param {grpc.Client~requestCallback} callback The callback\n *     for when the response is received\n * @return {grpc~ClientUnaryCall} An event emitter for stream related events\n */\nClient.prototype.makeUnaryRequest = function (path, serialize, deserialize, argument, metadata, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    if (metadata instanceof Metadata) {\n      options = {};\n    } else {\n      options = metadata;\n      metadata = new Metadata();\n    }\n  } else if (typeof metadata === 'function') {\n    callback = metadata;\n    metadata = new Metadata();\n    options = {};\n  }\n  if (!metadata) {\n    metadata = new Metadata();\n  }\n  if (!options) {\n    options = {};\n  }\n  if (!(metadata instanceof Metadata && options instanceof Object && typeof callback === 'function')) {\n    throw new Error('Argument mismatch in makeUnaryRequest');\n  }\n  var method_definition = options.method_definition = {\n    path: path,\n    requestStream: false,\n    responseStream: false,\n    requestSerialize: serialize,\n    responseDeserialize: deserialize\n  };\n  metadata = metadata.clone();\n  var callProperties = {\n    argument: argument,\n    metadata: metadata,\n    call: new ClientUnaryCall(),\n    channel: this.$channel,\n    methodDefinition: method_definition,\n    callOptions: options,\n    callback: callback\n  };\n\n  // Transform call properties if specified.\n  if (this.$callInvocationTransformer) {\n    callProperties = this.$callInvocationTransformer(callProperties);\n  }\n  var callOptions = callProperties.callOptions;\n  var methodDefinition = callProperties.methodDefinition;\n  var interceptors = Client.prototype.resolveCallInterceptors.call(this, methodDefinition, callOptions.interceptors, callOptions.interceptor_providers);\n  var intercepting_call = client_interceptors.getInterceptingCall(methodDefinition, callOptions, interceptors, callProperties.channel, callProperties.callback);\n  var emitter = callProperties.call;\n  emitter.call = intercepting_call;\n  var last_listener = client_interceptors.getLastListener(methodDefinition, emitter, callProperties.callback);\n  intercepting_call.start(callProperties.metadata, last_listener);\n  intercepting_call.sendMessage(callProperties.argument);\n  intercepting_call.halfClose();\n  return emitter;\n};\n\n/**\n * Make a client stream request to the given method, using the given serialize\n * and deserialize functions, with the given argument.\n * @param {string} path The path of the method to request\n * @param {grpc~serialize} serialize The serialization function for\n *     inputs\n * @param {grpc~deserialize} deserialize The deserialization\n *     function for outputs\n * @param {grpc.Metadata=} metadata Array of metadata key/value pairs to add to\n *     the call\n * @param {grpc.Client~CallOptions=} options Options map\n * @param {grpc.Client~requestCallback} callback The callback for when the\n *     response is received\n * @return {grpc~ClientWritableStream} An event emitter for stream related\n *     events\n */\nClient.prototype.makeClientStreamRequest = function (path, serialize, deserialize, metadata, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    if (metadata instanceof Metadata) {\n      options = {};\n    } else {\n      options = metadata;\n      metadata = new Metadata();\n    }\n  } else if (typeof metadata === 'function') {\n    callback = metadata;\n    metadata = new Metadata();\n    options = {};\n  }\n  if (!metadata) {\n    metadata = new Metadata();\n  }\n  if (!options) {\n    options = {};\n  }\n  if (!(metadata instanceof Metadata && options instanceof Object && typeof callback === 'function')) {\n    throw new Error('Argument mismatch in makeClientStreamRequest');\n  }\n  var method_definition = options.method_definition = {\n    path: path,\n    requestStream: true,\n    responseStream: false,\n    requestSerialize: serialize,\n    responseDeserialize: deserialize\n  };\n  metadata = metadata.clone();\n  var callProperties = {\n    metadata: metadata,\n    call: new ClientWritableStream(),\n    channel: this.$channel,\n    methodDefinition: method_definition,\n    callOptions: options,\n    callback: callback\n  };\n\n  // Transform call properties if specified.\n  if (this.$callInvocationTransformer) {\n    callProperties = this.$callInvocationTransformer(callProperties);\n  }\n  var callOptions = callProperties.callOptions;\n  var methodDefinition = callProperties.methodDefinition;\n  var interceptors = Client.prototype.resolveCallInterceptors.call(this, methodDefinition, callOptions.interceptors, callOptions.interceptor_providers);\n  var intercepting_call = client_interceptors.getInterceptingCall(methodDefinition, callOptions, interceptors, callProperties.channel, callProperties.callback);\n  var emitter = callProperties.call;\n  emitter.call = intercepting_call;\n  var last_listener = client_interceptors.getLastListener(methodDefinition, emitter, callProperties.callback);\n  intercepting_call.start(callProperties.metadata, last_listener);\n  return emitter;\n};\n\n/**\n * Make a server stream request to the given method, with the given serialize\n * and deserialize function, using the given argument\n * @param {string} path The path of the method to request\n * @param {grpc~serialize} serialize The serialization function for inputs\n * @param {grpc~deserialize} deserialize The deserialization\n *     function for outputs\n * @param {*} argument The argument to the call. Should be serializable with\n *     serialize\n * @param {grpc.Metadata=} metadata Array of metadata key/value pairs to add to\n *     the call\n * @param {grpc.Client~CallOptions=} options Options map\n * @return {grpc~ClientReadableStream} An event emitter for stream related\n *     events\n */\nClient.prototype.makeServerStreamRequest = function (path, serialize, deserialize, argument, metadata, options) {\n  if (!(metadata instanceof Metadata)) {\n    options = metadata;\n    metadata = new Metadata();\n  }\n  if (!(options instanceof Object)) {\n    options = {};\n  }\n  if (!(metadata instanceof Metadata && options instanceof Object)) {\n    throw new Error('Argument mismatch in makeServerStreamRequest');\n  }\n  var method_definition = options.method_definition = {\n    path: path,\n    requestStream: false,\n    responseStream: true,\n    requestSerialize: serialize,\n    responseDeserialize: deserialize\n  };\n  metadata = metadata.clone();\n  var callProperties = {\n    argument: argument,\n    metadata: metadata,\n    call: new ClientReadableStream(),\n    channel: this.$channel,\n    methodDefinition: method_definition,\n    callOptions: options\n  };\n\n  // Transform call properties if specified.\n  if (this.$callInvocationTransformer) {\n    callProperties = this.$callInvocationTransformer(callProperties);\n  }\n  var callOptions = callProperties.callOptions;\n  var methodDefinition = callProperties.methodDefinition;\n  var interceptors = Client.prototype.resolveCallInterceptors.call(this, methodDefinition, callOptions.interceptors, callOptions.interceptor_providers);\n  var emitter = callProperties.call;\n  var intercepting_call = client_interceptors.getInterceptingCall(methodDefinition, callOptions, interceptors, callProperties.channel, emitter);\n  emitter.call = intercepting_call;\n  var last_listener = client_interceptors.getLastListener(methodDefinition, emitter);\n  intercepting_call.start(callProperties.metadata, last_listener);\n  intercepting_call.sendMessage(callProperties.argument);\n  intercepting_call.halfClose();\n  return emitter;\n};\n\n/**\n * Make a bidirectional stream request with this method on the given channel.\n * @param {string} path The path of the method to request\n * @param {grpc~serialize} serialize The serialization function for inputs\n * @param {grpc~deserialize} deserialize The deserialization\n *     function for outputs\n * @param {grpc.Metadata=} metadata Array of metadata key/value\n *     pairs to add to the call\n * @param {grpc.Client~CallOptions=} options Options map\n * @return {grpc~ClientDuplexStream} An event emitter for stream related events\n */\nClient.prototype.makeBidiStreamRequest = function (path, serialize, deserialize, metadata, options) {\n  if (!(metadata instanceof Metadata)) {\n    options = metadata;\n    metadata = new Metadata();\n  }\n  if (!(options instanceof Object)) {\n    options = {};\n  }\n  if (!(metadata instanceof Metadata && options instanceof Object)) {\n    throw new Error('Argument mismatch in makeBidiStreamRequest');\n  }\n  var method_definition = options.method_definition = {\n    path: path,\n    requestStream: true,\n    responseStream: true,\n    requestSerialize: serialize,\n    responseDeserialize: deserialize\n  };\n  metadata = metadata.clone();\n  var callProperties = {\n    metadata: metadata,\n    call: new ClientDuplexStream(),\n    channel: this.$channel,\n    methodDefinition: method_definition,\n    callOptions: options\n  };\n\n  // Transform call properties if specified.\n  if (this.$callInvocationTransformer) {\n    callProperties = this.$callInvocationTransformer(callProperties);\n  }\n  var callOptions = callProperties.callOptions;\n  var methodDefinition = callProperties.methodDefinition;\n  var interceptors = Client.prototype.resolveCallInterceptors.call(this, methodDefinition, callOptions.interceptors, callOptions.interceptor_providers);\n  var emitter = callProperties.call;\n  var intercepting_call = client_interceptors.getInterceptingCall(methodDefinition, callOptions, interceptors, callProperties.channel, emitter);\n  emitter.call = intercepting_call;\n  var last_listener = client_interceptors.getLastListener(methodDefinition, emitter);\n  intercepting_call.start(callProperties.metadata, last_listener);\n  return emitter;\n};\n\n/**\n * Close this client.\n */\nClient.prototype.close = function () {\n  this.$channel.close();\n};\n\n/**\n * Return the underlying channel object for the specified client\n * @return {Channel} The channel\n */\nClient.prototype.getChannel = function () {\n  return this.$channel;\n};\n\n/**\n * Wait for the client to be ready. The callback will be called when the\n * client has successfully connected to the server, and it will be called\n * with an error if the attempt to connect to the server has unrecoverablly\n * failed or if the deadline expires. This function will make the channel\n * start connecting if it has not already done so.\n * @param {grpc~Deadline} deadline When to stop waiting for a connection.\n * @param {function(Error)} callback The callback to call when done attempting\n *     to connect.\n */\nClient.prototype.waitForReady = function (deadline, callback) {\n  var self = this;\n  var checkState = function (err) {\n    if (err) {\n      callback(new Error('Failed to connect before the deadline'));\n      return;\n    }\n    var new_state;\n    try {\n      new_state = self.$channel.getConnectivityState(true);\n    } catch (e) {\n      callback(new Error('The channel has been closed'));\n      return;\n    }\n    if (new_state === grpc.connectivityState.READY) {\n      callback();\n    } else if (new_state === grpc.connectivityState.FATAL_FAILURE) {\n      callback(new Error('Failed to connect to server'));\n    } else {\n      try {\n        self.$channel.watchConnectivityState(new_state, deadline, checkState);\n      } catch (e) {\n        callback(new Error('The channel has been closed'));\n      }\n    }\n  };\n  /* Force a single round of polling to ensure that the channel state is up\n   * to date */\n  grpc.forcePoll();\n  setImmediate(checkState);\n};\n\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */\nvar requester_funcs = {\n  [methodTypes.UNARY]: Client.prototype.makeUnaryRequest,\n  [methodTypes.CLIENT_STREAMING]: Client.prototype.makeClientStreamRequest,\n  [methodTypes.SERVER_STREAMING]: Client.prototype.makeServerStreamRequest,\n  [methodTypes.BIDI_STREAMING]: Client.prototype.makeBidiStreamRequest\n};\nfunction getDefaultValues(metadata, options) {\n  var res = {};\n  res.metadata = metadata || new Metadata();\n  res.options = options || {};\n  return res;\n}\n\n/**\n * Map with wrappers for each type of requester function to make it use the old\n * argument order with optional arguments after the callback.\n * @access private\n */\nvar deprecated_request_wrap = {\n  [methodTypes.UNARY]: function (makeUnaryRequest) {\n    return function makeWrappedUnaryRequest(argument, callback, metadata, options) {\n      /* jshint validthis: true */\n      var opt_args = getDefaultValues(metadata, options);\n      return makeUnaryRequest.call(this, argument, opt_args.metadata, opt_args.options, callback);\n    };\n  },\n  [methodTypes.CLIENT_STREAMING]: function (makeServerStreamRequest) {\n    return function makeWrappedClientStreamRequest(callback, metadata, options) {\n      /* jshint validthis: true */\n      var opt_args = getDefaultValues(metadata, options);\n      return makeServerStreamRequest.call(this, opt_args.metadata, opt_args.options, callback);\n    };\n  },\n  [methodTypes.SERVER_STREAMING]: x => x,\n  [methodTypes.BIDI_STREAMING]: x => x\n};\n\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @memberof grpc\n * @alias grpc~makeGenericClientConstructor\n * @param {grpc~ServiceDefinition} methods An object mapping method names to\n *     method attributes\n * @param {string} serviceName The fully qualified name of the service\n * @param {Object} class_options An options object.\n * @param {boolean=} [class_options.deprecatedArgumentOrder=false] Indicates\n *     that the old argument order should be used for methods, with optional\n *     arguments at the end instead of the callback at the end. This option\n *     is only a temporary stopgap measure to smooth an API breakage.\n *     It is deprecated, and new code should not use it.\n * @return {function} New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */\nexports.makeClientConstructor = function (methods, serviceName, class_options) {\n  if (!class_options) {\n    class_options = {};\n  }\n  function ServiceClient(address, credentials, options) {\n    Client.call(this, address, credentials, options);\n  }\n  util.inherits(ServiceClient, Client);\n  ServiceClient.prototype.$method_definitions = methods;\n  ServiceClient.prototype.$method_names = {};\n  Object.keys(methods).forEach(name => {\n    const attrs = methods[name];\n    if (common.isPrototypePolluted(name)) {\n      return;\n    }\n    if (name.indexOf('$') === 0) {\n      throw new Error('Method names cannot start with $');\n    }\n    var method_type = common.getMethodType(attrs);\n    var method_func = function () {\n      return requester_funcs[method_type].apply(this, [attrs.path, attrs.requestSerialize, attrs.responseDeserialize].concat([].slice.call(arguments)));\n    };\n    if (class_options.deprecatedArgumentOrder) {\n      ServiceClient.prototype[name] = deprecated_request_wrap[method_type](method_func);\n    } else {\n      ServiceClient.prototype[name] = method_func;\n    }\n    ServiceClient.prototype.$method_names[attrs.path] = name;\n    // Associate all provided attributes with the method\n    Object.assign(ServiceClient.prototype[name], attrs);\n    if (attrs.originalName && !common.isPrototypePolluted(attrs.originalName)) {\n      ServiceClient.prototype[attrs.originalName] = ServiceClient.prototype[name];\n    }\n  });\n  ServiceClient.service = methods;\n  return ServiceClient;\n};\n\n/**\n * Return the underlying channel object for the specified client\n * @memberof grpc\n * @alias grpc~getClientChannel\n * @param {grpc.Client} client The client\n * @return {Channel} The channel\n * @see grpc.Client#getChannel\n */\nexports.getClientChannel = function (client) {\n  return Client.prototype.getChannel.call(client);\n};\n\n/**\n * Gets a map of client method names to interceptor stacks.\n * @param {grpc.Client} client\n * @returns {Object.<string, Interceptor[]>}\n */\nexports.getClientInterceptors = function (client) {\n  return Object.keys(client.$method_definitions).reduce((acc, key) => {\n    if (typeof key === 'string') {\n      acc[key] = client[key].interceptors;\n    }\n    return acc;\n  }, {});\n};\n\n/**\n * Wait for the client to be ready. The callback will be called when the\n * client has successfully connected to the server, and it will be called\n * with an error if the attempt to connect to the server has unrecoverablly\n * failed or if the deadline expires. This function will make the channel\n * start connecting if it has not already done so.\n * @memberof grpc\n * @alias grpc~waitForClientReady\n * @param {grpc.Client} client The client to wait on\n * @param {grpc~Deadline} deadline When to stop waiting for a connection. Pass\n *     Infinity to wait forever.\n * @param {function(Error)} callback The callback to call when done attempting\n *     to connect.\n * @see grpc.Client#waitForReady\n */\nexports.waitForClientReady = function (client, deadline, callback) {\n  Client.prototype.waitForReady.call(client, deadline, callback);\n};\nexports.StatusBuilder = client_interceptors.StatusBuilder;\nexports.ListenerBuilder = client_interceptors.ListenerBuilder;\nexports.RequesterBuilder = client_interceptors.RequesterBuilder;\nexports.InterceptingCall = client_interceptors.InterceptingCall;","map":{"version":3,"names":["require","client_interceptors","grpc","common","Metadata","constants","EventEmitter","stream","Readable","Writable","Duplex","methodTypes","util","version","inherits","ClientUnaryCall","call","ClientWritableStream","objectMode","self","on","halfClose","_write","chunk","encoding","callback","writeFailed","setImmediate","outerCallback","err","event","context","sendMessageWithContext","prototype","ClientReadableStream","finished","reading","read_status","received_status","_readsDone","status","code","OK","details","cancelWithStatus","_emitStatusIfDone","_receiveStatus","push","error","createStatusError","emit","_read","size","recvMessageWithContext","ClientDuplexStream","cancel","getPeer","Client","address","credentials","options","Array","isArray","interceptor_providers","interceptors","InterceptorConfigurationError","$interceptors","$interceptor_providers","$method_definitions","Object","keys","forEach","method_name","method_definition","resolveInterceptorProviders","concat","$callInvocationTransformer","callInvocationTransformer","channelOverride","channelFactoryOverride","ignoredKeys","channel_options","getOwnPropertyNames","reduce","acc","key","indexOf","$channel","Channel","exports","resolveCallInterceptors","makeUnaryRequest","path","serialize","deserialize","argument","metadata","Error","requestStream","responseStream","requestSerialize","responseDeserialize","clone","callProperties","channel","methodDefinition","callOptions","intercepting_call","getInterceptingCall","emitter","last_listener","getLastListener","start","sendMessage","makeClientStreamRequest","makeServerStreamRequest","makeBidiStreamRequest","close","getChannel","waitForReady","deadline","checkState","new_state","getConnectivityState","e","connectivityState","READY","FATAL_FAILURE","watchConnectivityState","forcePoll","requester_funcs","UNARY","CLIENT_STREAMING","SERVER_STREAMING","BIDI_STREAMING","getDefaultValues","res","deprecated_request_wrap","makeWrappedUnaryRequest","opt_args","makeWrappedClientStreamRequest","x","makeClientConstructor","methods","serviceName","class_options","ServiceClient","$method_names","name","attrs","isPrototypePolluted","method_type","getMethodType","method_func","apply","slice","arguments","deprecatedArgumentOrder","assign","originalName","service","getClientChannel","client","getClientInterceptors","waitForClientReady","StatusBuilder","ListenerBuilder","RequesterBuilder","InterceptingCall"],"sources":["/var/www/html/project/Dash_Vuexy-master/node_modules/grpc/src/client.js"],"sourcesContent":["/**\n * @license\n * Copyright 2015 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * Client module\n *\n * This module contains the factory method for creating Client classes, and the\n * method calling code for all types of methods.\n *\n * @example <caption>Create a client and call a method on it</caption>\n *\n * var proto_obj = grpc.load(proto_file_path);\n * var Client = proto_obj.package.subpackage.ServiceName;\n * var client = new Client(server_address, client_credentials);\n * var call = client.unaryMethod(arguments, callback);\n */\n\n'use strict';\n\nvar client_interceptors = require('./client_interceptors');\nvar grpc = require('./grpc_extension');\n\nvar common = require('./common');\n\nvar Metadata = require('./metadata');\n\nvar constants = require('./constants');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar stream = require('stream');\n\nvar Readable = stream.Readable;\nvar Writable = stream.Writable;\nvar Duplex = stream.Duplex;\nvar methodTypes = constants.methodTypes;\nvar util = require('util');\nvar version = require('../package.json').version;\n\n/**\n * Initial response metadata sent by the server when it starts processing the\n * call\n * @event grpc~ClientUnaryCall#metadata\n * @type {grpc.Metadata}\n */\n\n/**\n * Status of the call when it has completed.\n * @event grpc~ClientUnaryCall#status\n * @type grpc~StatusObject\n */\n\nutil.inherits(ClientUnaryCall, EventEmitter);\n\n/**\n * An EventEmitter. Used for unary calls.\n * @constructor grpc~ClientUnaryCall\n * @extends external:EventEmitter\n * @param {grpc.internal~Call} call The call object associated with the request\n */\nfunction ClientUnaryCall(call) {\n  EventEmitter.call(this);\n  this.call = call;\n}\n\nutil.inherits(ClientWritableStream, Writable);\n\n/**\n * A stream that the client can write to. Used for calls that are streaming from\n * the client side.\n * @constructor grpc~ClientWritableStream\n * @extends external:Writable\n * @borrows grpc~ClientUnaryCall#cancel as grpc~ClientWritableStream#cancel\n * @borrows grpc~ClientUnaryCall#getPeer as grpc~ClientWritableStream#getPeer\n * @borrows grpc~ClientUnaryCall#event:metadata as\n *     grpc~ClientWritableStream#metadata\n * @borrows grpc~ClientUnaryCall#event:status as\n *     grpc~ClientWritableStream#status\n * @param {InterceptingCall} call Exposes gRPC request operations, processed by\n *     an interceptor stack.\n */\nfunction ClientWritableStream(call) {\n  Writable.call(this, {objectMode: true});\n  this.call = call;\n  var self = this;\n  this.on('finish', function() {\n    self.call.halfClose();\n  });\n}\n\n/**\n * Write a message to the request stream. If serializing the argument fails,\n * the call will be cancelled and the stream will end with an error.\n * @name grpc~ClientWritableStream#write\n * @kind function\n * @override\n * @param {*} message The message to write. Must be a valid argument to the\n *     serialize function of the corresponding method\n * @param {grpc.writeFlags} flags Flags to modify how the message is written\n * @param {Function} callback Callback for when this chunk of data is flushed\n * @return {boolean} As defined for [Writable]{@link external:Writable}\n */\n\n/**\n * Attempt to write the given chunk. Calls the callback when done. This is an\n * implementation of a method needed for implementing stream.Writable.\n * @private\n * @param {*} chunk The chunk to write\n * @param {grpc.writeFlags} encoding Used to pass write flags\n * @param {function(Error=)} callback Called when the write is complete\n */\nfunction _write(chunk, encoding, callback) {\n  /* jshint validthis: true */\n  var self = this;\n  if (this.writeFailed) {\n    /* Once a write fails, just call the callback immediately to let the caller\n       flush any pending writes. */\n    setImmediate(callback);\n    return;\n  }\n  var outerCallback = function(err, event) {\n    if (err) {\n      /* Assume that the call is complete and that writing failed because a\n         status was received. In that case, set a flag to discard all future\n         writes */\n      self.writeFailed = true;\n    }\n    callback();\n  };\n  var context = {\n    encoding: encoding,\n    callback: outerCallback\n  };\n  this.call.sendMessageWithContext(context, chunk);\n}\n\nClientWritableStream.prototype._write = _write;\n\nutil.inherits(ClientReadableStream, Readable);\n\n/**\n * A stream that the client can read from. Used for calls that are streaming\n * from the server side.\n * @constructor grpc~ClientReadableStream\n * @extends external:Readable\n * @borrows grpc~ClientUnaryCall#cancel as grpc~ClientReadableStream#cancel\n * @borrows grpc~ClientUnaryCall#getPeer as grpc~ClientReadableStream#getPeer\n * @borrows grpc~ClientUnaryCall#event:metadata as\n *     grpc~ClientReadableStream#metadata\n * @borrows grpc~ClientUnaryCall#event:status as\n *     grpc~ClientReadableStream#status\n * @param {InterceptingCall} call Exposes gRPC request operations, processed by\n *     an interceptor stack.\n */\nfunction ClientReadableStream(call) {\n  Readable.call(this, {objectMode: true});\n  this.call = call;\n  this.finished = false;\n  this.reading = false;\n  /* Status generated from reading messages from the server. Overrides the\n   * status from the server if not OK */\n  this.read_status = null;\n  /* Status received from the server. */\n  this.received_status = null;\n}\n\n/**\n * Called when all messages from the server have been processed. The status\n * parameter indicates that the call should end with that status. status\n * defaults to OK if not provided.\n * @param {Object!} status The status that the call should end with\n * @private\n */\nfunction _readsDone(status) {\n  /* jshint validthis: true */\n  if (!status) {\n    status = {code: constants.status.OK, details: 'OK'};\n  }\n  if (status.code !== constants.status.OK) {\n    this.call.cancelWithStatus(status.code, status.details);\n  }\n  this.finished = true;\n  this.read_status = status;\n  this._emitStatusIfDone();\n}\n\nClientReadableStream.prototype._readsDone = _readsDone;\n\n/**\n * Called to indicate that we have received a status from the server.\n * @private\n */\nfunction _receiveStatus(status) {\n  /* jshint validthis: true */\n  this.received_status = status;\n  this._emitStatusIfDone();\n}\n\nClientReadableStream.prototype._receiveStatus = _receiveStatus;\n\n/**\n * If we have both processed all incoming messages and received the status from\n * the server, emit the status. Otherwise, do nothing.\n * @private\n */\nfunction _emitStatusIfDone() {\n  /* jshint validthis: true */\n  var status;\n  if (this.read_status && this.received_status) {\n    if (this.read_status.code !== constants.status.OK) {\n      status = this.read_status;\n    } else {\n      status = this.received_status;\n    }\n    if (status.code === constants.status.OK) {\n      this.push(null);\n    } else {\n      var error = common.createStatusError(status);\n      this.emit('error', error);\n    }\n    this.emit('status', status);\n  }\n}\n\nClientReadableStream.prototype._emitStatusIfDone = _emitStatusIfDone;\n\n/**\n * Read the next object from the stream.\n * @private\n * @param {*} size Ignored because we use objectMode=true\n */\nfunction _read(size) {\n  /* jshint validthis: true */\n  if (this.finished) {\n    this.push(null);\n  } else {\n    if (!this.reading) {\n      this.reading = true;\n      var context = {\n        stream: this\n      };\n      this.call.recvMessageWithContext(context);\n    }\n  }\n}\n\nClientReadableStream.prototype._read = _read;\n\nutil.inherits(ClientDuplexStream, Duplex);\n\n/**\n * A stream that the client can read from or write to. Used for calls with\n * duplex streaming.\n * @constructor grpc~ClientDuplexStream\n * @extends external:Duplex\n * @borrows grpc~ClientUnaryCall#cancel as grpc~ClientDuplexStream#cancel\n * @borrows grpc~ClientUnaryCall#getPeer as grpc~ClientDuplexStream#getPeer\n * @borrows grpc~ClientWritableStream#write as grpc~ClientDuplexStream#write\n * @borrows grpc~ClientUnaryCall#event:metadata as\n *     grpc~ClientDuplexStream#metadata\n * @borrows grpc~ClientUnaryCall#event:status as\n *     grpc~ClientDuplexStream#status\n * @param {InterceptingCall} call Exposes gRPC request operations, processed by\n *     an interceptor stack.\n */\nfunction ClientDuplexStream(call) {\n  Duplex.call(this, {objectMode: true});\n  this.call = call;\n  /* Status generated from reading messages from the server. Overrides the\n   * status from the server if not OK */\n  this.read_status = null;\n  /* Status received from the server. */\n  this.received_status = null;\n  var self = this;\n  this.on('finish', function() {\n    self.call.halfClose();\n  });\n}\n\nClientDuplexStream.prototype._readsDone = _readsDone;\nClientDuplexStream.prototype._receiveStatus = _receiveStatus;\nClientDuplexStream.prototype._emitStatusIfDone = _emitStatusIfDone;\nClientDuplexStream.prototype._read = _read;\nClientDuplexStream.prototype._write = _write;\n\n/**\n * Cancel the ongoing call. Results in the call ending with a CANCELLED status,\n * unless it has already ended with some other status.\n * @alias grpc~ClientUnaryCall#cancel\n */\nfunction cancel() {\n  /* jshint validthis: true */\n  this.call.cancel();\n}\n\nClientUnaryCall.prototype.cancel = cancel;\nClientReadableStream.prototype.cancel = cancel;\nClientWritableStream.prototype.cancel = cancel;\nClientDuplexStream.prototype.cancel = cancel;\n\n/**\n * Get the endpoint this call/stream is connected to.\n * @return {string} The URI of the endpoint\n * @alias grpc~ClientUnaryCall#getPeer\n */\nfunction getPeer() {\n  /* jshint validthis: true */\n  return this.call.getPeer();\n}\n\nClientUnaryCall.prototype.getPeer = getPeer;\nClientReadableStream.prototype.getPeer = getPeer;\nClientWritableStream.prototype.getPeer = getPeer;\nClientDuplexStream.prototype.getPeer = getPeer;\n\n/**\n * Any client call type\n * @typedef {(grpc~ClientUnaryCall|grpc~ClientReadableStream|\n *            grpc~ClientWritableStream|grpc~ClientDuplexStream)}\n *     grpc.Client~Call\n */\n\n/**\n * Options that can be set on a call.\n * @typedef {Object} grpc.Client~CallOptions\n * @property {grpc~Deadline} deadline The deadline for the entire call to\n *     complete.\n * @property {string} host Server hostname to set on the call. Only meaningful\n *     if different from the server address used to construct the client.\n * @property {grpc.Client~Call} parent Parent call. Used in servers when\n *     making a call as part of the process of handling a call. Used to\n *     propagate some information automatically, as specified by\n *     propagate_flags.\n * @property {number} propagate_flags Indicates which properties of a parent\n *     call should propagate to this call. Bitwise combination of flags in\n *     {@link grpc.propagate}.\n * @property {grpc.credentials~CallCredentials} credentials The credentials that\n *     should be used to make this particular call.\n */\n\n/**\n * Properties of a call, for use with a {@link grpc.Client~callInvocationTransformer}.\n * @typedef {Object} grpc.Client~CallProperties\n * @property {*} argument The call argument. Only preset if the method is unary or server streaming.\n * @property {grpc.Metadata} metadata The request metadata\n * @property {grpc~Call} call The call object that will be returned by the client method\n * @property {grpc.Channel} channel The channel that will be used to make a request\n * @property {grpc~MethodDefinition} methodDefinition The MethodDefinition object that describes this method\n * @property {grpc.Client~CallOptions} options The call options passed when making this request\n * @property {grpc.Client~requestCallback} callback The callback that will handle the response.\n *     Only present if this method is unary or client streaming.\n */\n\n/**\n * Call invocation transformer. Has access to the full call properties before a\n * call is processed and can modify most of those properties. Some modifications\n * will have no effect or may cause problems.\n * @name grpc.Client~callInvocationTransformer\n * @function\n * @param {grpc.Client~CallProperties} callProperties The original call properties\n * @return {grpc.Client~CallProperties} The modified call properties.\n */\n\n/**\n * A function that functionally replaces the Channel constructor.\n * @name grpc.Client~channelFactory\n * @function\n * @param {string} target The address of the server to connect to\n * @param {grpc.ChannelCredentials} credentials Channel credentials to use when connecting\n * @param {grpc~ChannelOptions} options A map of channel options that will be passed to the core.\n *     The available options are listed in\n *     [this document]{@link https://grpc.github.io/grpc/core/group__grpc__arg__keys.html}.\n * @returns {grpc.Channel} This can either be an actual channel object, or an object with the\n *     same API.\n */\n\n/**\n * A generic gRPC client. Primarily useful as a base class for generated clients\n * @memberof grpc\n * @constructor\n * @param {string} address Server address to connect to\n * @param {grpc.credentials~ChannelCredentials} credentials Credentials to use\n *     to connect to the server\n * @param {Object} options Options to apply to channel creation. Any of\n *     [the channel arguments]{@link https://grpc.github.io/grpc/core/group__grpc__arg__keys.html}\n *     can be used here in addition to specific client options.\n * @param {grpc~Interceptor[]} [options.interceptors] Interceptors to apply to each request\n * @param {grpc~InterceptorProvider[]} [options.interceptor_providers] Interceptor providers\n *     to apply interceptors to each request depending on the method definition. At most\n *     one of the interceptors and interceptor_providers options may be set.\n * @param {grpc.Client~callInvocationTransformer=} options.callInvocationTransformer\n * @param {grpc.Channel=} options.channelOverride Channel to use instead of constructing a new one.\n *     If set, the address, credentials, channel arguments options, and channelFactoryOverride\n *     option will all be ignored.\n * @param {grpc.Client~channelFactory} options.channelFactoryOverride Function to use instead of\n *     the Channel constructor when creating the Client's channel.\n */\nfunction Client(address, credentials, options) {\n  var self = this;\n  if (!options) {\n    options = {};\n  }\n\n  // Resolve interceptor options and assign interceptors to each method\n  if (Array.isArray(options.interceptor_providers) && Array.isArray(options.interceptors)) {\n    throw new client_interceptors.InterceptorConfigurationError(\n      'Both interceptors and interceptor_providers were passed as options ' +\n      'to the client constructor. Only one of these is allowed.');\n  }\n  self.$interceptors = options.interceptors || [];\n  self.$interceptor_providers = options.interceptor_providers || [];\n  if (self.$method_definitions) {\n    Object.keys(self.$method_definitions).forEach(method_name => {\n      const method_definition = self.$method_definitions[method_name];\n      self[method_name].interceptors = client_interceptors\n        .resolveInterceptorProviders(self.$interceptor_providers, method_definition)\n        .concat(self.$interceptors);\n    });\n  }\n\n  this.$callInvocationTransformer = options.callInvocationTransformer;\n\n  let channelOverride = options.channelOverride;\n  let channelFactoryOverride = options.channelFactoryOverride;\n  // Exclude channel options which have already been consumed\n  const ignoredKeys = [\n    'interceptors', 'interceptor_providers', 'channelOverride',\n    'channelFactoryOverride', 'callInvocationTransformer'\n  ];\n  var channel_options = Object.getOwnPropertyNames(options)\n    .reduce((acc, key) => {\n      if (ignoredKeys.indexOf(key) === -1) {\n        acc[key] = options[key];\n      }\n      return acc;\n    }, {});\n  /* Private fields use $ as a prefix instead of _ because it is an invalid\n   * prefix of a method name */\n  if (channelOverride) {\n    this.$channel = options.channelOverride;\n  } else {\n    if (channelFactoryOverride) {\n      this.$channel = channelFactoryOverride(address, credentials, channel_options);\n    } else {\n      this.$channel = new grpc.Channel(address, credentials, channel_options);\n    }\n  }\n}\n\nexports.Client = Client;\n\nClient.prototype.resolveCallInterceptors = function(method_definition, interceptors, interceptor_providers) {\n  if (Array.isArray(interceptors) && Array.isArray(interceptor_providers)) {\n    throw new client_interceptors.InterceptorConfigurationError(\n      'Both interceptors and interceptor_providers were passed as call ' +\n      'options. Only one of these is allowed.');\n  }\n  if (Array.isArray(interceptors) || Array.isArray(interceptor_providers)) {\n    interceptors = interceptors || [];\n    interceptor_providers = interceptor_providers || [];\n    return client_interceptors.resolveInterceptorProviders(interceptor_providers, method_definition).concat(interceptors);\n  } else {\n    return client_interceptors.resolveInterceptorProviders(this.$interceptor_providers, method_definition).concat(this.$interceptors);\n  }\n}\n\n/**\n * @callback grpc.Client~requestCallback\n * @param {?grpc~ServiceError} error The error, if the call\n *     failed\n * @param {*} value The response value, if the call succeeded\n */\n\n/**\n * Make a unary request to the given method, using the given serialize\n * and deserialize functions, with the given argument.\n * @param {string} path The path of the method to request\n * @param {grpc~serialize} serialize The serialization function for\n *     inputs\n * @param {grpc~deserialize} deserialize The deserialization\n *     function for outputs\n * @param {*} argument The argument to the call. Should be serializable with\n *     serialize\n * @param {grpc.Metadata=} metadata Metadata to add to the call\n * @param {grpc.Client~CallOptions=} options Options map\n * @param {grpc.Client~requestCallback} callback The callback\n *     for when the response is received\n * @return {grpc~ClientUnaryCall} An event emitter for stream related events\n */\nClient.prototype.makeUnaryRequest = function(path, serialize, deserialize,\n                                             argument, metadata, options,\n                                             callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    if (metadata instanceof Metadata) {\n      options = {};\n    } else {\n      options = metadata;\n      metadata = new Metadata();\n    }\n  } else if (typeof metadata === 'function') {\n    callback = metadata;\n    metadata = new Metadata();\n    options = {};\n  }\n  if (!metadata) {\n    metadata = new Metadata();\n  }\n  if (!options) {\n    options = {};\n  }\n  if (!((metadata instanceof Metadata) &&\n        (options instanceof Object) &&\n        (typeof callback === 'function'))) {\n    throw new Error('Argument mismatch in makeUnaryRequest');\n  }\n\n  var method_definition = options.method_definition = {\n    path: path,\n    requestStream: false,\n    responseStream: false,\n    requestSerialize: serialize,\n    responseDeserialize: deserialize\n  };\n\n  metadata = metadata.clone();\n\n  var callProperties = {\n    argument: argument,\n    metadata: metadata,\n    call: new ClientUnaryCall(),\n    channel: this.$channel,\n    methodDefinition: method_definition,\n    callOptions: options,\n    callback: callback\n  };\n\n  // Transform call properties if specified.\n  if (this.$callInvocationTransformer) {\n    callProperties = this.$callInvocationTransformer(callProperties);\n  }\n\n  var callOptions = callProperties.callOptions;\n  var methodDefinition = callProperties.methodDefinition;\n\n  var interceptors = Client.prototype.resolveCallInterceptors.call(\n    this,\n    methodDefinition,\n    callOptions.interceptors,\n    callOptions.interceptor_providers\n  );\n\n  var intercepting_call = client_interceptors.getInterceptingCall(\n    methodDefinition,\n    callOptions,\n    interceptors,\n    callProperties.channel,\n    callProperties.callback\n  );\n\n  var emitter = callProperties.call;\n  emitter.call = intercepting_call;\n\n  var last_listener = client_interceptors.getLastListener(\n    methodDefinition,\n    emitter,\n    callProperties.callback\n  );\n\n  intercepting_call.start(callProperties.metadata, last_listener);\n  intercepting_call.sendMessage(callProperties.argument);\n  intercepting_call.halfClose();\n\n  return emitter;\n};\n\n/**\n * Make a client stream request to the given method, using the given serialize\n * and deserialize functions, with the given argument.\n * @param {string} path The path of the method to request\n * @param {grpc~serialize} serialize The serialization function for\n *     inputs\n * @param {grpc~deserialize} deserialize The deserialization\n *     function for outputs\n * @param {grpc.Metadata=} metadata Array of metadata key/value pairs to add to\n *     the call\n * @param {grpc.Client~CallOptions=} options Options map\n * @param {grpc.Client~requestCallback} callback The callback for when the\n *     response is received\n * @return {grpc~ClientWritableStream} An event emitter for stream related\n *     events\n */\nClient.prototype.makeClientStreamRequest = function(path, serialize,\n                                                    deserialize, metadata,\n                                                    options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    if (metadata instanceof Metadata) {\n      options = {};\n    } else {\n      options = metadata;\n      metadata = new Metadata();\n    }\n  } else if (typeof metadata === 'function') {\n    callback = metadata;\n    metadata = new Metadata();\n    options = {};\n  }\n  if (!metadata) {\n    metadata = new Metadata();\n  }\n  if (!options) {\n    options = {};\n  }\n  if (!((metadata instanceof Metadata) &&\n       (options instanceof Object) &&\n       (typeof callback === 'function'))) {\n    throw new Error('Argument mismatch in makeClientStreamRequest');\n  }\n\n  var method_definition = options.method_definition = {\n    path: path,\n    requestStream: true,\n    responseStream: false,\n    requestSerialize: serialize,\n    responseDeserialize: deserialize\n  };\n\n  metadata = metadata.clone();\n\n  var callProperties = {\n    metadata: metadata,\n    call: new ClientWritableStream(),\n    channel: this.$channel,\n    methodDefinition: method_definition,\n    callOptions: options,\n    callback: callback\n  };\n\n  // Transform call properties if specified.\n  if (this.$callInvocationTransformer) {\n    callProperties = this.$callInvocationTransformer(callProperties);\n  }\n\n  var callOptions = callProperties.callOptions;\n  var methodDefinition = callProperties.methodDefinition;\n\n  var interceptors = Client.prototype.resolveCallInterceptors.call(\n    this,\n    methodDefinition,\n    callOptions.interceptors,\n    callOptions.interceptor_providers\n  );\n\n  var intercepting_call = client_interceptors.getInterceptingCall(\n    methodDefinition,\n    callOptions,\n    interceptors,\n    callProperties.channel,\n    callProperties.callback\n  );\n\n  var emitter = callProperties.call;\n  emitter.call = intercepting_call;\n\n  var last_listener = client_interceptors.getLastListener(\n    methodDefinition,\n    emitter,\n    callProperties.callback\n  );\n\n  intercepting_call.start(callProperties.metadata, last_listener);\n\n  return emitter;\n};\n\n/**\n * Make a server stream request to the given method, with the given serialize\n * and deserialize function, using the given argument\n * @param {string} path The path of the method to request\n * @param {grpc~serialize} serialize The serialization function for inputs\n * @param {grpc~deserialize} deserialize The deserialization\n *     function for outputs\n * @param {*} argument The argument to the call. Should be serializable with\n *     serialize\n * @param {grpc.Metadata=} metadata Array of metadata key/value pairs to add to\n *     the call\n * @param {grpc.Client~CallOptions=} options Options map\n * @return {grpc~ClientReadableStream} An event emitter for stream related\n *     events\n */\nClient.prototype.makeServerStreamRequest = function(path, serialize,\n                                                    deserialize, argument,\n                                                    metadata, options) {\n  if (!(metadata instanceof Metadata)) {\n    options = metadata;\n    metadata = new Metadata();\n  }\n  if (!(options instanceof Object)) {\n    options = {};\n  }\n  if (!((metadata instanceof Metadata) && (options instanceof Object))) {\n    throw new Error('Argument mismatch in makeServerStreamRequest');\n  }\n\n  var method_definition = options.method_definition = {\n    path: path,\n    requestStream: false,\n    responseStream: true,\n    requestSerialize: serialize,\n    responseDeserialize: deserialize\n  };\n\n  metadata = metadata.clone();\n\n  var callProperties = {\n    argument: argument,\n    metadata: metadata,\n    call: new ClientReadableStream(),\n    channel: this.$channel,\n    methodDefinition: method_definition,\n    callOptions: options,\n  };\n\n  // Transform call properties if specified.\n  if (this.$callInvocationTransformer) {\n    callProperties = this.$callInvocationTransformer(callProperties);\n  }\n\n  var callOptions = callProperties.callOptions;\n  var methodDefinition = callProperties.methodDefinition;\n\n  var interceptors = Client.prototype.resolveCallInterceptors.call(\n    this,\n    methodDefinition,\n    callOptions.interceptors,\n    callOptions.interceptor_providers\n  );\n\n  var emitter = callProperties.call;\n  var intercepting_call = client_interceptors.getInterceptingCall(\n    methodDefinition,\n    callOptions,\n    interceptors,\n    callProperties.channel,\n    emitter\n  );\n  emitter.call = intercepting_call;\n  var last_listener = client_interceptors.getLastListener(\n    methodDefinition,\n    emitter\n  );\n\n  intercepting_call.start(callProperties.metadata, last_listener);\n  intercepting_call.sendMessage(callProperties.argument);\n  intercepting_call.halfClose();\n\n  return emitter;\n};\n\n/**\n * Make a bidirectional stream request with this method on the given channel.\n * @param {string} path The path of the method to request\n * @param {grpc~serialize} serialize The serialization function for inputs\n * @param {grpc~deserialize} deserialize The deserialization\n *     function for outputs\n * @param {grpc.Metadata=} metadata Array of metadata key/value\n *     pairs to add to the call\n * @param {grpc.Client~CallOptions=} options Options map\n * @return {grpc~ClientDuplexStream} An event emitter for stream related events\n */\nClient.prototype.makeBidiStreamRequest = function(path, serialize,\n                                                  deserialize, metadata,\n                                                  options) {\n  if (!(metadata instanceof Metadata)) {\n    options = metadata;\n    metadata = new Metadata();\n  }\n  if (!(options instanceof Object)) {\n    options = {};\n  }\n  if (!((metadata instanceof Metadata) && (options instanceof Object))) {\n    throw new Error('Argument mismatch in makeBidiStreamRequest');\n  }\n\n  var method_definition = options.method_definition = {\n    path: path,\n    requestStream: true,\n    responseStream: true,\n    requestSerialize: serialize,\n    responseDeserialize: deserialize\n  };\n\n  metadata = metadata.clone();\n\n  var callProperties = {\n    metadata: metadata,\n    call: new ClientDuplexStream(),\n    channel: this.$channel,\n    methodDefinition: method_definition,\n    callOptions: options,\n  };\n\n  // Transform call properties if specified.\n  if (this.$callInvocationTransformer) {\n    callProperties = this.$callInvocationTransformer(callProperties);\n  }\n\n  var callOptions = callProperties.callOptions;\n  var methodDefinition = callProperties.methodDefinition;\n\n  var interceptors = Client.prototype.resolveCallInterceptors.call(\n    this,\n    methodDefinition,\n    callOptions.interceptors,\n    callOptions.interceptor_providers\n  );\n\n\n  var emitter = callProperties.call;\n  var intercepting_call = client_interceptors.getInterceptingCall(\n    methodDefinition,\n    callOptions,\n    interceptors,\n    callProperties.channel,\n    emitter\n  );\n  emitter.call = intercepting_call;\n  var last_listener = client_interceptors.getLastListener(\n    methodDefinition,\n    emitter\n  );\n\n  intercepting_call.start(callProperties.metadata, last_listener);\n\n  return emitter;\n};\n\n/**\n * Close this client.\n */\nClient.prototype.close = function() {\n  this.$channel.close();\n};\n\n/**\n * Return the underlying channel object for the specified client\n * @return {Channel} The channel\n */\nClient.prototype.getChannel = function() {\n  return this.$channel;\n};\n\n/**\n * Wait for the client to be ready. The callback will be called when the\n * client has successfully connected to the server, and it will be called\n * with an error if the attempt to connect to the server has unrecoverablly\n * failed or if the deadline expires. This function will make the channel\n * start connecting if it has not already done so.\n * @param {grpc~Deadline} deadline When to stop waiting for a connection.\n * @param {function(Error)} callback The callback to call when done attempting\n *     to connect.\n */\nClient.prototype.waitForReady = function(deadline, callback) {\n  var self = this;\n  var checkState = function(err) {\n    if (err) {\n      callback(new Error('Failed to connect before the deadline'));\n      return;\n    }\n    var new_state;\n    try {\n      new_state = self.$channel.getConnectivityState(true);\n    } catch (e) {\n      callback(new Error('The channel has been closed'));\n      return;\n    }\n    if (new_state === grpc.connectivityState.READY) {\n      callback();\n    } else if (new_state === grpc.connectivityState.FATAL_FAILURE) {\n      callback(new Error('Failed to connect to server'));\n    } else {\n      try {\n        self.$channel.watchConnectivityState(new_state, deadline, checkState);\n      } catch (e) {\n        callback(new Error('The channel has been closed'));\n      }\n    }\n  };\n  /* Force a single round of polling to ensure that the channel state is up\n   * to date */\n  grpc.forcePoll();\n  setImmediate(checkState);\n};\n\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */\nvar requester_funcs = {\n  [methodTypes.UNARY]: Client.prototype.makeUnaryRequest,\n  [methodTypes.CLIENT_STREAMING]: Client.prototype.makeClientStreamRequest,\n  [methodTypes.SERVER_STREAMING]: Client.prototype.makeServerStreamRequest,\n  [methodTypes.BIDI_STREAMING]: Client.prototype.makeBidiStreamRequest\n};\n\nfunction getDefaultValues(metadata, options) {\n  var res = {};\n  res.metadata = metadata || new Metadata();\n  res.options = options || {};\n  return res;\n}\n\n/**\n * Map with wrappers for each type of requester function to make it use the old\n * argument order with optional arguments after the callback.\n * @access private\n */\nvar deprecated_request_wrap = {\n  [methodTypes.UNARY]: function(makeUnaryRequest) {\n    return function makeWrappedUnaryRequest(argument, callback,\n                                            metadata, options) {\n      /* jshint validthis: true */\n      var opt_args = getDefaultValues(metadata, options);\n      return makeUnaryRequest.call(this, argument, opt_args.metadata,\n                                   opt_args.options, callback);\n    };\n  },\n  [methodTypes.CLIENT_STREAMING]: function(makeServerStreamRequest) {\n    return function makeWrappedClientStreamRequest(callback, metadata,\n                                                   options) {\n      /* jshint validthis: true */\n      var opt_args = getDefaultValues(metadata, options);\n      return makeServerStreamRequest.call(this, opt_args.metadata,\n                                          opt_args.options, callback);\n    };\n  },\n  [methodTypes.SERVER_STREAMING]: x => x,\n  [methodTypes.BIDI_STREAMING]: x => x\n};\n\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @memberof grpc\n * @alias grpc~makeGenericClientConstructor\n * @param {grpc~ServiceDefinition} methods An object mapping method names to\n *     method attributes\n * @param {string} serviceName The fully qualified name of the service\n * @param {Object} class_options An options object.\n * @param {boolean=} [class_options.deprecatedArgumentOrder=false] Indicates\n *     that the old argument order should be used for methods, with optional\n *     arguments at the end instead of the callback at the end. This option\n *     is only a temporary stopgap measure to smooth an API breakage.\n *     It is deprecated, and new code should not use it.\n * @return {function} New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */\nexports.makeClientConstructor = function(methods, serviceName,\n                                         class_options) {\n  if (!class_options) {\n    class_options = {};\n  }\n\n  function ServiceClient(address, credentials, options) {\n    Client.call(this, address, credentials, options);\n  }\n\n  util.inherits(ServiceClient, Client);\n  ServiceClient.prototype.$method_definitions = methods;\n  ServiceClient.prototype.$method_names = {};\n\n  Object.keys(methods).forEach(name => {\n    const attrs = methods[name];\n    if (common.isPrototypePolluted(name)) {\n      return;\n    }\n    if (name.indexOf('$') === 0) {\n      throw new Error('Method names cannot start with $');\n    }\n    var method_type = common.getMethodType(attrs);\n    var method_func = function() {\n      return requester_funcs[method_type].apply(this,\n        [ attrs.path, attrs.requestSerialize, attrs.responseDeserialize ]\n        .concat([].slice.call(arguments))\n      );\n    };\n    if (class_options.deprecatedArgumentOrder) {\n      ServiceClient.prototype[name] =\n        deprecated_request_wrap[method_type](method_func);\n    } else {\n      ServiceClient.prototype[name] = method_func;\n    }\n    ServiceClient.prototype.$method_names[attrs.path] = name;\n    // Associate all provided attributes with the method\n    Object.assign(ServiceClient.prototype[name], attrs);\n    if (attrs.originalName && !common.isPrototypePolluted(attrs.originalName)) {\n      ServiceClient.prototype[attrs.originalName] =\n        ServiceClient.prototype[name];\n    }\n  });\n\n  ServiceClient.service = methods;\n\n  return ServiceClient;\n};\n\n/**\n * Return the underlying channel object for the specified client\n * @memberof grpc\n * @alias grpc~getClientChannel\n * @param {grpc.Client} client The client\n * @return {Channel} The channel\n * @see grpc.Client#getChannel\n */\nexports.getClientChannel = function(client) {\n  return Client.prototype.getChannel.call(client);\n};\n\n/**\n * Gets a map of client method names to interceptor stacks.\n * @param {grpc.Client} client\n * @returns {Object.<string, Interceptor[]>}\n */\nexports.getClientInterceptors = function(client) {\n  return Object.keys(client.$method_definitions)\n    .reduce((acc, key) => {\n      if (typeof key === 'string') {\n        acc[key] = client[key].interceptors;\n      }\n      return acc;\n    }, {});\n};\n\n/**\n * Wait for the client to be ready. The callback will be called when the\n * client has successfully connected to the server, and it will be called\n * with an error if the attempt to connect to the server has unrecoverablly\n * failed or if the deadline expires. This function will make the channel\n * start connecting if it has not already done so.\n * @memberof grpc\n * @alias grpc~waitForClientReady\n * @param {grpc.Client} client The client to wait on\n * @param {grpc~Deadline} deadline When to stop waiting for a connection. Pass\n *     Infinity to wait forever.\n * @param {function(Error)} callback The callback to call when done attempting\n *     to connect.\n * @see grpc.Client#waitForReady\n */\nexports.waitForClientReady = function(client, deadline, callback) {\n  Client.prototype.waitForReady.call(client, deadline, callback);\n};\n\nexports.StatusBuilder = client_interceptors.StatusBuilder;\nexports.ListenerBuilder = client_interceptors.ListenerBuilder;\nexports.RequesterBuilder = client_interceptors.RequesterBuilder;\nexports.InterceptingCall = client_interceptors.InterceptingCall;\n"],"mappings":"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B,CAACrB,SAAS,CAACX,MAAM,GAAGA,MAAM;;AAE5C;AACA;AACA;AACA;AACA;AACA,SAASiC,MAAMA,CAAA,EAAG;EAChB;EACA,IAAI,CAACvC,IAAI,CAACuC,MAAM,EAAE;AACpB;AAEAxC,eAAe,CAACkB,SAAS,CAACsB,MAAM,GAAGA,MAAM;AACzCrB,oBAAoB,CAACD,SAAS,CAACsB,MAAM,GAAGA,MAAM;AAC9CtC,oBAAoB,CAACgB,SAAS,CAACsB,MAAM,GAAGA,MAAM;AAC9CD,kBAAkB,CAACrB,SAAS,CAACsB,MAAM,GAAGA,MAAM;;AAE5C;AACA;AACA;AACA;AACA;AACA,SAASC,OAAOA,CAAA,EAAG;EACjB;EACA,OAAO,IAAI,CAACxC,IAAI,CAACwC,OAAO,EAAE;AAC5B;AAEAzC,eAAe,CAACkB,SAAS,CAACuB,OAAO,GAAGA,OAAO;AAC3CtB,oBAAoB,CAACD,SAAS,CAACuB,OAAO,GAAGA,OAAO;AAChDvC,oBAAoB,CAACgB,SAAS,CAACuB,OAAO,GAAGA,OAAO;AAChDF,kBAAkB,CAACrB,SAAS,CAACuB,OAAO,GAAGA,OAAO;;AAE9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAACC,OAAO,EAAEC,WAAW,EAAEC,OAAO,EAAE;EAC7C,IAAIzC,IAAI,GAAG,IAAI;EACf,IAAI,CAACyC,OAAO,EAAE;IACZA,OAAO,GAAG,CAAC,CAAC;EACd;;EAEA;EACA,IAAIC,KAAK,CAA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}