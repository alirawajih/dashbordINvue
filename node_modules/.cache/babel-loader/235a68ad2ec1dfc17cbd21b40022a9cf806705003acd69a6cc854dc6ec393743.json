{"ast":null,"code":"\"use strict\";\n\n/*\n *\n * Copyright 2016, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\nrequire(\"core-js/modules/es.array.push.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Path template utility.\n */\nconst has = require(\"lodash.has\");\nconst util = require(\"util\");\nconst extras = require(\"./parserExtras\");\nconst parser = require('./pathTemplateParser');\nclass PathTemplate {\n  get size() {\n    return this.parseResult.size;\n  }\n  get segments() {\n    return this.parseResult.segments;\n  }\n  /**\n   * @param {String} data the of the template\n   *\n   * @constructor\n   */\n  constructor(data) {\n    this.parseResult = extras.finishParse(parser.parse(data));\n  }\n  /**\n   * Matches a fully-qualified path template string.\n   *\n   * @param {String} path a fully-qualified path template string\n   * @return {Object} contains const names matched to binding values\n   * @throws {TypeError} if path can't be matched to this template\n   */\n  match(path) {\n    const pathSegments = path.split('/');\n    const bindings = {};\n    let segmentCount = this.size;\n    let current;\n    let index = 0;\n    this.segments.forEach(segment => {\n      if (index > pathSegments.length) {\n        return;\n      }\n      if (segment.kind === extras.BINDING) {\n        current = segment.literal;\n      } else if (segment.kind === extras.TERMINAL) {\n        if (segment.literal === '*') {\n          bindings[current] = pathSegments[index];\n          index += 1;\n        } else if (segment.literal === '**') {\n          const size = pathSegments.length - segmentCount + 1;\n          segmentCount += size - 1;\n          bindings[current] = pathSegments.slice(index, index + size).join('/');\n          index += size;\n        } else if (segment.literal === pathSegments[index]) {\n          index += 1;\n        } else {\n          const msg = util.format('mismatched literal (index=%d): \\'%s\\' != \\'%s\\'', index, segment.literal, pathSegments[index]);\n          throw new TypeError(msg);\n        }\n      }\n    });\n    if (index !== pathSegments.length || index !== segmentCount) {\n      const msg = util.format('match error: could not instantiate a path template from %s', path);\n      throw new TypeError(msg);\n    }\n    return bindings;\n  }\n  /**\n   * Renders a path template using the provided bindings.\n   *\n   * @param {Object} bindings a mapping of const names to binding strings\n   * @return {String} a rendered representation of the path template\n   * @throws {TypeError} if a key is missing, or if a sub-template cannot be\n   *   parsed\n   */\n  render(bindings) {\n    const out = [];\n    let inABinding = false;\n    this.segments.forEach(segment => {\n      if (segment.kind === extras.BINDING) {\n        if (!has(bindings, segment.literal)) {\n          const msg = util.format('Value for key %s is not provided in %s', segment.literal, bindings);\n          throw new TypeError(msg);\n        }\n        const tmp = new PathTemplate(bindings[segment.literal]);\n        Array.prototype.push.apply(out, tmp.segments);\n        inABinding = true;\n      } else if (segment.kind === extras.END_BINDING) {\n        inABinding = false;\n      } else if (inABinding) {\n        return;\n      } else {\n        out.push(segment);\n      }\n    });\n    const result = formatSegments(out);\n    this.match(result);\n    return result;\n  }\n  /**\n   * Renders the path template.\n   *\n   * @return {string} contains const names matched to binding values\n   */\n  inspect() {\n    return formatSegments(this.segments);\n  }\n}\nexports.PathTemplate = PathTemplate;\n/**\n * Creates the string representattion for the segments.\n * @param {Object[]} segments - The array of segments.\n * @return {string} - A string representing segments in the path template\n *   format.\n */\nfunction formatSegments(segments) {\n  let out = '';\n  let slash = true;\n  segments.forEach(segment => {\n    if (segment.kind === extras.TERMINAL) {\n      if (slash) {\n        out += '/';\n      }\n      out += segment.literal;\n      return;\n    }\n    slash = true;\n    if (segment.kind === extras.BINDING) {\n      out += '/{' + segment.literal + '=';\n      slash = false;\n    } else {\n      out += segment.literal + '}';\n    }\n  });\n  return out.substring(1);\n}","map":{"version":3,"names":["require","has","util","extras","parser","PathTemplate","size","parseResult","segments","constructor","data","finishParse","parse","match","path","pathSegments","split","bindings","segmentCount","current","index","forEach","segment","length","kind","BINDING","literal","TERMINAL","slice","join","msg","format","TypeError","render","out","inABinding","tmp","Array","prototype","push","apply","END_BINDING","result","formatSegments","inspect","exports","slash","substring"],"sources":["../../src/pathTemplate.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}