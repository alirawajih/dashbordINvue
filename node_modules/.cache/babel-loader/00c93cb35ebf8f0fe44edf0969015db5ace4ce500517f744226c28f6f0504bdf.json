{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar Protobuf = require(\"protobufjs\");\nvar descriptor = require(\"protobufjs/ext/descriptor\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar camelCase = require(\"lodash.camelcase\");\nvar descriptorOptions = {\n  longs: String,\n  enums: String,\n  bytes: String,\n  defaults: true,\n  oneofs: true,\n  json: true\n};\nfunction joinName(baseName, name) {\n  if (baseName === '') {\n    return name;\n  } else {\n    return baseName + '.' + name;\n  }\n}\nfunction isHandledReflectionObject(obj) {\n  return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;\n}\nfunction isNamespaceBase(obj) {\n  return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n  var objName = joinName(parentName, obj.name);\n  if (isHandledReflectionObject(obj)) {\n    return [[objName, obj]];\n  } else {\n    if (isNamespaceBase(obj) && typeof obj.nested !== undefined) {\n      return Object.keys(obj.nested).map(function (name) {\n        return getAllHandledReflectionObjects(obj.nested[name], objName);\n      }).reduce(function (accumulator, currentValue) {\n        return accumulator.concat(currentValue);\n      }, []);\n    }\n  }\n  return [];\n}\nfunction createDeserializer(cls, options) {\n  return function deserialize(argBuf) {\n    return cls.toObject(cls.decode(argBuf), options);\n  };\n}\nfunction createSerializer(cls) {\n  return function serialize(arg) {\n    var message = cls.fromObject(arg);\n    return cls.encode(message).finish();\n  };\n}\nfunction createMethodDefinition(method, serviceName, options) {\n  /* This is only ever called after the corresponding root.resolveAll(), so we\n   * can assume that the resolved request and response types are non-null */\n  var requestType = method.resolvedRequestType;\n  var responseType = method.resolvedResponseType;\n  return {\n    path: '/' + serviceName + '/' + method.name,\n    requestStream: !!method.requestStream,\n    responseStream: !!method.responseStream,\n    requestSerialize: createSerializer(requestType),\n    requestDeserialize: createDeserializer(requestType, options),\n    responseSerialize: createSerializer(responseType),\n    responseDeserialize: createDeserializer(responseType, options),\n    // TODO(murgatroid99): Find a better way to handle this\n    originalName: camelCase(method.name),\n    requestType: createMessageDefinition(requestType),\n    responseType: createMessageDefinition(responseType)\n  };\n}\nfunction createServiceDefinition(service, name, options) {\n  var def = {};\n  for (var _i = 0, _a = service.methodsArray; _i < _a.length; _i++) {\n    var method = _a[_i];\n    def[method.name] = createMethodDefinition(method, name, options);\n  }\n  return def;\n}\nvar fileDescriptorCache = new Map();\nfunction getFileDescriptors(root) {\n  if (fileDescriptorCache.has(root)) {\n    return fileDescriptorCache.get(root);\n  } else {\n    var descriptorList = root.toDescriptor('proto3').file;\n    var bufferList = descriptorList.map(function (value) {\n      return Buffer.from(descriptor.FileDescriptorProto.encode(value).finish());\n    });\n    fileDescriptorCache.set(root, bufferList);\n    return bufferList;\n  }\n}\nfunction createMessageDefinition(message) {\n  var messageDescriptor = message.toDescriptor('proto3');\n  return {\n    format: 'Protocol Buffer 3 DescriptorProto',\n    type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n    fileDescriptorProtos: getFileDescriptors(message.root)\n  };\n}\nfunction createEnumDefinition(enumType) {\n  var enumDescriptor = enumType.toDescriptor('proto3');\n  return {\n    format: 'Protocol Buffer 3 EnumDescriptorProto',\n    type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n    fileDescriptorProtos: getFileDescriptors(enumType.root)\n  };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options: Options): ServiceDefinition;\n * function createDefinition(obj: Protobuf.Type, name: string, options: Options): MessageTypeDefinition;\n * function createDefinition(obj: Protobuf.Enum, name: string, options: Options): EnumTypeDefinition;\n */\nfunction createDefinition(obj, name, options) {\n  if (obj instanceof Protobuf.Service) {\n    return createServiceDefinition(obj, name, options);\n  } else if (obj instanceof Protobuf.Type) {\n    return createMessageDefinition(obj);\n  } else if (obj instanceof Protobuf.Enum) {\n    return createEnumDefinition(obj);\n  } else {\n    throw new Error('Type mismatch in reflection object handling');\n  }\n}\nfunction createPackageDefinition(root, options) {\n  var def = {};\n  root.resolveAll();\n  for (var _i = 0, _a = getAllHandledReflectionObjects(root, ''); _i < _a.length; _i++) {\n    var _b = _a[_i],\n      name = _b[0],\n      obj = _b[1];\n    def[name] = createDefinition(obj, name, options);\n  }\n  return def;\n}\nfunction addIncludePathResolver(root, includePaths) {\n  var originalResolvePath = root.resolvePath;\n  root.resolvePath = function (origin, target) {\n    if (path.isAbsolute(target)) {\n      return target;\n    }\n    for (var _i = 0, includePaths_1 = includePaths; _i < includePaths_1.length; _i++) {\n      var directory = includePaths_1[_i];\n      var fullPath = path.join(directory, target);\n      try {\n        fs.accessSync(fullPath, fs.constants.R_OK);\n        return fullPath;\n      } catch (err) {\n        continue;\n      }\n    }\n    return originalResolvePath(origin, target);\n  };\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename The file path to load. Can be an absolute path or relative to\n *     an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\nfunction load(filename, options) {\n  var root = new Protobuf.Root();\n  options = options || {};\n  if (!!options.includeDirs) {\n    if (!(options.includeDirs instanceof Array)) {\n      return Promise.reject(new Error('The includeDirs option must be an array'));\n    }\n    addIncludePathResolver(root, options.includeDirs);\n  }\n  return root.load(filename, options).then(function (loadedRoot) {\n    loadedRoot.resolveAll();\n    return createPackageDefinition(root, options);\n  });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n  var root = new Protobuf.Root();\n  options = options || {};\n  if (!!options.includeDirs) {\n    if (!(options.includeDirs instanceof Array)) {\n      throw new Error('The include option must be an array');\n    }\n    addIncludePathResolver(root, options.includeDirs);\n  }\n  var loadedRoot = root.loadSync(filename, options);\n  loadedRoot.resolveAll();\n  return createPackageDefinition(root, options);\n}\nexports.loadSync = loadSync;","map":{"version":3,"names":["Object","defineProperty","exports","value","Protobuf","require","descriptor","fs","path","camelCase","descriptorOptions","longs","String","enums","bytes","defaults","oneofs","json","joinName","baseName","name","isHandledReflectionObject","obj","Service","Type","Enum","isNamespaceBase","Namespace","Root","getAllHandledReflectionObjects","parentName","objName","nested","undefined","keys","map","reduce","accumulator","currentValue","concat","createDeserializer","cls","options","deserialize","argBuf","toObject","decode","createSerializer","serialize","arg","message","fromObject","encode","finish","createMethodDefinition","method","serviceName","requestType","resolvedRequestType","responseType","resolvedResponseType","requestStream","responseStream","requestSerialize","requestDeserialize","responseSerialize","responseDeserialize","originalName","createMessageDefinition","createServiceDefinition","service","def","_i","_a","methodsArray","length","fileDescriptorCache","Map","getFileDescriptors","root","has","get","descriptorList","toDescriptor","file","bufferList","Buffer","from","FileDescriptorProto","set","messageDescriptor","format","type","$type","fileDescriptorProtos","createEnumDefinition","enumType","enumDescriptor","createDefinition","Error","createPackageDefinition","resolveAll","_b","addIncludePathResolver","includePaths","originalResolvePath","resolvePath","origin","target","isAbsolute","includePaths_1","directory","fullPath","join","accessSync","constants","R_OK","err","load","filename","includeDirs","Array","Promise","reject","then","loadedRoot","loadSync"],"sources":["/var/www/html/project/Dash_Vuexy-master/node_modules/@grpc/proto-loader/build/src/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar Protobuf = require(\"protobufjs\");\nvar descriptor = require(\"protobufjs/ext/descriptor\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar camelCase = require(\"lodash.camelcase\");\nvar descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true\n};\nfunction joinName(baseName, name) {\n    if (baseName === '') {\n        return name;\n    }\n    else {\n        return baseName + '.' + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    var objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [[objName, obj]];\n    }\n    else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== undefined) {\n            return Object.keys(obj.nested).map(function (name) {\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            }).reduce(function (accumulator, currentValue) { return accumulator.concat(currentValue); }, []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        var message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction createMethodDefinition(method, serviceName, options) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */\n    var requestType = method.resolvedRequestType;\n    var responseType = method.resolvedResponseType;\n    return {\n        path: '/' + serviceName + '/' + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType),\n        responseType: createMessageDefinition(responseType)\n    };\n}\nfunction createServiceDefinition(service, name, options) {\n    var def = {};\n    for (var _i = 0, _a = service.methodsArray; _i < _a.length; _i++) {\n        var method = _a[_i];\n        def[method.name] = createMethodDefinition(method, name, options);\n    }\n    return def;\n}\nvar fileDescriptorCache = new Map();\nfunction getFileDescriptors(root) {\n    if (fileDescriptorCache.has(root)) {\n        return fileDescriptorCache.get(root);\n    }\n    else {\n        var descriptorList = root.toDescriptor('proto3').file;\n        var bufferList = descriptorList.map(function (value) { return Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()); });\n        fileDescriptorCache.set(root, bufferList);\n        return bufferList;\n    }\n}\nfunction createMessageDefinition(message) {\n    var messageDescriptor = message.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 DescriptorProto',\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: getFileDescriptors(message.root)\n    };\n}\nfunction createEnumDefinition(enumType) {\n    var enumDescriptor = enumType.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 EnumDescriptorProto',\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: getFileDescriptors(enumType.root)\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options: Options): ServiceDefinition;\n * function createDefinition(obj: Protobuf.Type, name: string, options: Options): MessageTypeDefinition;\n * function createDefinition(obj: Protobuf.Enum, name: string, options: Options): EnumTypeDefinition;\n */\nfunction createDefinition(obj, name, options) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options);\n    }\n    else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj);\n    }\n    else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj);\n    }\n    else {\n        throw new Error('Type mismatch in reflection object handling');\n    }\n}\nfunction createPackageDefinition(root, options) {\n    var def = {};\n    root.resolveAll();\n    for (var _i = 0, _a = getAllHandledReflectionObjects(root, ''); _i < _a.length; _i++) {\n        var _b = _a[_i], name = _b[0], obj = _b[1];\n        def[name] = createDefinition(obj, name, options);\n    }\n    return def;\n}\nfunction addIncludePathResolver(root, includePaths) {\n    var originalResolvePath = root.resolvePath;\n    root.resolvePath = function (origin, target) {\n        if (path.isAbsolute(target)) {\n            return target;\n        }\n        for (var _i = 0, includePaths_1 = includePaths; _i < includePaths_1.length; _i++) {\n            var directory = includePaths_1[_i];\n            var fullPath = path.join(directory, target);\n            try {\n                fs.accessSync(fullPath, fs.constants.R_OK);\n                return fullPath;\n            }\n            catch (err) {\n                continue;\n            }\n        }\n        return originalResolvePath(origin, target);\n    };\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename The file path to load. Can be an absolute path or relative to\n *     an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\nfunction load(filename, options) {\n    var root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!(options.includeDirs instanceof Array)) {\n            return Promise.reject(new Error('The includeDirs option must be an array'));\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    return root.load(filename, options).then(function (loadedRoot) {\n        loadedRoot.resolveAll();\n        return createPackageDefinition(root, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    var root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!(options.includeDirs instanceof Array)) {\n            throw new Error('The include option must be an array');\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    var loadedRoot = root.loadSync(filename, options);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(root, options);\n}\nexports.loadSync = loadSync;\n//# sourceMappingURL=index.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}