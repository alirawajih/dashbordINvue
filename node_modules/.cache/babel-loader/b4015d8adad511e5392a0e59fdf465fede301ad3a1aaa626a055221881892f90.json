{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst client_1 = require(\"./client\");\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */\nconst requesterFuncs = {\n  unary: client_1.Client.prototype.makeUnaryRequest,\n  server_stream: client_1.Client.prototype.makeServerStreamRequest,\n  client_stream: client_1.Client.prototype.makeClientStreamRequest,\n  bidi: client_1.Client.prototype.makeBidiStreamRequest\n};\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @param methods An object mapping method names to\n *     method attributes\n * @param serviceName The fully qualified name of the service\n * @param classOptions An options object.\n * @return New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */\nfunction makeClientConstructor(methods, serviceName, classOptions) {\n  if (!classOptions) {\n    classOptions = {};\n  }\n  class ServiceClientImpl extends client_1.Client {}\n  Object.keys(methods).forEach(name => {\n    const attrs = methods[name];\n    let methodType;\n    // TODO(murgatroid99): Verify that we don't need this anymore\n    if (typeof name === 'string' && name.charAt(0) === '$') {\n      throw new Error('Method names cannot start with $');\n    }\n    if (attrs.requestStream) {\n      if (attrs.responseStream) {\n        methodType = 'bidi';\n      } else {\n        methodType = 'client_stream';\n      }\n    } else {\n      if (attrs.responseStream) {\n        methodType = 'server_stream';\n      } else {\n        methodType = 'unary';\n      }\n    }\n    const serialize = attrs.requestSerialize;\n    const deserialize = attrs.responseDeserialize;\n    const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\n    ServiceClientImpl.prototype[name] = methodFunc;\n    // Associate all provided attributes with the method\n    Object.assign(ServiceClientImpl.prototype[name], attrs);\n    if (attrs.originalName) {\n      ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name];\n    }\n  });\n  ServiceClientImpl.service = methods;\n  return ServiceClientImpl;\n}\nexports.makeClientConstructor = makeClientConstructor;\nfunction partial(fn, path, serialize, deserialize) {\n  // tslint:disable-next-line:no-any\n  return function (...args) {\n    return fn.call(this, path, serialize, deserialize, ...args);\n  };\n}\nfunction isProtobufTypeDefinition(obj) {\n  return 'format' in obj;\n}\n/**\n * Load a gRPC package definition as a gRPC object hierarchy.\n * @param packageDef The package definition object.\n * @return The resulting gRPC object.\n */\nfunction loadPackageDefinition(packageDef) {\n  const result = {};\n  for (const serviceFqn in packageDef) {\n    if (packageDef.hasOwnProperty(serviceFqn)) {\n      const service = packageDef[serviceFqn];\n      const nameComponents = serviceFqn.split('.');\n      const serviceName = nameComponents[nameComponents.length - 1];\n      let current = result;\n      for (const packageName of nameComponents.slice(0, -1)) {\n        if (!current[packageName]) {\n          current[packageName] = {};\n        }\n        current = current[packageName];\n      }\n      if (isProtobufTypeDefinition(service)) {\n        current[serviceName] = service;\n      } else {\n        current[serviceName] = makeClientConstructor(service, serviceName, {});\n      }\n    }\n  }\n  return result;\n}\nexports.loadPackageDefinition = loadPackageDefinition;","map":{"version":3,"names":["Object","defineProperty","exports","value","client_1","require","requesterFuncs","unary","Client","prototype","makeUnaryRequest","server_stream","makeServerStreamRequest","client_stream","makeClientStreamRequest","bidi","makeBidiStreamRequest","makeClientConstructor","methods","serviceName","classOptions","ServiceClientImpl","keys","forEach","name","attrs","methodType","charAt","Error","requestStream","responseStream","serialize","requestSerialize","deserialize","responseDeserialize","methodFunc","partial","path","assign","originalName","service","fn","args","call","isProtobufTypeDefinition","obj","loadPackageDefinition","packageDef","result","serviceFqn","hasOwnProperty","nameComponents","split","length","current","packageName","slice"],"sources":["/var/www/html/project/Dash_Vuexy-master/node_modules/@grpc/grpc-js/build/src/make-client.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst client_1 = require(\"./client\");\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */\nconst requesterFuncs = {\n    unary: client_1.Client.prototype.makeUnaryRequest,\n    server_stream: client_1.Client.prototype.makeServerStreamRequest,\n    client_stream: client_1.Client.prototype.makeClientStreamRequest,\n    bidi: client_1.Client.prototype.makeBidiStreamRequest\n};\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @param methods An object mapping method names to\n *     method attributes\n * @param serviceName The fully qualified name of the service\n * @param classOptions An options object.\n * @return New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */\nfunction makeClientConstructor(methods, serviceName, classOptions) {\n    if (!classOptions) {\n        classOptions = {};\n    }\n    class ServiceClientImpl extends client_1.Client {\n    }\n    Object.keys(methods).forEach((name) => {\n        const attrs = methods[name];\n        let methodType;\n        // TODO(murgatroid99): Verify that we don't need this anymore\n        if (typeof name === 'string' && name.charAt(0) === '$') {\n            throw new Error('Method names cannot start with $');\n        }\n        if (attrs.requestStream) {\n            if (attrs.responseStream) {\n                methodType = 'bidi';\n            }\n            else {\n                methodType = 'client_stream';\n            }\n        }\n        else {\n            if (attrs.responseStream) {\n                methodType = 'server_stream';\n            }\n            else {\n                methodType = 'unary';\n            }\n        }\n        const serialize = attrs.requestSerialize;\n        const deserialize = attrs.responseDeserialize;\n        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\n        ServiceClientImpl.prototype[name] = methodFunc;\n        // Associate all provided attributes with the method\n        Object.assign(ServiceClientImpl.prototype[name], attrs);\n        if (attrs.originalName) {\n            ServiceClientImpl.prototype[attrs.originalName] =\n                ServiceClientImpl.prototype[name];\n        }\n    });\n    ServiceClientImpl.service = methods;\n    return ServiceClientImpl;\n}\nexports.makeClientConstructor = makeClientConstructor;\nfunction partial(fn, path, serialize, deserialize) {\n    // tslint:disable-next-line:no-any\n    return function (...args) {\n        return fn.call(this, path, serialize, deserialize, ...args);\n    };\n}\nfunction isProtobufTypeDefinition(obj) {\n    return 'format' in obj;\n}\n/**\n * Load a gRPC package definition as a gRPC object hierarchy.\n * @param packageDef The package definition object.\n * @return The resulting gRPC object.\n */\nfunction loadPackageDefinition(packageDef) {\n    const result = {};\n    for (const serviceFqn in packageDef) {\n        if (packageDef.hasOwnProperty(serviceFqn)) {\n            const service = packageDef[serviceFqn];\n            const nameComponents = serviceFqn.split('.');\n            const serviceName = nameComponents[nameComponents.length - 1];\n            let current = result;\n            for (const packageName of nameComponents.slice(0, -1)) {\n                if (!current[packageName]) {\n                    current[packageName] = {};\n                }\n                current = current[packageName];\n            }\n            if (isProtobufTypeDefinition(service)) {\n                current[serviceName] = service;\n            }\n            else {\n                current[serviceName] = makeClientConstructor(service, serviceName, {});\n            }\n        }\n    }\n    return result;\n}\nexports.loadPackageDefinition = loadPackageDefinition;\n//# sourceMappingURL=make-client.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}