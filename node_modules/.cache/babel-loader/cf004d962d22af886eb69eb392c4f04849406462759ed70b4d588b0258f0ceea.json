{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.regexp.flags.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst zlib = require(\"zlib\");\nconst filter_1 = require(\"./filter\");\nclass CompressionHandler {\n  /**\n   * @param message Raw uncompressed message bytes\n   * @param compress Indicates whether the message should be compressed\n   * @return Framed message, compressed if applicable\n   */\n  async writeMessage(message, compress) {\n    let messageBuffer = message;\n    if (compress) {\n      messageBuffer = await this.compressMessage(messageBuffer);\n    }\n    const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n    output.writeUInt8(compress ? 1 : 0, 0);\n    output.writeUInt32BE(messageBuffer.length, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n  /**\n   * @param data Framed message, possibly compressed\n   * @return Uncompressed message\n   */\n  async readMessage(data) {\n    const compressed = data.readUInt8(0) === 1;\n    let messageBuffer = data.slice(5);\n    if (compressed) {\n      messageBuffer = await this.decompressMessage(messageBuffer);\n    }\n    return messageBuffer;\n  }\n}\nclass IdentityHandler extends CompressionHandler {\n  async compressMessage(message) {\n    return message;\n  }\n  async writeMessage(message, compress) {\n    const output = Buffer.allocUnsafe(message.length + 5);\n    /* With \"identity\" compression, messages should always be marked as\n     * uncompressed */\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(message.length, 1);\n    message.copy(output, 5);\n    return output;\n  }\n  decompressMessage(message) {\n    return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n  }\n}\nclass DeflateHandler extends CompressionHandler {\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.deflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.inflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n}\nclass GzipHandler extends CompressionHandler {\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.gzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.unzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n}\nclass UnknownHandler extends CompressionHandler {\n  constructor(compressionName) {\n    super();\n    this.compressionName = compressionName;\n  }\n  compressMessage(message) {\n    return Promise.reject(new Error(`Received message compressed wth unsupported compression method ${this.compressionName}`));\n  }\n  decompressMessage(message) {\n    // This should be unreachable\n    return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n  }\n}\nfunction getCompressionHandler(compressionName) {\n  switch (compressionName) {\n    case 'identity':\n      return new IdentityHandler();\n    case 'deflate':\n      return new DeflateHandler();\n    case 'gzip':\n      return new GzipHandler();\n    default:\n      return new UnknownHandler(compressionName);\n  }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n  constructor() {\n    super(...arguments);\n    this.sendCompression = new IdentityHandler();\n    this.receiveCompression = new IdentityHandler();\n  }\n  async sendMetadata(metadata) {\n    const headers = await metadata;\n    headers.set('grpc-encoding', 'identity');\n    headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n    return headers;\n  }\n  async receiveMetadata(metadata) {\n    const headers = await metadata;\n    const receiveEncoding = headers.get('grpc-encoding');\n    if (receiveEncoding.length > 0) {\n      const encoding = receiveEncoding[0];\n      if (typeof encoding === 'string') {\n        this.receiveCompression = getCompressionHandler(encoding);\n      }\n    }\n    headers.remove('grpc-encoding');\n    headers.remove('grpc-accept-encoding');\n    return headers;\n  }\n  async sendMessage(message) {\n    /* This filter is special. The input message is the bare message bytes,\n     * and the output is a framed and possibly compressed message. For this\n     * reason, this filter should be at the bottom of the filter stack */\n    const resolvedMessage = await message;\n    const compress = resolvedMessage.flags === undefined ? false : (resolvedMessage.flags & 2 /* NoCompress */) === 0;\n    return {\n      message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n      flags: resolvedMessage.flags\n    };\n  }\n  async receiveMessage(message) {\n    /* This filter is also special. The input message is framed and possibly\n     * compressed, and the output message is deframed and uncompressed. So\n     * this is another reason that this filter should be at the bottom of the\n     * filter stack. */\n    return this.receiveCompression.readMessage(await message);\n  }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n  constructor(channel) {\n    this.channel = channel;\n  }\n  createFilter(callStream) {\n    return new CompressionFilter();\n  }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory;","map":{"version":3,"names":["require","Object","defineProperty","exports","value","zlib","filter_1","CompressionHandler","writeMessage","message","compress","messageBuffer","compressMessage","output","Buffer","allocUnsafe","length","writeUInt8","writeUInt32BE","copy","readMessage","data","compressed","readUInt8","slice","decompressMessage","IdentityHandler","Promise","reject","Error","DeflateHandler","resolve","deflate","err","inflate","GzipHandler","gzip","unzip","UnknownHandler","constructor","compressionName","getCompressionHandler","CompressionFilter","BaseFilter","arguments","sendCompression","receiveCompression","sendMetadata","metadata","headers","set","receiveMetadata","receiveEncoding","get","encoding","remove","sendMessage","resolvedMessage","flags","undefined","receiveMessage","CompressionFilterFactory","channel","createFilter","callStream"],"sources":["/var/www/html/project/Dash_Vuexy-master/node_modules/@grpc/grpc-js/build/src/compression-filter.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst zlib = require(\"zlib\");\nconst filter_1 = require(\"./filter\");\nclass CompressionHandler {\n    /**\n     * @param message Raw uncompressed message bytes\n     * @param compress Indicates whether the message should be compressed\n     * @return Framed message, compressed if applicable\n     */\n    async writeMessage(message, compress) {\n        let messageBuffer = message;\n        if (compress) {\n            messageBuffer = await this.compressMessage(messageBuffer);\n        }\n        const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n        output.writeUInt8(compress ? 1 : 0, 0);\n        output.writeUInt32BE(messageBuffer.length, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    /**\n     * @param data Framed message, possibly compressed\n     * @return Uncompressed message\n     */\n    async readMessage(data) {\n        const compressed = data.readUInt8(0) === 1;\n        let messageBuffer = data.slice(5);\n        if (compressed) {\n            messageBuffer = await this.decompressMessage(messageBuffer);\n        }\n        return messageBuffer;\n    }\n}\nclass IdentityHandler extends CompressionHandler {\n    async compressMessage(message) {\n        return message;\n    }\n    async writeMessage(message, compress) {\n        const output = Buffer.allocUnsafe(message.length + 5);\n        /* With \"identity\" compression, messages should always be marked as\n         * uncompressed */\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(message.length, 1);\n        message.copy(output, 5);\n        return output;\n    }\n    decompressMessage(message) {\n        return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n    }\n}\nclass DeflateHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.deflate(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.inflate(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass GzipHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.gzip(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.unzip(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass UnknownHandler extends CompressionHandler {\n    constructor(compressionName) {\n        super();\n        this.compressionName = compressionName;\n    }\n    compressMessage(message) {\n        return Promise.reject(new Error(`Received message compressed wth unsupported compression method ${this.compressionName}`));\n    }\n    decompressMessage(message) {\n        // This should be unreachable\n        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n    }\n}\nfunction getCompressionHandler(compressionName) {\n    switch (compressionName) {\n        case 'identity':\n            return new IdentityHandler();\n        case 'deflate':\n            return new DeflateHandler();\n        case 'gzip':\n            return new GzipHandler();\n        default:\n            return new UnknownHandler(compressionName);\n    }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n    constructor() {\n        super(...arguments);\n        this.sendCompression = new IdentityHandler();\n        this.receiveCompression = new IdentityHandler();\n    }\n    async sendMetadata(metadata) {\n        const headers = await metadata;\n        headers.set('grpc-encoding', 'identity');\n        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n        return headers;\n    }\n    async receiveMetadata(metadata) {\n        const headers = await metadata;\n        const receiveEncoding = headers.get('grpc-encoding');\n        if (receiveEncoding.length > 0) {\n            const encoding = receiveEncoding[0];\n            if (typeof encoding === 'string') {\n                this.receiveCompression = getCompressionHandler(encoding);\n            }\n        }\n        headers.remove('grpc-encoding');\n        headers.remove('grpc-accept-encoding');\n        return headers;\n    }\n    async sendMessage(message) {\n        /* This filter is special. The input message is the bare message bytes,\n         * and the output is a framed and possibly compressed message. For this\n         * reason, this filter should be at the bottom of the filter stack */\n        const resolvedMessage = await message;\n        const compress = resolvedMessage.flags === undefined ?\n            false :\n            (resolvedMessage.flags & 2 /* NoCompress */) === 0;\n        return {\n            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n            flags: resolvedMessage.flags\n        };\n    }\n    async receiveMessage(message) {\n        /* This filter is also special. The input message is framed and possibly\n         * compressed, and the output message is deframed and uncompressed. So\n         * this is another reason that this filter should be at the bottom of the\n         * filter stack. */\n        return this.receiveCompression.readMessage(await message);\n    }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n    constructor(channel) {\n        this.channel = channel;\n    }\n    createFilter(callStream) {\n        return new CompressionFilter();\n    }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory;\n//# sourceMappingURL=compression-filter.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}