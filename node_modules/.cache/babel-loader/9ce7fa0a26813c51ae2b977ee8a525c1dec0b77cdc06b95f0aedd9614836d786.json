{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/web.immediate.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst call_1 = require(\"./call\");\nconst channel_1 = require(\"./channel\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\n// This symbol must be exported (for now).\n// See: https://github.com/Microsoft/TypeScript/issues/20080\nexports.kChannel = Symbol();\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\nclass Client {\n  constructor(address, credentials, options = {}) {\n    if (options.channelOverride) {\n      this[exports.kChannel] = options.channelOverride;\n    } else if (options.channelFactoryOverride) {\n      this[exports.kChannel] = options.channelFactoryOverride(address, credentials, options);\n    } else {\n      this[exports.kChannel] = new channel_1.Http2Channel(address, credentials, options);\n    }\n  }\n  close() {\n    this[exports.kChannel].close();\n  }\n  getChannel() {\n    return this[exports.kChannel];\n  }\n  waitForReady(deadline, callback) {\n    const checkState = err => {\n      if (err) {\n        callback(new Error('Failed to connect before the deadline'));\n        return;\n      }\n      let newState;\n      try {\n        newState = this[exports.kChannel].getConnectivityState(true);\n      } catch (e) {\n        callback(new Error('The channel has been closed'));\n        return;\n      }\n      if (newState === channel_1.ConnectivityState.READY) {\n        callback();\n      } else {\n        try {\n          this[exports.kChannel].watchConnectivityState(newState, deadline, checkState);\n        } catch (e) {\n          callback(new Error('The channel has been closed'));\n        }\n      }\n    };\n    setImmediate(checkState);\n  }\n  handleUnaryResponse(call, deserialize, callback) {\n    let responseMessage = null;\n    call.on('data', data => {\n      if (responseMessage != null) {\n        call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n      }\n      try {\n        responseMessage = deserialize(data);\n      } catch (e) {\n        call.cancelWithStatus(constants_1.Status.INTERNAL, 'Failed to parse server response');\n      }\n    });\n    call.on('end', () => {\n      if (responseMessage == null) {\n        call.cancelWithStatus(constants_1.Status.INTERNAL, 'Not enough responses received');\n      }\n    });\n    call.on('status', status => {\n      /* We assume that call emits status after it emits end, and that it\n       * accounts for any cancelWithStatus calls up until it emits status.\n       * Therefore, considering the above event handlers, status.code should be\n       * OK if and only if we have a non-null responseMessage */\n      if (status.code === constants_1.Status.OK) {\n        callback(null, responseMessage);\n      } else {\n        const error = Object.assign(new Error(status.details), status);\n        callback(error);\n      }\n    });\n  }\n  checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n    if (arg1 instanceof Function) {\n      return {\n        metadata: new metadata_1.Metadata(),\n        options: {},\n        callback: arg1\n      };\n    } else if (arg2 instanceof Function) {\n      if (arg1 instanceof metadata_1.Metadata) {\n        return {\n          metadata: arg1,\n          options: {},\n          callback: arg2\n        };\n      } else {\n        return {\n          metadata: new metadata_1.Metadata(),\n          options: arg1,\n          callback: arg2\n        };\n      }\n    } else {\n      if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && arg3 instanceof Function)) {\n        throw new Error('Incorrect arguments passed');\n      }\n      return {\n        metadata: arg1,\n        options: arg2,\n        callback: arg3\n      };\n    }\n  }\n  makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n    ({\n      metadata,\n      options,\n      callback\n    } = this.checkOptionalUnaryResponseArguments(metadata, options, callback));\n    const call = this[exports.kChannel].createCall(method, options.deadline, options.host, options.parent, options.propagate_flags);\n    if (options.credentials) {\n      call.setCredentials(options.credentials);\n    }\n    const message = serialize(argument);\n    const writeObj = {\n      message\n    };\n    call.sendMetadata(metadata);\n    call.write(writeObj);\n    call.end();\n    this.handleUnaryResponse(call, deserialize, callback);\n    return new call_1.ClientUnaryCallImpl(call);\n  }\n  makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n    ({\n      metadata,\n      options,\n      callback\n    } = this.checkOptionalUnaryResponseArguments(metadata, options, callback));\n    const call = this[exports.kChannel].createCall(method, options.deadline, options.host, options.parent, options.propagate_flags);\n    if (options.credentials) {\n      call.setCredentials(options.credentials);\n    }\n    call.sendMetadata(metadata);\n    this.handleUnaryResponse(call, deserialize, callback);\n    return new call_1.ClientWritableStreamImpl(call, serialize);\n  }\n  checkMetadataAndOptions(arg1, arg2) {\n    let metadata;\n    let options;\n    if (arg1 instanceof metadata_1.Metadata) {\n      metadata = arg1;\n      if (arg2) {\n        options = arg2;\n      } else {\n        options = {};\n      }\n    } else {\n      if (arg1) {\n        options = arg1;\n      } else {\n        options = {};\n      }\n      metadata = new metadata_1.Metadata();\n    }\n    return {\n      metadata,\n      options\n    };\n  }\n  makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n    ({\n      metadata,\n      options\n    } = this.checkMetadataAndOptions(metadata, options));\n    const call = this[exports.kChannel].createCall(method, options.deadline, options.host, options.parent, options.propagate_flags);\n    if (options.credentials) {\n      call.setCredentials(options.credentials);\n    }\n    const message = serialize(argument);\n    const writeObj = {\n      message\n    };\n    call.sendMetadata(metadata);\n    call.write(writeObj);\n    call.end();\n    return new call_1.ClientReadableStreamImpl(call, deserialize);\n  }\n  makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n    ({\n      metadata,\n      options\n    } = this.checkMetadataAndOptions(metadata, options));\n    const call = this[exports.kChannel].createCall(method, options.deadline, options.host, options.parent, options.propagate_flags);\n    if (options.credentials) {\n      call.setCredentials(options.credentials);\n    }\n    call.sendMetadata(metadata);\n    return new call_1.ClientDuplexStreamImpl(call, serialize, deserialize);\n  }\n}\nexports.Client = Client;","map":{"version":3,"names":["require","Object","defineProperty","exports","value","call_1","channel_1","constants_1","metadata_1","kChannel","Symbol","Client","constructor","address","credentials","options","channelOverride","channelFactoryOverride","Http2Channel","close","getChannel","waitForReady","deadline","callback","checkState","err","Error","newState","getConnectivityState","e","ConnectivityState","READY","watchConnectivityState","setImmediate","handleUnaryResponse","call","deserialize","responseMessage","on","data","cancelWithStatus","Status","INTERNAL","status","code","OK","error","assign","details","checkOptionalUnaryResponseArguments","arg1","arg2","arg3","Function","metadata","Metadata","makeUnaryRequest","method","serialize","argument","createCall","host","parent","propagate_flags","setCredentials","message","writeObj","sendMetadata","write","end","ClientUnaryCallImpl","makeClientStreamRequest","ClientWritableStreamImpl","checkMetadataAndOptions","makeServerStreamRequest","ClientReadableStreamImpl","makeBidiStreamRequest","ClientDuplexStreamImpl"],"sources":["/var/www/html/project/Dash_Vuexy-master/node_modules/@grpc/grpc-js/build/src/client.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst call_1 = require(\"./call\");\nconst channel_1 = require(\"./channel\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\n// This symbol must be exported (for now).\n// See: https://github.com/Microsoft/TypeScript/issues/20080\nexports.kChannel = Symbol();\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\nclass Client {\n    constructor(address, credentials, options = {}) {\n        if (options.channelOverride) {\n            this[exports.kChannel] = options.channelOverride;\n        }\n        else if (options.channelFactoryOverride) {\n            this[exports.kChannel] =\n                options.channelFactoryOverride(address, credentials, options);\n        }\n        else {\n            this[exports.kChannel] = new channel_1.Http2Channel(address, credentials, options);\n        }\n    }\n    close() {\n        this[exports.kChannel].close();\n    }\n    getChannel() {\n        return this[exports.kChannel];\n    }\n    waitForReady(deadline, callback) {\n        const checkState = (err) => {\n            if (err) {\n                callback(new Error('Failed to connect before the deadline'));\n                return;\n            }\n            let newState;\n            try {\n                newState = this[exports.kChannel].getConnectivityState(true);\n            }\n            catch (e) {\n                callback(new Error('The channel has been closed'));\n                return;\n            }\n            if (newState === channel_1.ConnectivityState.READY) {\n                callback();\n            }\n            else {\n                try {\n                    this[exports.kChannel].watchConnectivityState(newState, deadline, checkState);\n                }\n                catch (e) {\n                    callback(new Error('The channel has been closed'));\n                }\n            }\n        };\n        setImmediate(checkState);\n    }\n    handleUnaryResponse(call, deserialize, callback) {\n        let responseMessage = null;\n        call.on('data', (data) => {\n            if (responseMessage != null) {\n                call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n            }\n            try {\n                responseMessage = deserialize(data);\n            }\n            catch (e) {\n                call.cancelWithStatus(constants_1.Status.INTERNAL, 'Failed to parse server response');\n            }\n        });\n        call.on('end', () => {\n            if (responseMessage == null) {\n                call.cancelWithStatus(constants_1.Status.INTERNAL, 'Not enough responses received');\n            }\n        });\n        call.on('status', (status) => {\n            /* We assume that call emits status after it emits end, and that it\n             * accounts for any cancelWithStatus calls up until it emits status.\n             * Therefore, considering the above event handlers, status.code should be\n             * OK if and only if we have a non-null responseMessage */\n            if (status.code === constants_1.Status.OK) {\n                callback(null, responseMessage);\n            }\n            else {\n                const error = Object.assign(new Error(status.details), status);\n                callback(error);\n            }\n        });\n    }\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n        if (arg1 instanceof Function) {\n            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };\n        }\n        else if (arg2 instanceof Function) {\n            if (arg1 instanceof metadata_1.Metadata) {\n                return { metadata: arg1, options: {}, callback: arg2 };\n            }\n            else {\n                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };\n            }\n        }\n        else {\n            if (!((arg1 instanceof metadata_1.Metadata) && (arg2 instanceof Object) &&\n                (arg3 instanceof Function))) {\n                throw new Error('Incorrect arguments passed');\n            }\n            return { metadata: arg1, options: arg2, callback: arg3 };\n        }\n    }\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n        ({ metadata, options, callback } =\n            this.checkOptionalUnaryResponseArguments(metadata, options, callback));\n        const call = this[exports.kChannel].createCall(method, options.deadline, options.host, options.parent, options.propagate_flags);\n        if (options.credentials) {\n            call.setCredentials(options.credentials);\n        }\n        const message = serialize(argument);\n        const writeObj = { message };\n        call.sendMetadata(metadata);\n        call.write(writeObj);\n        call.end();\n        this.handleUnaryResponse(call, deserialize, callback);\n        return new call_1.ClientUnaryCallImpl(call);\n    }\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n        ({ metadata, options, callback } =\n            this.checkOptionalUnaryResponseArguments(metadata, options, callback));\n        const call = this[exports.kChannel].createCall(method, options.deadline, options.host, options.parent, options.propagate_flags);\n        if (options.credentials) {\n            call.setCredentials(options.credentials);\n        }\n        call.sendMetadata(metadata);\n        this.handleUnaryResponse(call, deserialize, callback);\n        return new call_1.ClientWritableStreamImpl(call, serialize);\n    }\n    checkMetadataAndOptions(arg1, arg2) {\n        let metadata;\n        let options;\n        if (arg1 instanceof metadata_1.Metadata) {\n            metadata = arg1;\n            if (arg2) {\n                options = arg2;\n            }\n            else {\n                options = {};\n            }\n        }\n        else {\n            if (arg1) {\n                options = arg1;\n            }\n            else {\n                options = {};\n            }\n            metadata = new metadata_1.Metadata();\n        }\n        return { metadata, options };\n    }\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n        ({ metadata, options } = this.checkMetadataAndOptions(metadata, options));\n        const call = this[exports.kChannel].createCall(method, options.deadline, options.host, options.parent, options.propagate_flags);\n        if (options.credentials) {\n            call.setCredentials(options.credentials);\n        }\n        const message = serialize(argument);\n        const writeObj = { message };\n        call.sendMetadata(metadata);\n        call.write(writeObj);\n        call.end();\n        return new call_1.ClientReadableStreamImpl(call, deserialize);\n    }\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n        ({ metadata, options } = this.checkMetadataAndOptions(metadata, options));\n        const call = this[exports.kChannel].createCall(method, options.deadline, options.host, options.parent, options.propagate_flags);\n        if (options.credentials) {\n            call.setCredentials(options.credentials);\n        }\n        call.sendMetadata(metadata);\n        return new call_1.ClientDuplexStreamImpl(call, serialize, deserialize);\n    }\n}\nexports.Client = Client;\n//# sourceMappingURL=client.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}