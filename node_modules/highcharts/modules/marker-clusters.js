!/**
 * Highcharts JS v11.4.8 (2024-10-09)
 *
 * Marker clusters module for Highcharts
 *
 * (c) 2010-2024 Wojciech Chmiel
 *
 * License: www.highcharts.com/license
 */function(t){"object"==typeof module&&module.exports?(t.default=t,module.exports=t):"function"==typeof define&&define.amd?define("highcharts/modules/marker-clusters",["highcharts"],function(e){return t(e),t.Highcharts=e,t}):t("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(t){"use strict";var e=t?t._modules:{};function i(e,i,s,r){e.hasOwnProperty(i)||(e[i]=r.apply(null,s),"function"==typeof CustomEvent&&t.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:i,module:e[i]}})))}i(e,"Extensions/MarkerClusters/MarkerClusterDefaults.js",[],function(){return{cluster:{enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}},tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}}}),i(e,"Extensions/MarkerClusters/MarkerClusterScatter.js",[e["Core/Animation/AnimationUtilities.js"],e["Extensions/MarkerClusters/MarkerClusterDefaults.js"],e["Core/Utilities.js"]],function(t,e,i){let{animObject:s}=t,{cluster:r}=e,{addEvent:a,defined:o,error:n,isArray:l,isFunction:p,isObject:u,isNumber:h,merge:d,objectEach:c,relativeLength:f,syncTimeout:m}=i,g={grid:function(t,e,i,s){let r,a,o,n,l;let p={},u=this.getGridOffset(),h=this.getScaledGridSize(s);for(l=0;l<t.length;l++){let s=F(this,{x:t[l],y:e[l]});r=s.x-u.plotLeft,a=s.y-u.plotTop,o=Math.floor(r/h),p[n=Math.floor(a/h)+":"+o]??(p[n]=[]),p[n].push({dataIndex:i[l],x:t[l],y:e[l]})}return p},kmeans:function(t,e,i,s){let a=[],o=[],n={},l=s.processedDistance||r.layoutAlgorithm.distance,p=s.iterations,u=0,h=!0,d=0,c=0,f,m=[];s.processedGridSize=s.processedDistance;let g=this.markerClusterAlgorithms?this.markerClusterAlgorithms.grid.call(this,t,e,i,s):{};for(let t in g)g[t].length>1&&(f=S(g[t]),a.push({posX:f.x,posY:f.y,oldX:0,oldY:0,startPointsLen:g[t].length,points:[]}));for(;h;){for(let t of a)t.points.length=0;o.length=0;for(let s=0;s<t.length;s++)d=t[s],c=e[s],(m=this.getClusterDistancesFromPoint(a,d,c)).length&&m[0].distance<l?a[m[0].clusterIndex].points.push({x:d,y:c,dataIndex:i[s]}):o.push({x:d,y:c,dataIndex:i[s]});for(let t=0;t<a.length;t++)1===a[t].points.length&&(m=this.getClusterDistancesFromPoint(a,a[t].points[0].x,a[t].points[0].y))[1].distance<l&&(a[m[1].clusterIndex].points.push(a[t].points[0]),a[m[0].clusterIndex].points.length=0);h=!1;for(let t=0;t<a.length;t++)f=S(a[t].points),a[t].oldX=a[t].posX,a[t].oldY=a[t].posY,a[t].posX=f.x,a[t].posY=f.y,(a[t].posX>a[t].oldX+1||a[t].posX<a[t].oldX-1||a[t].posY>a[t].oldY+1||a[t].posY<a[t].oldY-1)&&(h=!0);p&&(h=u<p-1),u++}for(let t=0,e=a.length;t<e;++t)n["cluster"+t]=a[t].points;for(let t=0,e=o.length;t<e;++t)n["noise"+t]=[o[t]];return n},optimizedKmeans:function(t,e,i,s){let a=s.processedDistance||r.layoutAlgorithm.gridSize,n=this.getRealExtremes(),l=(this.options.cluster||{}).marker,p,u={},h,d;if(!this.markerClusterInfo||this.initMaxX&&this.initMaxX<n.maxX||this.initMinX&&this.initMinX>n.minX||this.initMaxY&&this.initMaxY<n.maxY||this.initMinY&&this.initMinY>n.minY)this.initMaxX=n.maxX,this.initMinX=n.minX,this.initMaxY=n.maxY,this.initMinY=n.minY,u=this.markerClusterAlgorithms?this.markerClusterAlgorithms.kmeans.call(this,t,e,i,s):{},this.baseClusters=null;else{for(let t of(this.baseClusters??(this.baseClusters={clusters:this.markerClusterInfo.clusters,noise:this.markerClusterInfo.noise}),this.baseClusters.clusters)){for(let e of(t.pointsOutside=[],t.pointsInside=[],t.data)){let i=F(this,e),s=F(this,t);p=Math.sqrt(Math.pow(i.x-s.x,2)+Math.pow(i.y-s.y,2)),h=a-(d=t.clusterZone?.marker?.radius?t.clusterZone.marker.radius:l?.radius?l.radius:r.marker.radius)>=0?a-d:d,p>d+h&&o(t.pointsOutside)?t.pointsOutside.push(e):o(t.pointsInside)&&t.pointsInside.push(e)}t.pointsInside.length&&(u[t.id]=t.pointsInside);let e=0;for(let i of t.pointsOutside)u[t.id+"_noise"+e++]=[i]}for(let t of this.baseClusters.noise)u[t.id]=t.data}return u}},x,y=[],C=0;function k(t,e,i){t.attr({opacity:e}).animate({opacity:1},i)}function M(t,e,i,s){for(let r of(I(t,s,i,!0,!0),e))r.point?.destroy?.()}function I(t,e,i,s,r){t.point&&(s&&t.point.graphic&&(t.point.graphic.show(),k(t.point.graphic,e,i)),r&&t.point.dataLabel&&(t.point.dataLabel.show(),k(t.point.dataLabel,e,i)))}function S(t){let e=t.length,i=0,s=0;for(let r=0;r<e;r++)i+=t[r].x,s+=t[r].y;return{x:i/e,y:s/e}}function b(t,e){let i=[];return i.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){i[t.dataIndex]=t})}),t.noise.forEach(function(t){i[t.data[0].dataIndex]=t.data[0]}),i}function A(){return Math.random().toString(36).substring(2,7)+"-"+C++}function X(t,e,i){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),i&&t.point.dataLabel&&t.point.dataLabel.hide())}function Y(t){(t.point||t.target).firePointEvent("drillToCluster",t,function(t){let e=t.point||t.target,i=e.series,{xAxis:s,yAxis:r,chart:a}=i,{inverted:o,mapView:n,pointer:l}=a;if(i.options.cluster?.drillToCluster&&e.clusteredData){let t=e.clusteredData.map(t=>t.x).sort((t,e)=>t-e),i=e.clusteredData.map(t=>t.y).sort((t,e)=>t-e),p=t[0],u=t[t.length-1],h=i[0],d=i[i.length-1],c=Math.abs((u-p)*.1),f=Math.abs((d-h)*.1),m=Math.min(p,u)-c,g=Math.max(p,u)+c,x=Math.min(h,d)-f,y=Math.max(h,d)+f;if(n)n.fitToBounds({x1:m,x2:g,y1:x,y2:y});else if(s&&r){let t=s.toPixels(m),e=s.toPixels(g),i=r.toPixels(x),n=r.toPixels(y);o&&([t,e,i,n]=[i,n,t,e]),t>e&&([t,e]=[e,t]),i>n&&([i,n]=[n,i]),l&&(l.zoomX=!0,l.zoomY=!0),a.transform({from:{x:t,y:i,width:e-t,height:n-i}})}}})}function P(t,e){let{chart:i,xAxis:s,yAxis:r}=t;return i.mapView?i.mapView.pixelsToProjectedUnits(e):{x:s?s.toValue(e.x):0,y:r?r.toValue(e.y):0}}function D(t){let e=this.chart,i=e.mapView,r=s(this.options.cluster?.animation),a=r.duration||500,o=this.markerClusterInfo?.pointsState,n=o?.newState,l=o?.oldState,p=[],u,h,d,c=0,f=0,g=0,x=!1,y=!1;if(l&&n){let s=F(this,h=n[t.stateId]);f=s.x-(i?0:e.plotLeft),g=s.y-(i?0:e.plotTop),1===h.parentsId.length?(u=l[n?.[t.stateId].parentsId[0]],h.point?.graphic&&u.point?.plotX&&u.point.plotY&&(u.point.plotX!==h.point.plotX||u.point.plotY!==h.point.plotY)&&(d=h.point.graphic.getBBox(),c=h.point.graphic?.isImg?0:d.width/2,h.point.graphic.attr({x:u.point.plotX-c,y:u.point.plotY-c}),h.point.graphic.animate({x:f-(h.point.graphic.radius||0),y:g-(h.point.graphic.radius||0)},r,function(){y=!0,u.point?.destroy?.()}),h.point.dataLabel?.alignAttr&&u.point.dataLabel?.alignAttr&&(h.point.dataLabel.attr({x:u.point.dataLabel.alignAttr.x,y:u.point.dataLabel.alignAttr.y}),h.point.dataLabel.animate({x:h.point.dataLabel.alignAttr.x,y:h.point.dataLabel.alignAttr.y},r)))):0===h.parentsId.length?(X(h,!0,!0),m(function(){I(h,.1,r,!0,!0)},a/2)):(X(h,!0,!0),h.parentsId.forEach(function(t){l?.[t]&&(u=l[t],p.push(u),u.point?.graphic&&(x=!0,u.point.graphic.show(),u.point.graphic.animate({x:f-(u.point.graphic.radius||0),y:g-(u.point.graphic.radius||0),opacity:.4},r,function(){y=!0,M(h,p,r,.7)}),u.point.dataLabel&&-9999!==u.point.dataLabel.y&&h.point?.dataLabel?.alignAttr&&(u.point.dataLabel.show(),u.point.dataLabel.animate({x:h.point.dataLabel.alignAttr.x,y:h.point.dataLabel.alignAttr.y,opacity:.4},r))))}),m(function(){y||M(h,p,r,.85)},a),x||m(function(){M(h,p,r,.1)},a/2))}}function L(){this.markerClusterSeriesData?.forEach(t=>{t?.destroy?.()}),this.markerClusterSeriesData=null}function z(){let t,e,i,s,n,l,u,d,c,m,g,y,C,k,M;let I=this,{chart:S,xData:b,yData:A}=I,X=S.mapView,D=I.options.cluster,L=I.getRealExtremes(),z=[],w=[],E=[];if(X&&I.is("mappoint")&&b&&A&&I.options.data?.forEach((t,e)=>{let i=I.projectPoint(t);i&&(b[e]=i.x,A[e]=i.y)}),D?.enabled&&b?.length&&A?.length&&!S.polar){g=D.layoutAlgorithm.type,(k=D.layoutAlgorithm).processedGridSize=f(k.gridSize||r.layoutAlgorithm.gridSize,S.plotWidth),k.processedDistance=f(k.distance||r.layoutAlgorithm.distance,S.plotWidth),s=k.kmeansThreshold||r.layoutAlgorithm.kmeansThreshold;let X=k.processedGridSize/2,j=P(I,{x:0,y:0}),O=P(I,{x:X,y:X});n=Math.abs(j.x-O.x),l=Math.abs(j.y-O.y);for(let t=0;t<b.length;t++)!I.dataMaxX&&(o(d)&&o(u)&&o(m)&&o(c)?h(A[t])&&h(m)&&h(c)&&(d=Math.max(b[t],d),u=Math.min(b[t],u),m=Math.max(A[t]||m,m),c=Math.min(A[t]||c,c)):(d=u=b[t],m=c=A[t])),b[t]>=L.minX-n&&b[t]<=L.maxX+n&&(A[t]||L.minY)>=L.minY-l&&(A[t]||L.maxY)<=L.maxY+l&&(z.push(b[t]),w.push(A[t]),E.push(t));o(d)&&o(u)&&h(m)&&h(c)&&(I.dataMaxX=d,I.dataMinX=u,I.dataMaxY=m,I.dataMinY=c),y=(C=(p(g)?g:I.markerClusterAlgorithms?g&&I.markerClusterAlgorithms[g]?I.markerClusterAlgorithms[g]:z.length<s?I.markerClusterAlgorithms.kmeans:I.markerClusterAlgorithms.grid:()=>!1).call(this,z,w,E,k))?I.getClusteredData(C,D):C,D.animation&&I.markerClusterInfo?.pointsState?.oldState?(function(t){for(let e of Object.keys(t))t[e].point?.destroy?.()}(I.markerClusterInfo.pointsState.oldState),t=I.markerClusterInfo.pointsState.newState):t={},e=b.length,i=I.markerClusterInfo,y&&(I.processedXData=y.groupedXData,I.processedYData=y.groupedYData,I.hasGroupedData=!0,I.markerClusterInfo=y,I.groupMap=y.groupMap),x.apply(this),y&&I.markerClusterInfo&&(I.markerClusterInfo.clusters?.forEach(t=>{(M=I.points[t.index]).isCluster=!0,M.clusteredData=t.data,M.clusterPointsAmount=t.data.length,t.point=M,a(M,"click",Y)}),I.markerClusterInfo.noise?.forEach(t=>{t.point=I.points[t.index]}),D.animation&&I.markerClusterInfo&&(I.markerClusterInfo.pointsState={oldState:t,newState:I.getPointsState(y,i,e)}),D.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else x.apply(this)}function w(t,e,i){let s=[];for(let r=0;r<t.length;r++){let a=F(this,{x:e,y:i}),o=F(this,{x:t[r].posX,y:t[r].posY}),n=Math.sqrt(Math.pow(a.x-o.x,2)+Math.pow(a.y-o.y,2));s.push({clusterIndex:r,distance:n})}return s.sort((t,e)=>t.distance-e.distance)}function E(t,e){let i=[],s=[],a=[],o=[],h=[],c=Math.max(2,e.minimumClusterSize||2),f=0,m,g,x,y,C,k,M,I,b,X,Y,P;if(p(e.layoutAlgorithm.type)&&!this.isValidGroupedDataObject(t))return n("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,this.chart),!1;for(let n in t)if(t[n].length>=c){if(x=t[n],m=A(),C=x.length,e.zones)for(let t=0;t<e.zones.length;t++)C>=e.zones[t].from&&C<=e.zones[t].to&&((Y=e.zones[t]).zoneIndex=t,X=e.zones[t].marker,P=e.zones[t].className);b=S(x),"grid"!==e.layoutAlgorithm.type||e.allowOverlap?M={x:b.x,y:b.y}:(k=this.options.marker||{},M=this.preventClusterCollisions({x:b.x,y:b.y,key:n,groupedData:t,gridSize:this.getScaledGridSize(e.layoutAlgorithm),defaultRadius:k.radius||3+(k.lineWidth||0),clusterRadius:X&&X.radius?X.radius:(e.marker||{}).radius||r.marker.radius}));for(let t=0;t<C;t++)x[t].parentStateId=m;if(a.push({x:M.x,y:M.y,id:n,stateId:m,index:f,data:x,clusterZone:Y,clusterZoneClassName:P}),i.push(M.x),s.push(M.y),h.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:d(e.marker,{states:e.states},X||{})}}),this.options.data&&this.options.data.length)for(let t=0;t<C;t++)u(this.options.data[x[t].dataIndex])&&(x[t].options=this.options.data[x[t].dataIndex]);f++,X=null}else for(let e=0;e<t[n].length;e++)g=t[n][e],m=A(),I=null,y=this.options?.data?.[g.dataIndex],i.push(g.x),s.push(g.y),g.parentStateId=m,o.push({x:g.x,y:g.y,id:n,stateId:m,index:f,data:t[n]}),I=y&&"object"==typeof y&&!l(y)?d(y,{x:g.x,y:g.y}):{userOptions:y,x:g.x,y:g.y},h.push({options:I}),f++;return{clusters:a,noise:o,groupedXData:i,groupedYData:s,groupMap:h}}function j(){let{chart:t,xAxis:e,yAxis:i}=this,s=0;return{plotLeft:e&&this.dataMinX&&this.dataMaxX?e.reversed?e.toPixels(this.dataMaxX):e.toPixels(this.dataMinX):t.plotLeft,plotTop:i&&this.dataMinY&&this.dataMaxY?i.reversed?i.toPixels(this.dataMinY):i.toPixels(this.dataMaxY):t.plotTop}}function O(t,e,i){let s,r;let a=e?b(e,i):[],o=b(t,i),n={};y=[],t.clusters.forEach(t=>{n[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(t=>{n[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}});for(let t=0;t<o.length;t++)s=o[t],r=a[t],s?.parentStateId&&r?.parentStateId&&n[s.parentStateId]?.parentsId.indexOf(r.parentStateId)===-1&&(n[s.parentStateId].parentsId.push(r.parentStateId),-1===y.indexOf(r.parentStateId)&&y.push(r.parentStateId));return n}function T(){let t=this.chart,e=t.mapView?0:t.plotLeft,i=P(this,{x:e,y:t.mapView?0:t.plotTop}),s=P(this,{x:e+t.plotWidth,y:e+t.plotHeight}),r=i.x,a=s.x,o=i.y,n=s.y;return{minX:Math.min(r,a),maxX:Math.max(r,a),minY:Math.min(o,n),maxY:Math.max(o,n)}}function V(t){let e=this.xAxis,i=this.chart.mapView,s=t.processedGridSize||r.layoutAlgorithm.gridSize,a=!0,o=1,n=1;this.gridValueSize||(i?this.gridValueSize=s/i.getScale():this.gridValueSize=Math.abs(e.toValue(s)-e.toValue(0)));let l=+(s/(i?this.gridValueSize*i.getScale():e.toPixels(this.gridValueSize)-e.toPixels(0))).toFixed(14);for(;a&&1!==l;){let t=Math.pow(2,o);l>.75&&l<1.25?a=!1:l>=1/t&&l<1/t*2?(a=!1,n=t):l<=t&&l>t/2&&(a=!1,n=1/t),o++}return s/n/l}function G(){let t=this.markerClusterSeriesData,e=this.markerClusterInfo?.pointsState?.oldState,i=y.map(t=>e?.[t].point?.id||"");t?.forEach(t=>{t&&i.indexOf(t.id)!==-1?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t?.destroy?.()})}function v(t){let e=!1;return!!u(t)&&(c(t,t=>{if(e=!0,!l(t)||!t.length){e=!1;return}for(let i=0;i<t.length;i++)if(!u(t[i])||!t[i].x||!t[i].y){e=!1;return}}),e)}function R(t){let[e,i]=t.key.split(":").map(parseFloat),s=t.gridSize,a=t.groupedData,n=t.defaultRadius,l=t.clusterRadius,p=i*s,u=e*s,h=F(this,t),d=[],c=this.options.cluster?.marker,f=this.options.cluster?.zones,m=this.getGridOffset(),g=h.x,x=h.y,y=0,C=0,k,M,I,b,A,X,Y,D,L,z,w,E;g-=m.plotLeft,x-=m.plotTop;for(let r=1;r<5;r++)for(Y=0,I=r%2?-1:1,b=r<3?-1:1,A=Math.floor((g+I*l)/s),E=[(X=Math.floor((x+b*l)/s))+":"+A,X+":"+i,e+":"+A];Y<E.length;Y++)-1===d.indexOf(E[Y])&&E[Y]!==t.key&&d.push(E[Y]);for(let t of d)if(a[t]){a[t].posX||(z=S(a[t]),a[t].posX=z.x,a[t].posY=z.y);let h=F(this,{x:a[t].posX||0,y:a[t].posY||0});if(k=h.x-m.plotLeft,M=h.y-m.plotTop,[L,D]=t.split(":").map(parseFloat),f){y=a[t].length;for(let t=0;t<f.length;t++)y>=f[t].from&&y<=f[t].to&&(C=o(f[t].marker?.radius)?f[t].marker.radius||0:c?.radius?c.radius:r.marker.radius)}a[t].length>1&&0===C&&c?.radius?C=c.radius:1===a[t].length&&(C=n),w=l+C,C=0,D!==i&&Math.abs(g-k)<w&&(g=D-i<0?p+l:p+s-l),L!==e&&Math.abs(x-M)<w&&(x=L-e<0?u+l:u+s-l)}let j=P(this,{x:g+m.plotLeft,y:x+m.plotTop});return a[t.key].posX=j.x,a[t.key].posY=j.y,j}function F(t,e){let{chart:i,xAxis:s,yAxis:r}=t;return i.mapView?i.mapView.projectedUnitsToPixels(e):{x:s?s.toPixels(e.x):0,y:r?r.toPixels(e.y):0}}return{compose:function(t,i){let s=i.prototype;!s.markerClusterAlgorithms&&(x=s.generatePoints,s.markerClusterAlgorithms=g,s.animateClusterPoint=D,s.destroyClusteredData=L,s.generatePoints=z,s.getClusterDistancesFromPoint=w,s.getClusteredData=E,s.getGridOffset=j,s.getPointsState=O,s.getRealExtremes=T,s.getScaledGridSize=V,s.hideClusteredData=G,s.isValidGroupedDataObject=v,s.preventClusterCollisions=R,a(i,"destroy",s.destroyClusteredData),t.plotOptions&&(t.plotOptions.series=d(t.plotOptions.series,e)))}}}),i(e,"Extensions/MarkerClusters/MarkerClusters.js",[e["Core/Animation/AnimationUtilities.js"],e["Core/Defaults.js"],e["Core/Globals.js"],e["Extensions/MarkerClusters/MarkerClusterDefaults.js"],e["Extensions/MarkerClusters/MarkerClusterScatter.js"],e["Core/Utilities.js"]],function(t,e,i,s,r,a){let{animObject:o}=t,{defaultOptions:n}=e,{composed:l}=i,{addEvent:p,defined:u,error:h,isFunction:d,merge:c,pushUnique:f,syncTimeout:m}=a;function g(){let t=this.chart,e=0;for(let i of t.series)i.markerClusterInfo&&(e=o((i.options.cluster||{}).animation).duration||0);m(()=>{t.tooltip&&t.tooltip.destroy()},e)}function x(){for(let t of this.series||[])if(t.markerClusterInfo){let e=t.options.cluster,i=((t.markerClusterInfo||{}).pointsState||{}).oldState;if((e||{}).animation&&t.markerClusterInfo&&0===(t.chart.pointer?.pinchDown||[]).length&&"pan"!==((t.xAxis||{}).eventArgs||{}).trigger&&i&&Object.keys(i).length){for(let e of t.markerClusterInfo.clusters)t.animateClusterPoint(e);for(let e of t.markerClusterInfo.noise)t.animateClusterPoint(e)}}}function y(t){let e=(((t.point||t.target).series.options.cluster||{}).events||{}).drillToCluster;d(e)&&e.call(this,t)}function C(){if(this.dataGroup)return h("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}function k(){let t=(this.options.cluster||{}).drillToCluster;if(this.markerClusterInfo&&this.markerClusterInfo.clusters)for(let e of this.markerClusterInfo.clusters)e.point&&e.point.graphic&&(e.point.graphic.addClass("highcharts-cluster-point"),t&&e.point&&(e.point.graphic.css({cursor:"pointer"}),e.point.dataLabel&&e.point.dataLabel.css({cursor:"pointer"})),u(e.clusterZone)&&e.point.graphic.addClass(e.clusterZoneClassName||"highcharts-cluster-zone-"+e.clusterZone.zoneIndex))}return(n.plotOptions||{}).series=c((n.plotOptions||{}).series,s),{compose:function(t,e,i,s){if(f(l,"MarkerClusters")){let a=s.prototype.pointClass,{scatter:o}=s.types;p(t,"setExtremes",g),p(e,"render",x),p(a,"drillToCluster",y),p(a,"update",C),p(s,"afterRender",k),o&&r.compose(i,o)}}}}),i(e,"Extensions/MarkerClusters/MarkerClusterSymbols.js",[],function(){let t;function e(e,i,s,r){let a=s/2,o=r/2,n=t.arc(e+a,i+o,a-4,o-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),l=t.arc(e+a,i+o,a-3,o-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a-2,open:!1});return t.arc(e+a,i+o,a-1,o-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a,open:!1}).concat(l,n)}return{compose:function(i){(t=i.prototype.symbols).cluster=e}}}),i(e,"masters/modules/marker-clusters.src.js",[e["Core/Globals.js"],e["Extensions/MarkerClusters/MarkerClusters.js"],e["Extensions/MarkerClusters/MarkerClusterSymbols.js"]],function(t,e,i){return e.compose(t.Axis,t.Chart,t.defaultOptions,t.Series),i.compose(t.SVGRenderer),t})});