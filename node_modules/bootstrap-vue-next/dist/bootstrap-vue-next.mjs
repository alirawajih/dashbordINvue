var Rn = Object.defineProperty;
var Hn = (e, t, a) => t in e ? Rn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a;
var Pe = (e, t, a) => (Hn(e, typeof t != "symbol" ? t + "" : t, a), a);
import { unref as T, computed as i, ref as x, shallowRef as xa, watch as ue, getCurrentScope as to, onScopeDispose as ao, shallowReadonly as pt, watchEffect as qe, readonly as ke, isRef as lo, effectScope as Mn, toRef as u, customRef as Dn, getCurrentInstance as ra, onMounted as Xe, nextTick as Te, reactive as dt, defineComponent as z, h as ce, Teleport as Na, inject as Ee, onActivated as jn, onBeforeUnmount as oo, openBlock as g, createElementBlock as V, Fragment as pe, createElementVNode as Z, renderSlot as A, normalizeProps as _e, guardReactiveProps as Oe, createVNode as Se, withCtx as D, mergeProps as ae, normalizeClass as H, normalizeStyle as Ge, createTextVNode as de, toDisplayString as ee, createCommentVNode as Q, createApp as qn, provide as Je, createBlock as M, resolveDynamicComponent as ne, toHandlers as Gn, Transition as Wn, useSlots as Le, resolveComponent as za, withModifiers as ct, renderList as $e, withKeys as Et, TransitionGroup as Un, withDirectives as it, vShow as ia, isReactive as Kn, onUnmounted as Xn, useAttrs as no, vModelCheckbox as Jn, vModelRadio as Yn, vModelSelect as Zn, createSlots as so } from "vue";
const Qn = (e) => typeof e == "boolean" || e === "" || e === "true" || e === "false", ro = (e) => typeof e == "boolean" ? e : e === "" ? !0 : e === "true";
class Qe {
  constructor(t, a = {}) {
    Pe(this, "cancelable", !0);
    Pe(this, "componentId", null);
    Pe(this, "_defaultPrevented", !1);
    Pe(this, "eventType", "");
    Pe(this, "nativeEvent", null);
    Pe(this, "_preventDefault");
    Pe(this, "relatedTarget", null);
    Pe(this, "target", null);
    if (!t)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    Object.assign(this, Qe.Defaults, a, { eventType: t }), this._preventDefault = function() {
      this.cancelable && (this.defaultPrevented = !0);
    };
  }
  // Readable by everyone,
  // But only overwritten by inherrited constructors
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  set defaultPrevented(t) {
    this._defaultPrevented = t;
  }
  // I think this is right
  // We want to be able to have it callable to everyone,
  // But only overwritten by inherrited constructors
  get preventDefault() {
    return this._preventDefault;
  }
  // This may not be correct, because it doesn't get correct type inferences in children
  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue
  set preventDefault(t) {
    this._preventDefault = t;
  }
  static get Defaults() {
    return {
      cancelable: !0,
      componentId: null,
      eventType: "",
      nativeEvent: null,
      relatedTarget: null,
      target: null
    };
  }
}
class zt extends Qe {
  constructor(a, l = {}) {
    super(a, l);
    Pe(this, "trigger", null);
    Object.assign(this, Qe.Defaults, l, { eventType: a });
  }
  static get Defaults() {
    return {
      ...super.Defaults,
      trigger: null
    };
  }
}
class io extends Qe {
  constructor(a, l) {
    super(a, l);
    Pe(this, "from");
    Pe(this, "to");
    Pe(this, "direction");
    Object.assign(this, Qe.Defaults, l, { eventType: a });
    const { from: o, direction: n, to: r } = l;
    this.from = o, this.to = r, this.direction = n;
  }
  static get Defaults() {
    return {
      ...super.Defaults
    };
  }
}
const ya = (e) => e !== null && typeof e == "object", uo = (e) => /^[0-9]*\.?[0-9]+$/.test(String(e)), es = (e) => Object.prototype.toString.call(e) === "[object Object]", co = /_/g, fo = /([a-z])([A-Z])/g, ts = /(\s|^)(\w)/g, as = /(\s|^)(\w)/, Ut = /\s+/, ls = /^#/, os = /^#[A-Za-z]+[\w\-:.]*$/, ns = /-u-.+/, ss = /[-/\\^$*+?.()|[\]{}]/g, rs = /[\s\uFEFF\xA0]+/g, Jt = (e, t = 2) => typeof e == "string" ? e : e == null ? "" : Array.isArray(e) || es(e) && e.toString === Object.prototype.toString ? JSON.stringify(e, null, t) : String(e), ll = (e) => e.replace(co, " ").replace(fo, (t, a, l) => `${a} ${l}`).replace(as, (t, a, l) => a + l.toUpperCase()), ol = (e) => e.replace(co, " ").replace(fo, (t, a, l) => `${a} ${l}`).replace(ts, (t, a, l) => a + l.toUpperCase()), is = (e) => {
  const t = e.trim();
  return t.charAt(0).toUpperCase() + t.slice(1);
}, us = (e) => e.replace(ss, "\\$&"), ds = (e) => us(e).replace(rs, "\\s"), ma = (e) => `\\${e}`, cs = (e) => {
  const t = Jt(e), { length: a } = t, l = t.charCodeAt(0);
  return t.split("").reduce((o, n, r) => {
    const s = t.charCodeAt(r);
    return s === 0 ? `${o}ï¿½` : (
      // ... is U+007F OR
      s === 127 || // ... is in the range [\1-\1F] (U+0001 to U+001F) OR ...
      s >= 1 && s <= 31 || // ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...
      r === 0 && s >= 48 && s <= 57 || // ... is the second character and is in the range [0-9] (U+0030 to U+0039)
      // and the first character is a `-` (U+002D) ...
      r === 1 && s >= 48 && s <= 57 && l === 45 ? o + ma(`${s.toString(16)} `) : (
        // ... is the first character AND ...
        r === 0 && // ... is a `-` (U+002D) AND ...
        s === 45 && // ... there is no second character ...
        a === 1 ? o + ma(n) : (
          // ... is greater than or equal to U+0080 OR ...
          s >= 128 || // ... is `-` (U+002D) OR ...
          s === 45 || // ... is `_` (U+005F) OR ...
          s === 95 || // ... is in the range [0-9] (U+0030 to U+0039) OR ...
          s >= 48 && s <= 57 || // ... is in the range [A-Z] (U+0041 to U+005A) OR ...
          s >= 65 && s <= 90 || // ... is in the range [a-z] (U+0061 to U+007A) ...
          s >= 97 && s <= 122 ? o + n : o + ma(n)
        )
      )
    );
  }, "");
}, vo = typeof window < "u", po = typeof document < "u", fs = typeof Element < "u", vs = typeof navigator < "u", ps = vo && po && vs, nl = vo ? window : {}, Ra = po ? document : {};
(() => {
  let e = !1;
  if (ps)
    try {
      const t = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          return e = !0, e;
        }
      };
      nl.addEventListener("test", t, t), nl.removeEventListener("test", t, t);
    } catch {
      e = !1;
    }
  return e;
})();
const Ha = typeof window < "u", ms = typeof document < "u", gs = typeof navigator < "u", Ma = Ha && ms && gs, sl = Ha ? window : {}, bs = (() => {
  let e = !1;
  if (Ma)
    try {
      const t = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          e = !0;
        }
      };
      sl.addEventListener("test", t, t), sl.removeEventListener("test", t, t);
    } catch {
      e = !1;
    }
  return e;
})(), He = fs ? Element.prototype : void 0, ys = (He == null ? void 0 : He.matches) || (He == null ? void 0 : He.msMatchesSelector) || (He == null ? void 0 : He.webkitMatchesSelector), et = (e) => !!(e && e.nodeType === Node.ELEMENT_NODE), hs = (e) => et(e) ? e.getBoundingClientRect() : null, Bs = (e = []) => {
  const { activeElement: t } = document;
  return t && !e.some((a) => a === t) ? t : null;
}, Ss = (e) => et(e) && e === Bs(), ws = (e, t = {}) => {
  try {
    e.focus(t);
  } catch (a) {
    console.error(a);
  }
  return Ss(e);
}, $s = (e, t) => t && et(e) && e.getAttribute(t) || null, _s = (e) => {
  if ($s(e, "display") === "none")
    return !1;
  const t = hs(e);
  return !!(t && t.height > 0 && t.width > 0);
}, Ie = (e) => ((e == null ? void 0 : e()) ?? []).length === 0, mo = (e, t) => (et(t) ? t : Ra).querySelector(e) || null, ks = (e, t) => Array.from([(et(t) ? t : Ra).querySelectorAll(e)]), Da = (e, t) => t && et(e) ? e.getAttribute(t) : null, Cs = (e) => Ra.getElementById(/^#/.test(e) ? e.slice(1) : e) || null, Ts = (e, t, a) => {
  t && et(e) && e.setAttribute(t, a);
}, As = (e, t) => {
  t && et(e) && e.removeAttribute(t);
}, Vs = (e, t) => Jt(e).toLowerCase() === Jt(t).toLowerCase(), Mt = Ha ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || // Fallback, but not a true polyfill
// Only needed for Opera Mini
((e) => setTimeout(e, 16)) : (e) => setTimeout(e, 0), go = (e, t) => et(e) ? ys.call(e, t) : !1, Ps = (He == null ? void 0 : He.closest) || function(e) {
  let t = this;
  if (!t)
    return null;
  do {
    if (go(t, e))
      return t;
    t = t.parentElement || t.parentNode;
  } while (t !== null && t.nodeType === Node.ELEMENT_NODE);
  return null;
}, rl = (e, t, a = !1) => {
  if (!et(t))
    return null;
  const l = Ps.call(t, e);
  return a ? l : l === t ? null : l;
}, ha = (e) => {
  const t = window.getComputedStyle(e), a = t.transitionDelay.split(",")[0] || "", l = t.transitionDuration.split(",")[0] || "", o = Number(a.slice(0, -1)) * 1e3, n = Number(l.slice(0, -1)) * 1e3;
  return o + n;
}, ua = (e, t, a) => t.concat(["sm", "md", "lg", "xl", "xxl"]).reduce((l, o) => (l[e ? `${e}${o.charAt(0).toUpperCase() + o.slice(1)}` : o] = a, l), /* @__PURE__ */ Object.create(null)), bo = (e, t, a, l = a) => Object.keys(t).reduce((o, n) => (e[n] && o.push(
  [l, n.replace(a, ""), e[n]].filter((r) => r && typeof r != "boolean").join("-").toLowerCase()
), o), []), ot = (e = "") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`, It = (e) => !!(e.href || e.to), De = (e, t = {}, a = {}) => {
  const l = [e];
  let o;
  for (let n = 0; n < l.length && !o; n++) {
    const r = l[n];
    o = a[r];
  }
  return o && typeof o == "function" ? o(t) : o;
}, nt = (e, t = NaN) => Number.isInteger(e) ? e : t, Os = (e, t = NaN) => {
  const a = Number.parseInt(e, 10);
  return Number.isNaN(a) ? t : a;
}, Vt = (e, t = NaN) => {
  const a = Number.parseFloat(e.toString());
  return Number.isNaN(a) ? t : a;
}, Rt = (e, t) => Object.keys(e).filter((a) => !t.includes(a)).reduce((a, l) => ({ ...a, [l]: e[l] }), {}), Yt = (e) => Array.isArray(e) ? e.map((t) => Yt(t)) : e instanceof Date ? new Date(e.getTime()) : e && typeof e == "object" ? Object.getOwnPropertyNames(e).reduce((t, a) => (Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(e, a) ?? {}), t[a] = Yt(e[a]), t), Object.create(Object.getPrototypeOf(e))) : e, Ba = (e) => new Promise((t) => t(Yt(e))), il = (e, t) => t + (e ? is(e) : ""), ja = (e, t) => (Array.isArray(t) ? t.slice() : Object.keys(t)).reduce(
  (a, l) => (a[l] = e[l], a),
  {}
), da = (e, t) => e === !0 || e === "true" || e === "" ? "true" : e === "grammar" || e === "spelling" ? e : t === !1 ? "true" : e === !1 || e === "false" ? "false" : void 0, yo = Symbol("carousel"), ho = Symbol("tabs"), Bo = Symbol("breadcrumb"), So = Symbol("progress"), wo = Symbol("listGroup"), $o = Symbol("avatarGroup"), _o = Symbol("accordion"), ko = Symbol("checkboxGroup"), Co = Symbol("radioGroup"), qa = Symbol("collapse"), To = Symbol("collapse"), Ga = Symbol("navbar"), Sa = (e, t) => ((e == null ? void 0 : e()) ?? []).reduce((a, l) => (typeof l.type == "symbol" ? a = a.concat(l.children) : a.push(l), a), []).filter((a) => {
  var l;
  return ((l = a.type) == null ? void 0 : l.__name) === t;
});
function Ze(e) {
  return e.split("-")[1];
}
function Wa(e) {
  return e === "y" ? "height" : "width";
}
function We(e) {
  return e.split("-")[0];
}
function _t(e) {
  return ["top", "bottom"].includes(We(e)) ? "x" : "y";
}
function ul(e, t, a) {
  let { reference: l, floating: o } = e;
  const n = l.x + l.width / 2 - o.width / 2, r = l.y + l.height / 2 - o.height / 2, s = _t(t), d = Wa(s), f = l[d] / 2 - o[d] / 2, p = s === "x";
  let m;
  switch (We(t)) {
    case "top":
      m = { x: n, y: l.y - o.height };
      break;
    case "bottom":
      m = { x: n, y: l.y + l.height };
      break;
    case "right":
      m = { x: l.x + l.width, y: r };
      break;
    case "left":
      m = { x: l.x - o.width, y: r };
      break;
    default:
      m = { x: l.x, y: l.y };
  }
  switch (Ze(t)) {
    case "start":
      m[s] -= f * (a && p ? -1 : 1);
      break;
    case "end":
      m[s] += f * (a && p ? -1 : 1);
  }
  return m;
}
const Es = async (e, t, a) => {
  const { placement: l = "bottom", strategy: o = "absolute", middleware: n = [], platform: r } = a, s = n.filter(Boolean), d = await (r.isRTL == null ? void 0 : r.isRTL(t));
  let f = await r.getElementRects({ reference: e, floating: t, strategy: o }), { x: p, y: m } = ul(f, l, d), v = l, b = {}, B = 0;
  for (let w = 0; w < s.length; w++) {
    const { name: $, fn: h } = s[w], { x: S, y, data: C, reset: O } = await h({ x: p, y: m, initialPlacement: l, placement: v, strategy: o, middlewareData: b, rects: f, platform: r, elements: { reference: e, floating: t } });
    p = S ?? p, m = y ?? m, b = { ...b, [$]: { ...b[$], ...C } }, O && B <= 50 && (B++, typeof O == "object" && (O.placement && (v = O.placement), O.rects && (f = O.rects === !0 ? await r.getElementRects({ reference: e, floating: t, strategy: o }) : O.rects), { x: p, y: m } = ul(f, v, d)), w = -1);
  }
  return { x: p, y: m, placement: v, strategy: o, middlewareData: b };
};
function Ua(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function St(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function Ft(e, t) {
  var a;
  t === void 0 && (t = {});
  const { x: l, y: o, platform: n, rects: r, elements: s, strategy: d } = e, { boundary: f = "clippingAncestors", rootBoundary: p = "viewport", elementContext: m = "floating", altBoundary: v = !1, padding: b = 0 } = t, B = Ua(b), w = s[v ? m === "floating" ? "reference" : "floating" : m], $ = St(await n.getClippingRect({ element: (a = await (n.isElement == null ? void 0 : n.isElement(w))) == null || a ? w : w.contextElement || await (n.getDocumentElement == null ? void 0 : n.getDocumentElement(s.floating)), boundary: f, rootBoundary: p, strategy: d })), h = m === "floating" ? { ...r.floating, x: l, y: o } : r.reference, S = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(s.floating)), y = await (n.isElement == null ? void 0 : n.isElement(S)) && await (n.getScale == null ? void 0 : n.getScale(S)) || { x: 1, y: 1 }, C = St(n.convertOffsetParentRelativeRectToViewportRelativeRect ? await n.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: h, offsetParent: S, strategy: d }) : h);
  return { top: ($.top - C.top + B.top) / y.y, bottom: (C.bottom - $.bottom + B.bottom) / y.y, left: ($.left - C.left + B.left) / y.x, right: (C.right - $.right + B.right) / y.x };
}
const Zt = Math.min, Qt = Math.max;
function wa(e, t, a) {
  return Qt(e, Zt(t, a));
}
const Is = (e) => ({ name: "arrow", options: e, async fn(t) {
  const { element: a, padding: l = 0 } = e || {}, { x: o, y: n, placement: r, rects: s, platform: d, elements: f } = t;
  if (a == null)
    return {};
  const p = Ua(l), m = { x: o, y: n }, v = _t(r), b = Wa(v), B = await d.getDimensions(a), w = v === "y", $ = w ? "top" : "left", h = w ? "bottom" : "right", S = w ? "clientHeight" : "clientWidth", y = s.reference[b] + s.reference[v] - m[v] - s.floating[b], C = m[v] - s.reference[v], O = await (d.getOffsetParent == null ? void 0 : d.getOffsetParent(a));
  let k = O ? O[S] : 0;
  k && await (d.isElement == null ? void 0 : d.isElement(O)) || (k = f.floating[S] || s.floating[b]);
  const I = y / 2 - C / 2, F = p[$], L = k - B[b] - p[h], _ = k / 2 - B[b] / 2 + I, E = wa(F, _, L), N = Ze(r) != null && _ != E && s.reference[b] / 2 - (_ < F ? p[$] : p[h]) - B[b] / 2 < 0;
  return { [v]: m[v] - (N ? _ < F ? F - _ : L - _ : 0), data: { [v]: E, centerOffset: _ - E } };
} }), Ao = ["top", "right", "bottom", "left"], dl = Ao.reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []), Fs = { left: "right", right: "left", bottom: "top", top: "bottom" };
function ea(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Fs[t]);
}
function Vo(e, t, a) {
  a === void 0 && (a = !1);
  const l = Ze(e), o = _t(e), n = Wa(o);
  let r = o === "x" ? l === (a ? "end" : "start") ? "right" : "left" : l === "start" ? "bottom" : "top";
  return t.reference[n] > t.floating[n] && (r = ea(r)), { main: r, cross: ea(r) };
}
const Ls = { start: "end", end: "start" };
function Kt(e) {
  return e.replace(/start|end/g, (t) => Ls[t]);
}
const xs = function(e) {
  return e === void 0 && (e = {}), { name: "autoPlacement", options: e, async fn(t) {
    var a, l, o;
    const { rects: n, middlewareData: r, placement: s, platform: d, elements: f } = t, { crossAxis: p = !1, alignment: m, allowedPlacements: v = dl, autoAlignment: b = !0, ...B } = e, w = m !== void 0 || v === dl ? function(_, E, N) {
      return (_ ? [...N.filter((R) => Ze(R) === _), ...N.filter((R) => Ze(R) !== _)] : N.filter((R) => We(R) === R)).filter((R) => !_ || Ze(R) === _ || !!E && Kt(R) !== R);
    }(m || null, b, v) : v, $ = await Ft(t, B), h = ((a = r.autoPlacement) == null ? void 0 : a.index) || 0, S = w[h];
    if (S == null)
      return {};
    const { main: y, cross: C } = Vo(S, n, await (d.isRTL == null ? void 0 : d.isRTL(f.floating)));
    if (s !== S)
      return { reset: { placement: w[0] } };
    const O = [$[We(S)], $[y], $[C]], k = [...((l = r.autoPlacement) == null ? void 0 : l.overflows) || [], { placement: S, overflows: O }], I = w[h + 1];
    if (I)
      return { data: { index: h + 1, overflows: k }, reset: { placement: I } };
    const F = k.map((_) => {
      const E = Ze(_.placement);
      return [_.placement, E && p ? _.overflows.slice(0, 2).reduce((N, R) => N + R, 0) : _.overflows[0], _.overflows];
    }).sort((_, E) => _[1] - E[1]), L = ((o = F.filter((_) => _[2].slice(0, Ze(_[0]) ? 2 : 3).every((E) => E <= 0))[0]) == null ? void 0 : o[0]) || F[0][0];
    return L !== s ? { data: { index: h + 1, overflows: k }, reset: { placement: L } } : {};
  } };
}, Po = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var a;
    const { placement: l, middlewareData: o, rects: n, initialPlacement: r, platform: s, elements: d } = t, { mainAxis: f = !0, crossAxis: p = !0, fallbackPlacements: m, fallbackStrategy: v = "bestFit", fallbackAxisSideDirection: b = "none", flipAlignment: B = !0, ...w } = e, $ = We(l), h = We(r) === r, S = await (s.isRTL == null ? void 0 : s.isRTL(d.floating)), y = m || (h || !B ? [ea(r)] : function(E) {
      const N = ea(E);
      return [Kt(E), N, Kt(N)];
    }(r));
    m || b === "none" || y.push(...function(E, N, R, oe) {
      const U = Ze(E);
      let G = function(te, ve, ye) {
        const Be = ["left", "right"], ge = ["right", "left"], be = ["top", "bottom"], W = ["bottom", "top"];
        switch (te) {
          case "top":
          case "bottom":
            return ye ? ve ? ge : Be : ve ? Be : ge;
          case "left":
          case "right":
            return ve ? be : W;
          default:
            return [];
        }
      }(We(E), R === "start", oe);
      return U && (G = G.map((te) => te + "-" + U), N && (G = G.concat(G.map(Kt)))), G;
    }(r, B, b, S));
    const C = [r, ...y], O = await Ft(t, w), k = [];
    let I = ((a = o.flip) == null ? void 0 : a.overflows) || [];
    if (f && k.push(O[$]), p) {
      const { main: E, cross: N } = Vo(l, n, S);
      k.push(O[E], O[N]);
    }
    if (I = [...I, { placement: l, overflows: k }], !k.every((E) => E <= 0)) {
      var F, L;
      const E = (((F = o.flip) == null ? void 0 : F.index) || 0) + 1, N = C[E];
      if (N)
        return { data: { index: E, overflows: I }, reset: { placement: N } };
      let R = (L = I.filter((oe) => oe.overflows[0] <= 0).sort((oe, U) => oe.overflows[1] - U.overflows[1])[0]) == null ? void 0 : L.placement;
      if (!R)
        switch (v) {
          case "bestFit": {
            var _;
            const oe = (_ = I.map((U) => [U.placement, U.overflows.filter((G) => G > 0).reduce((G, te) => G + te, 0)]).sort((U, G) => U[1] - G[1])[0]) == null ? void 0 : _[0];
            oe && (R = oe);
            break;
          }
          case "initialPlacement":
            R = r;
        }
      if (l !== R)
        return { reset: { placement: R } };
    }
    return {};
  } };
};
function cl(e, t) {
  return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width };
}
function fl(e) {
  return Ao.some((t) => e[t] >= 0);
}
const Ns = function(e) {
  return e === void 0 && (e = {}), { name: "hide", options: e, async fn(t) {
    const { strategy: a = "referenceHidden", ...l } = e, { rects: o } = t;
    switch (a) {
      case "referenceHidden": {
        const n = cl(await Ft(t, { ...l, elementContext: "reference" }), o.reference);
        return { data: { referenceHiddenOffsets: n, referenceHidden: fl(n) } };
      }
      case "escaped": {
        const n = cl(await Ft(t, { ...l, altBoundary: !0 }), o.floating);
        return { data: { escapedOffsets: n, escaped: fl(n) } };
      }
      default:
        return {};
    }
  } };
};
function vl(e) {
  const t = Zt(...e.map((l) => l.left)), a = Zt(...e.map((l) => l.top));
  return { x: t, y: a, width: Qt(...e.map((l) => l.right)) - t, height: Qt(...e.map((l) => l.bottom)) - a };
}
const zs = function(e) {
  return e === void 0 && (e = {}), { name: "inline", options: e, async fn(t) {
    const { placement: a, elements: l, rects: o, platform: n, strategy: r } = t, { padding: s = 2, x: d, y: f } = e, p = Array.from(await (n.getClientRects == null ? void 0 : n.getClientRects(l.reference)) || []), m = function(w) {
      const $ = w.slice().sort((y, C) => y.y - C.y), h = [];
      let S = null;
      for (let y = 0; y < $.length; y++) {
        const C = $[y];
        !S || C.y - S.y > S.height / 2 ? h.push([C]) : h[h.length - 1].push(C), S = C;
      }
      return h.map((y) => St(vl(y)));
    }(p), v = St(vl(p)), b = Ua(s), B = await n.getElementRects({ reference: { getBoundingClientRect: function() {
      if (m.length === 2 && m[0].left > m[1].right && d != null && f != null)
        return m.find((w) => d > w.left - b.left && d < w.right + b.right && f > w.top - b.top && f < w.bottom + b.bottom) || v;
      if (m.length >= 2) {
        if (_t(a) === "x") {
          const O = m[0], k = m[m.length - 1], I = We(a) === "top", F = O.top, L = k.bottom, _ = I ? O.left : k.left, E = I ? O.right : k.right;
          return { top: F, bottom: L, left: _, right: E, width: E - _, height: L - F, x: _, y: F };
        }
        const w = We(a) === "left", $ = Qt(...m.map((O) => O.right)), h = Zt(...m.map((O) => O.left)), S = m.filter((O) => w ? O.left === h : O.right === $), y = S[0].top, C = S[S.length - 1].bottom;
        return { top: y, bottom: C, left: h, right: $, width: $ - h, height: C - y, x: h, y };
      }
      return v;
    } }, floating: l.floating, strategy: r });
    return o.reference.x !== B.reference.x || o.reference.y !== B.reference.y || o.reference.width !== B.reference.width || o.reference.height !== B.reference.height ? { reset: { rects: B } } : {};
  } };
}, Oo = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: a, y: l } = t, o = await async function(n, r) {
      const { placement: s, platform: d, elements: f } = n, p = await (d.isRTL == null ? void 0 : d.isRTL(f.floating)), m = We(s), v = Ze(s), b = _t(s) === "x", B = ["left", "top"].includes(m) ? -1 : 1, w = p && b ? -1 : 1, $ = typeof r == "function" ? r(n) : r;
      let { mainAxis: h, crossAxis: S, alignmentAxis: y } = typeof $ == "number" ? { mainAxis: $, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...$ };
      return v && typeof y == "number" && (S = v === "end" ? -1 * y : y), b ? { x: S * w, y: h * B } : { x: h * B, y: S * w };
    }(t, e);
    return { x: a + o.x, y: l + o.y, data: o };
  } };
};
function Rs(e) {
  return e === "x" ? "y" : "x";
}
const Eo = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: a, y: l, placement: o } = t, { mainAxis: n = !0, crossAxis: r = !1, limiter: s = { fn: ($) => {
      let { x: h, y: S } = $;
      return { x: h, y: S };
    } }, ...d } = e, f = { x: a, y: l }, p = await Ft(t, d), m = _t(We(o)), v = Rs(m);
    let b = f[m], B = f[v];
    if (n) {
      const $ = m === "y" ? "bottom" : "right";
      b = wa(b + p[m === "y" ? "top" : "left"], b, b - p[$]);
    }
    if (r) {
      const $ = v === "y" ? "bottom" : "right";
      B = wa(B + p[v === "y" ? "top" : "left"], B, B - p[$]);
    }
    const w = s.fn({ ...t, [m]: b, [v]: B });
    return { ...w, data: { x: w.x - a, y: w.y - l } };
  } };
};
function xe(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Ue(e) {
  return xe(e).getComputedStyle(e);
}
function Io(e) {
  return e instanceof xe(e).Node;
}
function rt(e) {
  return Io(e) ? (e.nodeName || "").toLowerCase() : "";
}
let Dt;
function Fo() {
  if (Dt)
    return Dt;
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? (Dt = e.brands.map((t) => t.brand + "/" + t.version).join(" "), Dt) : navigator.userAgent;
}
function Ke(e) {
  return e instanceof xe(e).HTMLElement;
}
function Ne(e) {
  return e instanceof xe(e).Element;
}
function pl(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof xe(e).ShadowRoot || e instanceof ShadowRoot;
}
function Lt(e) {
  const { overflow: t, overflowX: a, overflowY: l, display: o } = Ue(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + l + a) && !["inline", "contents"].includes(o);
}
function Hs(e) {
  return ["table", "td", "th"].includes(rt(e));
}
function $a(e) {
  const t = /firefox/i.test(Fo()), a = Ue(e), l = a.backdropFilter || a.WebkitBackdropFilter;
  return a.transform !== "none" || a.perspective !== "none" || !!l && l !== "none" || t && a.willChange === "filter" || t && !!a.filter && a.filter !== "none" || ["transform", "perspective"].some((o) => a.willChange.includes(o)) || ["paint", "layout", "strict", "content"].some((o) => {
    const n = a.contain;
    return n != null && n.includes(o);
  });
}
function _a() {
  return /^((?!chrome|android).)*safari/i.test(Fo());
}
function ca(e) {
  return ["html", "body", "#document"].includes(rt(e));
}
const ml = Math.min, Pt = Math.max, ta = Math.round;
function Lo(e) {
  const t = Ue(e);
  let a = parseFloat(t.width) || 0, l = parseFloat(t.height) || 0;
  const o = Ke(e), n = o ? e.offsetWidth : a, r = o ? e.offsetHeight : l, s = ta(a) !== n || ta(l) !== r;
  return s && (a = n, l = r), { width: a, height: l, fallback: s };
}
function xo(e) {
  return Ne(e) ? e : e.contextElement;
}
const No = { x: 1, y: 1 };
function Bt(e) {
  const t = xo(e);
  if (!Ke(t))
    return No;
  const a = t.getBoundingClientRect(), { width: l, height: o, fallback: n } = Lo(t);
  let r = (n ? ta(a.width) : a.width) / l, s = (n ? ta(a.height) : a.height) / o;
  return r && Number.isFinite(r) || (r = 1), s && Number.isFinite(s) || (s = 1), { x: r, y: s };
}
function ft(e, t, a, l) {
  var o, n;
  t === void 0 && (t = !1), a === void 0 && (a = !1);
  const r = e.getBoundingClientRect(), s = xo(e);
  let d = No;
  t && (l ? Ne(l) && (d = Bt(l)) : d = Bt(e));
  const f = s ? xe(s) : window, p = _a() && a;
  let m = (r.left + (p && ((o = f.visualViewport) == null ? void 0 : o.offsetLeft) || 0)) / d.x, v = (r.top + (p && ((n = f.visualViewport) == null ? void 0 : n.offsetTop) || 0)) / d.y, b = r.width / d.x, B = r.height / d.y;
  if (s) {
    const w = xe(s), $ = l && Ne(l) ? xe(l) : l;
    let h = w.frameElement;
    for (; h && l && $ !== w; ) {
      const S = Bt(h), y = h.getBoundingClientRect(), C = getComputedStyle(h);
      y.x += (h.clientLeft + parseFloat(C.paddingLeft)) * S.x, y.y += (h.clientTop + parseFloat(C.paddingTop)) * S.y, m *= S.x, v *= S.y, b *= S.x, B *= S.y, m += y.x, v += y.y, h = xe(h).frameElement;
    }
  }
  return St({ width: b, height: B, x: m, y: v });
}
function st(e) {
  return ((Io(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function fa(e) {
  return Ne(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function zo(e) {
  return ft(st(e)).left + fa(e).scrollLeft;
}
function wt(e) {
  if (rt(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || pl(e) && e.host || st(e);
  return pl(t) ? t.host : t;
}
function Ro(e) {
  const t = wt(e);
  return ca(t) ? t.ownerDocument.body : Ke(t) && Lt(t) ? t : Ro(t);
}
function Ot(e, t) {
  var a;
  t === void 0 && (t = []);
  const l = Ro(e), o = l === ((a = e.ownerDocument) == null ? void 0 : a.body), n = xe(l);
  return o ? t.concat(n, n.visualViewport || [], Lt(l) ? l : []) : t.concat(l, Ot(l));
}
function gl(e, t, a) {
  let l;
  if (t === "viewport")
    l = function(r, s) {
      const d = xe(r), f = st(r), p = d.visualViewport;
      let m = f.clientWidth, v = f.clientHeight, b = 0, B = 0;
      if (p) {
        m = p.width, v = p.height;
        const w = _a();
        (!w || w && s === "fixed") && (b = p.offsetLeft, B = p.offsetTop);
      }
      return { width: m, height: v, x: b, y: B };
    }(e, a);
  else if (t === "document")
    l = function(r) {
      const s = st(r), d = fa(r), f = r.ownerDocument.body, p = Pt(s.scrollWidth, s.clientWidth, f.scrollWidth, f.clientWidth), m = Pt(s.scrollHeight, s.clientHeight, f.scrollHeight, f.clientHeight);
      let v = -d.scrollLeft + zo(r);
      const b = -d.scrollTop;
      return Ue(f).direction === "rtl" && (v += Pt(s.clientWidth, f.clientWidth) - p), { width: p, height: m, x: v, y: b };
    }(st(e));
  else if (Ne(t))
    l = function(r, s) {
      const d = ft(r, !0, s === "fixed"), f = d.top + r.clientTop, p = d.left + r.clientLeft, m = Ke(r) ? Bt(r) : { x: 1, y: 1 };
      return { width: r.clientWidth * m.x, height: r.clientHeight * m.y, x: p * m.x, y: f * m.y };
    }(t, a);
  else {
    const r = { ...t };
    if (_a()) {
      var o, n;
      const s = xe(e);
      r.x -= ((o = s.visualViewport) == null ? void 0 : o.offsetLeft) || 0, r.y -= ((n = s.visualViewport) == null ? void 0 : n.offsetTop) || 0;
    }
    l = r;
  }
  return St(l);
}
function Ho(e, t) {
  const a = wt(e);
  return !(a === t || !Ne(a) || ca(a)) && (Ue(a).position === "fixed" || Ho(a, t));
}
function bl(e, t) {
  return Ke(e) && Ue(e).position !== "fixed" ? t ? t(e) : e.offsetParent : null;
}
function yl(e, t) {
  const a = xe(e);
  if (!Ke(e))
    return a;
  let l = bl(e, t);
  for (; l && Hs(l) && Ue(l).position === "static"; )
    l = bl(l, t);
  return l && (rt(l) === "html" || rt(l) === "body" && Ue(l).position === "static" && !$a(l)) ? a : l || function(o) {
    let n = wt(o);
    for (; Ke(n) && !ca(n); ) {
      if ($a(n))
        return n;
      n = wt(n);
    }
    return null;
  }(e) || a;
}
function Ms(e, t, a) {
  const l = Ke(t), o = st(t), n = ft(e, !0, a === "fixed", t);
  let r = { scrollLeft: 0, scrollTop: 0 };
  const s = { x: 0, y: 0 };
  if (l || !l && a !== "fixed")
    if ((rt(t) !== "body" || Lt(o)) && (r = fa(t)), Ke(t)) {
      const d = ft(t, !0);
      s.x = d.x + t.clientLeft, s.y = d.y + t.clientTop;
    } else
      o && (s.x = zo(o));
  return { x: n.left + r.scrollLeft - s.x, y: n.top + r.scrollTop - s.y, width: n.width, height: n.height };
}
const Ds = { getClippingRect: function(e) {
  let { element: t, boundary: a, rootBoundary: l, strategy: o } = e;
  const n = a === "clippingAncestors" ? function(f, p) {
    const m = p.get(f);
    if (m)
      return m;
    let v = Ot(f).filter(($) => Ne($) && rt($) !== "body"), b = null;
    const B = Ue(f).position === "fixed";
    let w = B ? wt(f) : f;
    for (; Ne(w) && !ca(w); ) {
      const $ = Ue(w), h = $a(w);
      h || $.position !== "fixed" || (b = null), (B ? !h && !b : !h && $.position === "static" && b && ["absolute", "fixed"].includes(b.position) || Lt(w) && !h && Ho(f, w)) ? v = v.filter((S) => S !== w) : b = $, w = wt(w);
    }
    return p.set(f, v), v;
  }(t, this._c) : [].concat(a), r = [...n, l], s = r[0], d = r.reduce((f, p) => {
    const m = gl(t, p, o);
    return f.top = Pt(m.top, f.top), f.right = ml(m.right, f.right), f.bottom = ml(m.bottom, f.bottom), f.left = Pt(m.left, f.left), f;
  }, gl(t, s, o));
  return { width: d.right - d.left, height: d.bottom - d.top, x: d.left, y: d.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: a, strategy: l } = e;
  const o = Ke(a), n = st(a);
  if (a === n)
    return t;
  let r = { scrollLeft: 0, scrollTop: 0 }, s = { x: 1, y: 1 };
  const d = { x: 0, y: 0 };
  if ((o || !o && l !== "fixed") && ((rt(a) !== "body" || Lt(n)) && (r = fa(a)), Ke(a))) {
    const f = ft(a);
    s = Bt(a), d.x = f.x + a.clientLeft, d.y = f.y + a.clientTop;
  }
  return { width: t.width * s.x, height: t.height * s.y, x: t.x * s.x - r.scrollLeft * s.x + d.x, y: t.y * s.y - r.scrollTop * s.y + d.y };
}, isElement: Ne, getDimensions: function(e) {
  return Lo(e);
}, getOffsetParent: yl, getDocumentElement: st, getScale: Bt, async getElementRects(e) {
  let { reference: t, floating: a, strategy: l } = e;
  const o = this.getOffsetParent || yl, n = this.getDimensions;
  return { reference: Ms(t, await o(a), l), floating: { x: 0, y: 0, ...await n(a) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => Ue(e).direction === "rtl" };
function js(e, t, a, l) {
  l === void 0 && (l = {});
  const { ancestorScroll: o = !0, ancestorResize: n = !0, elementResize: r = !0, animationFrame: s = !1 } = l, d = o || n ? [...Ne(e) ? Ot(e) : e.contextElement ? Ot(e.contextElement) : [], ...Ot(t)] : [];
  d.forEach((v) => {
    const b = !Ne(v) && v.toString().includes("V");
    !o || s && !b || v.addEventListener("scroll", a, { passive: !0 }), n && v.addEventListener("resize", a);
  });
  let f, p = null;
  r && (p = new ResizeObserver(() => {
    a();
  }), Ne(e) && !s && p.observe(e), Ne(e) || !e.contextElement || s || p.observe(e.contextElement), p.observe(t));
  let m = s ? ft(e) : null;
  return s && function v() {
    const b = ft(e);
    !m || b.x === m.x && b.y === m.y && b.width === m.width && b.height === m.height || a(), m = b, f = requestAnimationFrame(v);
  }(), a(), () => {
    var v;
    d.forEach((b) => {
      o && b.removeEventListener("scroll", a), n && b.removeEventListener("resize", a);
    }), (v = p) == null || v.disconnect(), p = null, s && cancelAnimationFrame(f);
  };
}
const qs = (e, t, a) => {
  const l = /* @__PURE__ */ new Map(), o = { platform: Ds, ...a }, n = { ...o.platform, _c: l };
  return Es(e, t, { ...o, platform: n });
};
function ka(e) {
  var t;
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
function Gs(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const a = ka(T(e.element));
      return a == null ? {} : Is({
        element: a,
        padding: e.padding
      }).fn(t);
    }
  };
}
function Mo(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function hl(e, t) {
  const a = Mo(e);
  return Math.round(t * a) / a;
}
function Do(e, t, a) {
  a === void 0 && (a = {});
  const l = a.whileElementsMounted, o = i(() => {
    var I;
    return (I = T(a.open)) != null ? I : !0;
  }), n = i(() => T(a.middleware)), r = i(() => {
    var I;
    return (I = T(a.placement)) != null ? I : "bottom";
  }), s = i(() => {
    var I;
    return (I = T(a.strategy)) != null ? I : "absolute";
  }), d = i(() => {
    var I;
    return (I = T(a.transform)) != null ? I : !0;
  }), f = i(() => ka(e.value)), p = i(() => ka(t.value)), m = x(0), v = x(0), b = x(s.value), B = x(r.value), w = xa({}), $ = x(!1), h = i(() => {
    const I = {
      position: b.value,
      left: "0",
      top: "0"
    };
    if (!p.value)
      return I;
    const F = hl(p.value, m.value), L = hl(p.value, v.value);
    return d.value ? {
      ...I,
      transform: "translate(" + F + "px, " + L + "px)",
      ...Mo(p.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: b.value,
      left: F + "px",
      top: L + "px"
    };
  });
  let S;
  function y() {
    f.value == null || p.value == null || qs(f.value, p.value, {
      middleware: n.value,
      placement: r.value,
      strategy: s.value
    }).then((I) => {
      m.value = I.x, v.value = I.y, b.value = I.strategy, B.value = I.placement, w.value = I.middlewareData, $.value = !0;
    });
  }
  function C() {
    typeof S == "function" && (S(), S = void 0);
  }
  function O() {
    if (C(), l === void 0) {
      y();
      return;
    }
    if (f.value != null && p.value != null) {
      S = l(f.value, p.value, y);
      return;
    }
  }
  function k() {
    o.value || ($.value = !1);
  }
  return ue([n, r, s], y, {
    flush: "sync"
  }), ue([f, p], O, {
    flush: "sync"
  }), ue(o, k, {
    flush: "sync"
  }), to() && ao(C), {
    x: pt(m),
    y: pt(v),
    strategy: pt(b),
    placement: pt(B),
    middlewareData: pt(w),
    isPositioned: pt($),
    floatingStyles: h,
    update: y
  };
}
const Ws = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), Us = /^aria-[\w-]*$/i, Ks = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Xs = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, Js = (e, t) => {
  const a = e.nodeName.toLowerCase();
  return t.includes(a) ? Ws.has(a) ? !!(Ks.test(e.nodeValue || "") || Xs.test(e.nodeValue || "")) : !0 : t.filter((l) => l instanceof RegExp).some((l) => l.test(a));
}, bt = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", Us],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
}, yt = (e, t, a) => {
  if (!e.length)
    return e;
  if (a && typeof a == "function")
    return a(e);
  const o = new window.DOMParser().parseFromString(e, "text/html"), n = o.body.querySelectorAll("*");
  for (const r of n) {
    const s = r.nodeName.toLowerCase();
    if (!Object.keys(t).includes(s)) {
      r.remove();
      continue;
    }
    const d = r.attributes, f = [...t["*"] || [], ...t[s] || []];
    for (const p of d)
      Js(p, f) || r.removeAttribute(p.nodeName);
  }
  return o.body.innerHTML;
};
var Ys = Object.defineProperty, Zs = Object.defineProperties, Qs = Object.getOwnPropertyDescriptors, Bl = Object.getOwnPropertySymbols, er = Object.prototype.hasOwnProperty, tr = Object.prototype.propertyIsEnumerable, Sl = (e, t, a) => t in e ? Ys(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, ar = (e, t) => {
  for (var a in t || (t = {}))
    er.call(t, a) && Sl(e, a, t[a]);
  if (Bl)
    for (var a of Bl(t))
      tr.call(t, a) && Sl(e, a, t[a]);
  return e;
}, lr = (e, t) => Zs(e, Qs(t));
function jo(e, t) {
  var a;
  const l = xa();
  return qe(() => {
    l.value = e();
  }, lr(ar({}, t), {
    flush: (a = t == null ? void 0 : t.flush) != null ? a : "sync"
  })), ke(l);
}
function xt(e) {
  return to() ? (ao(e), !0) : !1;
}
function or(e) {
  let t = 0, a, l;
  const o = () => {
    t -= 1, l && t <= 0 && (l.stop(), a = void 0, l = void 0);
  };
  return (...n) => (t += 1, a || (l = Mn(!0), a = l.run(() => e(...n))), xt(o), a);
}
function kt(e) {
  return typeof e == "function" ? e() : T(e);
}
const Fe = kt, aa = typeof window < "u", nr = (e) => typeof e < "u", Nt = () => {
}, sr = /* @__PURE__ */ rr();
function rr() {
  var e;
  return aa && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && /* @__PURE__ */ /iP(ad|hone|od)/.test(window.navigator.userAgent);
}
function ir(e, t) {
  function a(...l) {
    return new Promise((o, n) => {
      Promise.resolve(e(() => t.apply(this, l), { fn: t, thisArg: this, args: l })).then(o).catch(n);
    });
  }
  return a;
}
const qo = (e) => e();
function ur(e = qo) {
  const t = x(!0);
  function a() {
    t.value = !1;
  }
  function l() {
    t.value = !0;
  }
  const o = (...n) => {
    t.value && e(...n);
  };
  return { isActive: ke(t), pause: a, resume: l, eventFilter: o };
}
function Go(...e) {
  if (e.length !== 1)
    return u(...e);
  const t = e[0];
  return typeof t == "function" ? ke(Dn(() => ({ get: t, set: Nt }))) : x(t);
}
function dr(e, t = !0) {
  ra() ? Xe(e) : t ? e() : Te(e);
}
function cr(e = 0, t = {}) {
  const a = x(e), {
    max: l = 1 / 0,
    min: o = -1 / 0
  } = t, n = (p = 1) => a.value = Math.min(l, a.value + p), r = (p = 1) => a.value = Math.max(o, a.value - p), s = () => a.value, d = (p) => a.value = Math.max(o, Math.min(l, p));
  return { count: a, inc: n, dec: r, get: s, set: d, reset: (p = e) => (e = p, d(p)) };
}
function Wo(e, t = 1e3, a = {}) {
  const {
    immediate: l = !0,
    immediateCallback: o = !1
  } = a;
  let n = null;
  const r = x(!1);
  function s() {
    n && (clearInterval(n), n = null);
  }
  function d() {
    r.value = !1, s();
  }
  function f() {
    const p = kt(t);
    p <= 0 || (r.value = !0, o && e(), s(), n = setInterval(e, p));
  }
  if (l && aa && f(), lo(t) || typeof t == "function") {
    const p = ue(t, () => {
      r.value && aa && f();
    });
    xt(p);
  }
  return xt(d), {
    isActive: r,
    pause: d,
    resume: f
  };
}
function ht(e, t = {}) {
  const {
    method: a = "parseFloat",
    radix: l,
    nanToZero: o
  } = t;
  return i(() => {
    let n = kt(e);
    return typeof n == "string" && (n = Number[a](n, l)), o && isNaN(n) && (n = 0), n;
  });
}
var wl = Object.getOwnPropertySymbols, fr = Object.prototype.hasOwnProperty, vr = Object.prototype.propertyIsEnumerable, pr = (e, t) => {
  var a = {};
  for (var l in e)
    fr.call(e, l) && t.indexOf(l) < 0 && (a[l] = e[l]);
  if (e != null && wl)
    for (var l of wl(e))
      t.indexOf(l) < 0 && vr.call(e, l) && (a[l] = e[l]);
  return a;
};
function mr(e, t, a = {}) {
  const l = a, {
    eventFilter: o = qo
  } = l, n = pr(l, [
    "eventFilter"
  ]);
  return ue(
    e,
    ir(
      o,
      t
    ),
    n
  );
}
var gr = Object.defineProperty, br = Object.defineProperties, yr = Object.getOwnPropertyDescriptors, la = Object.getOwnPropertySymbols, Uo = Object.prototype.hasOwnProperty, Ko = Object.prototype.propertyIsEnumerable, $l = (e, t, a) => t in e ? gr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, hr = (e, t) => {
  for (var a in t || (t = {}))
    Uo.call(t, a) && $l(e, a, t[a]);
  if (la)
    for (var a of la(t))
      Ko.call(t, a) && $l(e, a, t[a]);
  return e;
}, Br = (e, t) => br(e, yr(t)), Sr = (e, t) => {
  var a = {};
  for (var l in e)
    Uo.call(e, l) && t.indexOf(l) < 0 && (a[l] = e[l]);
  if (e != null && la)
    for (var l of la(e))
      t.indexOf(l) < 0 && Ko.call(e, l) && (a[l] = e[l]);
  return a;
};
function wr(e, t, a = {}) {
  const l = a, {
    eventFilter: o
  } = l, n = Sr(l, [
    "eventFilter"
  ]), { eventFilter: r, pause: s, resume: d, isActive: f } = ur(o);
  return { stop: mr(
    e,
    t,
    Br(hr({}, n), {
      eventFilter: r
    })
  ), pause: s, resume: d, isActive: f };
}
function at(e) {
  var t;
  const a = kt(e);
  return (t = a == null ? void 0 : a.$el) != null ? t : a;
}
const lt = aa ? window : void 0;
function Ce(...e) {
  let t, a, l, o;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([a, l, o] = e, t = lt) : [t, a, l, o] = e, !t)
    return Nt;
  Array.isArray(a) || (a = [a]), Array.isArray(l) || (l = [l]);
  const n = [], r = () => {
    n.forEach((p) => p()), n.length = 0;
  }, s = (p, m, v, b) => (p.addEventListener(m, v, b), () => p.removeEventListener(m, v, b)), d = ue(
    () => [at(t), kt(o)],
    ([p, m]) => {
      r(), p && n.push(
        ...a.flatMap((v) => l.map((b) => s(p, v, b, m)))
      );
    },
    { immediate: !0, flush: "post" }
  ), f = () => {
    d(), r();
  };
  return xt(f), f;
}
let _l = !1;
function Xo(e, t, a = {}) {
  const { window: l = lt, ignore: o = [], capture: n = !0, detectIframe: r = !1 } = a;
  if (!l)
    return;
  sr && !_l && (_l = !0, Array.from(l.document.body.children).forEach((v) => v.addEventListener("click", Nt)));
  let s = !0;
  const d = (v) => o.some((b) => {
    if (typeof b == "string")
      return Array.from(l.document.querySelectorAll(b)).some((B) => B === v.target || v.composedPath().includes(B));
    {
      const B = at(b);
      return B && (v.target === B || v.composedPath().includes(B));
    }
  }), p = [
    Ce(l, "click", (v) => {
      const b = at(e);
      if (!(!b || b === v.target || v.composedPath().includes(b))) {
        if (v.detail === 0 && (s = !d(v)), !s) {
          s = !0;
          return;
        }
        t(v);
      }
    }, { passive: !0, capture: n }),
    Ce(l, "pointerdown", (v) => {
      const b = at(e);
      b && (s = !v.composedPath().includes(b) && !d(v));
    }, { passive: !0 }),
    r && Ce(l, "blur", (v) => {
      var b;
      const B = at(e);
      ((b = l.document.activeElement) == null ? void 0 : b.tagName) === "IFRAME" && !(B != null && B.contains(l.document.activeElement)) && t(v);
    })
  ].filter(Boolean);
  return () => p.forEach((v) => v());
}
function $r() {
  const e = x(!1);
  return ra() && Xe(() => {
    e.value = !0;
  }), e;
}
function _r(e) {
  const t = $r();
  return i(() => (t.value, !!e()));
}
function kr(e, t = {}) {
  const { window: a = lt } = t, l = _r(() => a && "matchMedia" in a && typeof a.matchMedia == "function");
  let o;
  const n = x(!1), r = () => {
    o && ("removeEventListener" in o ? o.removeEventListener("change", s) : o.removeListener(s));
  }, s = () => {
    l.value && (r(), o = a.matchMedia(Go(e).value), n.value = !!(o != null && o.matches), o && ("addEventListener" in o ? o.addEventListener("change", s) : o.addListener(s)));
  };
  return qe(s), xt(() => r()), n;
}
function Cr(e) {
  return JSON.parse(JSON.stringify(e));
}
const jt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, qt = "__vueuse_ssr_handlers__", Tr = /* @__PURE__ */ Ar();
function Ar() {
  return qt in jt || (jt[qt] = jt[qt] || {}), jt[qt];
}
function Ka(e, t) {
  return Tr[e] || t;
}
function Vr(e) {
  return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number";
}
var Pr = Object.defineProperty, kl = Object.getOwnPropertySymbols, Or = Object.prototype.hasOwnProperty, Er = Object.prototype.propertyIsEnumerable, Cl = (e, t, a) => t in e ? Pr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, Tl = (e, t) => {
  for (var a in t || (t = {}))
    Or.call(t, a) && Cl(e, a, t[a]);
  if (kl)
    for (var a of kl(t))
      Er.call(t, a) && Cl(e, a, t[a]);
  return e;
};
const Ir = {
  boolean: {
    read: (e) => e === "true",
    write: (e) => String(e)
  },
  object: {
    read: (e) => JSON.parse(e),
    write: (e) => JSON.stringify(e)
  },
  number: {
    read: (e) => Number.parseFloat(e),
    write: (e) => String(e)
  },
  any: {
    read: (e) => e,
    write: (e) => String(e)
  },
  string: {
    read: (e) => e,
    write: (e) => String(e)
  },
  map: {
    read: (e) => new Map(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e.entries()))
  },
  set: {
    read: (e) => new Set(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e))
  },
  date: {
    read: (e) => new Date(e),
    write: (e) => e.toISOString()
  }
}, Al = "vueuse-storage";
function Fr(e, t, a, l = {}) {
  var o;
  const {
    flush: n = "pre",
    deep: r = !0,
    listenToStorageChanges: s = !0,
    writeDefaults: d = !0,
    mergeDefaults: f = !1,
    shallow: p,
    window: m = lt,
    eventFilter: v,
    onError: b = (F) => {
      console.error(F);
    }
  } = l, B = (p ? xa : x)(t);
  if (!a)
    try {
      a = Ka("getDefaultStorage", () => {
        var F;
        return (F = lt) == null ? void 0 : F.localStorage;
      })();
    } catch (F) {
      b(F);
    }
  if (!a)
    return B;
  const w = kt(t), $ = Vr(w), h = (o = l.serializer) != null ? o : Ir[$], { pause: S, resume: y } = wr(
    B,
    () => C(B.value),
    { flush: n, deep: r, eventFilter: v }
  );
  return m && s && (Ce(m, "storage", I), Ce(m, Al, k)), I(), B;
  function C(F) {
    try {
      if (F == null)
        a.removeItem(e);
      else {
        const L = h.write(F), _ = a.getItem(e);
        _ !== L && (a.setItem(e, L), m && m.dispatchEvent(new CustomEvent(Al, {
          detail: {
            key: e,
            oldValue: _,
            newValue: L,
            storageArea: a
          }
        })));
      }
    } catch (L) {
      b(L);
    }
  }
  function O(F) {
    const L = F ? F.newValue : a.getItem(e);
    if (L == null)
      return d && w !== null && a.setItem(e, h.write(w)), w;
    if (!F && f) {
      const _ = h.read(L);
      return typeof f == "function" ? f(_, w) : $ === "object" && !Array.isArray(_) ? Tl(Tl({}, w), _) : _;
    } else
      return typeof L != "string" ? L : h.read(L);
  }
  function k(F) {
    I(F.detail);
  }
  function I(F) {
    if (!(F && F.storageArea !== a)) {
      if (F && F.key == null) {
        B.value = w;
        return;
      }
      if (!(F && F.key !== e)) {
        S();
        try {
          B.value = O(F);
        } catch (L) {
          b(L);
        } finally {
          F ? Te(y) : y();
        }
      }
    }
  }
}
function Lr(e) {
  return kr("(prefers-color-scheme: dark)", e);
}
var xr = Object.defineProperty, Vl = Object.getOwnPropertySymbols, Nr = Object.prototype.hasOwnProperty, zr = Object.prototype.propertyIsEnumerable, Pl = (e, t, a) => t in e ? xr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, Rr = (e, t) => {
  for (var a in t || (t = {}))
    Nr.call(t, a) && Pl(e, a, t[a]);
  if (Vl)
    for (var a of Vl(t))
      zr.call(t, a) && Pl(e, a, t[a]);
  return e;
};
function Hr(e = {}) {
  const {
    selector: t = "html",
    attribute: a = "class",
    initialValue: l = "auto",
    window: o = lt,
    storage: n,
    storageKey: r = "vueuse-color-scheme",
    listenToStorageChanges: s = !0,
    storageRef: d,
    emitAuto: f,
    disableTransition: p = !0
  } = e, m = Rr({
    auto: "",
    light: "light",
    dark: "dark"
  }, e.modes || {}), v = Lr({ window: o }), b = i(() => v.value ? "dark" : "light"), B = d || (r == null ? Go(l) : Fr(r, l, n, { window: o, listenToStorageChanges: s })), w = i(
    () => B.value === "auto" ? b.value : B.value
  ), $ = Ka(
    "updateHTMLAttrs",
    (C, O, k) => {
      const I = typeof C == "string" ? o == null ? void 0 : o.document.querySelector(C) : at(C);
      if (!I)
        return;
      let F;
      if (p && (F = o.document.createElement("style"), F.appendChild(document.createTextNode("*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), o.document.head.appendChild(F)), O === "class") {
        const L = k.split(/\s/g);
        Object.values(m).flatMap((_) => (_ || "").split(/\s/g)).filter(Boolean).forEach((_) => {
          L.includes(_) ? I.classList.add(_) : I.classList.remove(_);
        });
      } else
        I.setAttribute(O, k);
      p && (o.getComputedStyle(F).opacity, document.head.removeChild(F));
    }
  );
  function h(C) {
    var O;
    $(t, a, (O = m[C]) != null ? O : C);
  }
  function S(C) {
    e.onChanged ? e.onChanged(C, h) : h(C);
  }
  ue(w, S, { flush: "post", immediate: !0 }), dr(() => S(w.value));
  const y = i({
    get() {
      return f ? B.value : w.value;
    },
    set(C) {
      B.value = C;
    }
  });
  try {
    return Object.assign(y, { store: B, system: b, state: w });
  } catch {
    return y;
  }
}
function je(e, t = {}) {
  const { initialValue: a = !1 } = t, l = x(!1), o = i(() => at(e));
  Ce(o, "focus", () => l.value = !0), Ce(o, "blur", () => l.value = !1);
  const n = i({
    get: () => l.value,
    set(r) {
      var s, d;
      !r && l.value ? (s = o.value) == null || s.blur() : r && !l.value && ((d = o.value) == null || d.focus());
    }
  });
  return ue(
    o,
    () => {
      n.value = a;
    },
    { immediate: !0, flush: "post" }
  ), { focused: n };
}
const Mr = {
  page: (e) => [e.pageX, e.pageY],
  client: (e) => [e.clientX, e.clientY],
  screen: (e) => [e.screenX, e.screenY],
  movement: (e) => e instanceof Touch ? null : [e.movementX, e.movementY]
};
function Dr(e = {}) {
  const {
    type: t = "page",
    touch: a = !0,
    resetOnTouchEnds: l = !1,
    initialValue: o = { x: 0, y: 0 },
    window: n = lt,
    target: r = n,
    eventFilter: s
  } = e, d = x(o.x), f = x(o.y), p = x(null), m = typeof t == "function" ? t : Mr[t], v = (h) => {
    const S = m(h);
    S && ([d.value, f.value] = S, p.value = "mouse");
  }, b = (h) => {
    if (h.touches.length > 0) {
      const S = m(h.touches[0]);
      S && ([d.value, f.value] = S, p.value = "touch");
    }
  }, B = () => {
    d.value = o.x, f.value = o.y;
  }, w = s ? (h) => s(() => v(h), {}) : (h) => v(h), $ = s ? (h) => s(() => b(h), {}) : (h) => b(h);
  return r && (Ce(r, "mousemove", w, { passive: !0 }), Ce(r, "dragover", w, { passive: !0 }), a && t !== "movement" && (Ce(r, "touchstart", $, { passive: !0 }), Ce(r, "touchmove", $, { passive: !0 }), l && Ce(r, "touchend", B, { passive: !0 }))), {
    x: d,
    y: f,
    sourceType: p
  };
}
function Ol(e, t = {}) {
  const {
    handleOutside: a = !0,
    window: l = lt
  } = t, { x: o, y: n, sourceType: r } = Dr(t), s = x(e ?? (l == null ? void 0 : l.document.body)), d = x(0), f = x(0), p = x(0), m = x(0), v = x(0), b = x(0), B = x(!0);
  let w = () => {
  };
  return l && (w = ue(
    [s, o, n],
    () => {
      const $ = at(s);
      if (!$)
        return;
      const {
        left: h,
        top: S,
        width: y,
        height: C
      } = $.getBoundingClientRect();
      p.value = h + l.pageXOffset, m.value = S + l.pageYOffset, v.value = C, b.value = y;
      const O = o.value - p.value, k = n.value - m.value;
      B.value = y === 0 || C === 0 || O < 0 || k < 0 || O > y || k > C, (a || !B.value) && (d.value = O, f.value = k);
    },
    { immediate: !0 }
  ), Ce(document, "mouseleave", () => {
    B.value = !0;
  })), {
    x: o,
    y: n,
    sourceType: r,
    elementX: d,
    elementY: f,
    elementPositionX: p,
    elementPositionY: m,
    elementHeight: v,
    elementWidth: b,
    isOutside: B,
    stop: w
  };
}
function jr(e, t = {}) {
  const {
    threshold: a = 50,
    onSwipe: l,
    onSwipeEnd: o,
    onSwipeStart: n,
    passive: r = !0,
    window: s = lt
  } = t, d = dt({ x: 0, y: 0 }), f = dt({ x: 0, y: 0 }), p = i(() => d.x - f.x), m = i(() => d.y - f.y), { max: v, abs: b } = Math, B = i(() => v(b(p.value), b(m.value)) >= a), w = x(!1), $ = i(() => B.value ? b(p.value) > b(m.value) ? p.value > 0 ? "left" : "right" : m.value > 0 ? "up" : "down" : "none"), h = (L) => [L.touches[0].clientX, L.touches[0].clientY], S = (L, _) => {
    d.x = L, d.y = _;
  }, y = (L, _) => {
    f.x = L, f.y = _;
  };
  let C;
  const O = qr(s == null ? void 0 : s.document);
  r ? C = O ? { passive: !0 } : { capture: !1 } : C = O ? { passive: !1, capture: !0 } : { capture: !0 };
  const k = (L) => {
    w.value && (o == null || o(L, $.value)), w.value = !1;
  }, I = [
    Ce(e, "touchstart", (L) => {
      if (L.touches.length !== 1)
        return;
      C.capture && !C.passive && L.preventDefault();
      const [_, E] = h(L);
      S(_, E), y(_, E), n == null || n(L);
    }, C),
    Ce(e, "touchmove", (L) => {
      if (L.touches.length !== 1)
        return;
      const [_, E] = h(L);
      y(_, E), !w.value && B.value && (w.value = !0), w.value && (l == null || l(L));
    }, C),
    Ce(e, "touchend", k, C),
    Ce(e, "touchcancel", k, C)
  ];
  return {
    isPassiveEventSupported: O,
    isSwiping: w,
    direction: $,
    coordsStart: d,
    coordsEnd: f,
    lengthX: p,
    lengthY: m,
    stop: () => I.forEach((L) => L())
  };
}
function qr(e) {
  if (!e)
    return !1;
  let t = !1;
  const a = {
    get passive() {
      return t = !0, !1;
    }
  };
  return e.addEventListener("x", Nt, a), e.removeEventListener("x", Nt), t;
}
function Ve(e, t, a, l = {}) {
  var o, n, r;
  const {
    clone: s = !1,
    passive: d = !1,
    eventName: f,
    deep: p = !1,
    defaultValue: m,
    shouldEmit: v
  } = l, b = ra(), B = a || (b == null ? void 0 : b.emit) || ((o = b == null ? void 0 : b.$emit) == null ? void 0 : o.bind(b)) || ((r = (n = b == null ? void 0 : b.proxy) == null ? void 0 : n.$emit) == null ? void 0 : r.bind(b == null ? void 0 : b.proxy));
  let w = f;
  t || (t = "modelValue"), w = f || w || `update:${t.toString()}`;
  const $ = (y) => s ? typeof s == "function" ? s(y) : Cr(y) : y, h = () => nr(e[t]) ? $(e[t]) : m, S = (y) => {
    v ? v(y) && B(w, y) : B(w, y);
  };
  if (d) {
    const y = h(), C = x(y);
    return ue(
      () => e[t],
      (O) => C.value = $(O)
    ), ue(
      C,
      (O) => {
        (O !== e[t] || p) && S(O);
      },
      { deep: p }
    ), C;
  } else
    return i({
      get() {
        return h();
      },
      set(y) {
        S(y);
      }
    });
}
const Xa = z({
  name: "ComponentOrEmpty",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    to: {
      type: [String, Object],
      default: null
    },
    skip: {
      type: Boolean,
      default: !1
    }
  },
  setup(e, { slots: t, attrs: a }) {
    return () => {
      var l, o, n;
      return e.skip ? (l = t.default) == null ? void 0 : l.call(t) : e.tag === "Teleport" ? ce(Na, { to: e.to }, [(o = t.default) == null ? void 0 : o.call(t)]) : ce(e.tag, { ...a }, [(n = t.default) == null ? void 0 : n.call(t)]);
    };
  }
}), Ht = (e) => jo(() => e.value ? `justify-content-${e.value}` : "");
function c(e) {
  return jo(
    () => e.value === void 0 || e.value === null ? e.value : ro(e.value)
  );
}
const Jo = {
  items: dt([]),
  reset() {
    this.items = dt([]);
  }
}, Yo = (e) => {
  e.provide(Bo, Jo);
}, Zo = () => Ee(Bo, null) ?? Jo, Gr = (e = {}) => {
  const t = e.persist ?? !1, a = "data-bs-theme", l = "body";
  return Hr({
    attribute: a,
    selector: l,
    storageKey: t === !0 ? `bv-color-${e.attribute ?? a}-${e.selector ?? l}` : null,
    ...e
  });
}, Wr = (e, t = x(1e3), a = {}) => {
  const l = x(!1), o = x(0), n = x(Fe(e)), r = x(Fe(t)), s = i(() => Math.ceil(n.value / r.value)), d = i(
    () => m.value || l.value ? Math.round(n.value - o.value * r.value) : 0
  ), { pause: f, resume: p, isActive: m } = Wo(
    () => o.value = o.value + 1,
    t,
    a
  ), v = () => {
    l.value = !1, o.value = 0, p();
  }, b = () => {
    l.value = !1, o.value = s.value;
  };
  qe(() => {
    const $ = Fe(e), h = n.value;
    $ !== h && (n.value = $, b(), v());
  }), qe(() => {
    const $ = Fe(t), h = r.value;
    $ !== h && (r.value = $, b(), v());
  }), qe(() => {
    o.value > s.value && (o.value = s.value), o.value === s.value && f();
  });
  const B = () => {
    m.value !== !1 && (l.value = !0, f());
  }, w = () => {
    o.value !== s.value && (l.value = !1, p());
  };
  return {
    isActive: ke(m),
    isPaused: ke(l),
    restart: v,
    stop: b,
    pause: B,
    resume: w,
    value: d
  };
}, Qo = (e) => {
  const t = x(Fe(e));
  return qe(() => t.value = Fe(e)), i(() => ({
    "form-check": t.value.plain === !1 && t.value.button === !1,
    "form-check-inline": t.value.inline === !0,
    "form-switch": t.value.switch === !0,
    [`form-control-${t.value.size}`]: t.value.size !== void 0 && t.value.size !== "md" && t.value.button === !1
  }));
}, en = (e) => {
  const t = x(Fe(e));
  return qe(() => t.value = Fe(e)), i(() => ({
    "form-check-input": t.value.plain === !1 && t.value.button === !1,
    "is-valid": t.value.state === !0,
    "is-invalid": t.value.state === !1,
    "btn-check": t.value.button === !0
  }));
}, tn = (e) => {
  const t = x(Fe(e));
  return qe(() => t.value = Fe(e)), i(() => ({
    "form-check-label": t.value.plain === !1 && t.value.button === !1,
    btn: t.value.button === !0,
    [`btn-${t.value.buttonVariant}`]: t.value.button === !0 && t.value.buttonVariant !== void 0 && t.value.buttonVariant !== null,
    [`btn-${t.value.size}`]: t.value.button && t.value.size && t.value.size !== "md"
  }));
}, an = (e) => {
  const t = x(Fe(e));
  return qe(() => t.value = Fe(e)), i(() => ({
    "aria-invalid": da(t.value.ariaInvalid, t.value.state),
    "aria-required": t.value.required === !0 ? !0 : void 0
  }));
}, ln = (e) => {
  const t = x(Fe(e));
  return qe(() => t.value = Fe(e)), i(() => ({
    "was-validated": t.value.validated === !0,
    "btn-group": t.value.buttons === !0 && t.value.stacked === !1,
    "btn-group-vertical": t.value.stacked === !0 && t.value.buttons === !0,
    [`btn-group-${t.value.size}`]: t.value.size !== void 0
  }));
}, on = {
  ariaInvalid: {
    type: [Boolean, String],
    default: void 0
  },
  autocomplete: { type: String, required: !1 },
  autofocus: { type: Boolean, default: !1 },
  disabled: { type: Boolean, default: !1 },
  form: { type: String, required: !1 },
  formatter: { type: Function, required: !1 },
  id: { type: String, required: !1 },
  lazy: { type: Boolean, default: !1 },
  lazyFormatter: { type: Boolean, default: !1 },
  list: { type: String, required: !1 },
  modelValue: { type: [String, Number], default: "" },
  name: { type: String, required: !1 },
  number: { type: Boolean, default: !1 },
  placeholder: { type: String, required: !1 },
  plaintext: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  required: { type: Boolean, default: !1 },
  size: { type: String, required: !1 },
  state: { type: Boolean, default: null },
  trim: { type: Boolean, default: !1 }
}, nn = (e, t) => {
  const a = x(null);
  let l = null, o = !0;
  const n = Ae(u(e, "id"), "input"), r = c(u(e, "state")), { focused: s } = je(a, {
    initialValue: e.autofocus
  }), d = (h, S, y = !1) => (h = String(h), typeof e.formatter == "function" && (!e.lazyFormatter || y) ? (o = !1, e.formatter(h, S)) : h), f = (h) => e.trim ? h.trim() : e.number ? Number.parseFloat(h) : h, p = () => {
    e.autofocus && (s.value = !0);
  };
  Xe(() => {
    a.value && (a.value.value = e.modelValue);
  }), jn(() => {
    Te(() => {
      p();
    });
  });
  const m = i(
    () => da(e.ariaInvalid, r.value)
  ), v = (h) => {
    const { value: S } = h.target, y = d(S, h);
    if (y === !1 || h.defaultPrevented) {
      h.preventDefault();
      return;
    }
    if (e.lazy)
      return;
    const C = f(y);
    e.modelValue !== C && (l = S, t("update:modelValue", C)), t("input", y);
  }, b = (h) => {
    const { value: S } = h.target, y = d(S, h);
    if (y === !1 || h.defaultPrevented) {
      h.preventDefault();
      return;
    }
    if (!e.lazy)
      return;
    l = S, t("update:modelValue", y);
    const C = f(y);
    e.modelValue !== C && t("change", y);
  }, B = (h) => {
    if (t("blur", h), !e.lazy && !e.lazyFormatter)
      return;
    const { value: S } = h.target, y = d(S, h, !0);
    l = S, t("update:modelValue", y);
  }, w = () => {
    e.disabled || (s.value = !0);
  }, $ = () => {
    var h;
    e.disabled || (h = a.value) == null || h.blur();
  };
  return ue(
    () => e.modelValue,
    (h) => {
      a.value && (a.value.value = l && o ? l : h, l = null, o = !0);
    }
  ), {
    input: a,
    computedId: n,
    computedAriaInvalid: m,
    onInput: v,
    onChange: b,
    onBlur: B,
    focus: w,
    blur: $
  };
}, gt = (e, t) => {
  if (!e)
    return e;
  if (t in e)
    return e[t];
  const a = t.split(".");
  return gt(e[a[0]], a.splice(1).join("."));
}, ga = (e, t = null, a, l) => {
  if (Object.prototype.toString.call(e) === "[object Object]") {
    const o = gt(e, l.valueField), n = gt(e, l.textField), r = gt(e, l.htmlField), s = gt(e, l.disabledField), d = e[l.optionsField] || null;
    return d !== null ? {
      label: String(gt(e, l.labelField) || n),
      options: Ja(d, a, l)
    } : {
      value: typeof o > "u" ? t || n : o,
      text: String(typeof n > "u" ? t : n),
      html: r,
      disabled: !!s
    };
  }
  return {
    value: t || e,
    text: String(e),
    disabled: !1
  };
}, Ja = (e, t, a) => Array.isArray(e) ? e.map((l) => ga(l, null, t, a)) : Object.prototype.toString.call(e) === "[object Object]" ? (console.warn(
  `[BootstrapVue warn]: ${t} - Setting prop "options" to an object is deprecated. Use the array format instead.`
), Object.keys(e).map((l) => {
  const o = e[l];
  switch (typeof o) {
    case "object":
      return ga(o.text, String(o.value), t, a);
    default:
      return ga(o, String(l), t, a);
  }
})) : [], Ae = (e, t) => i(() => (e == null ? void 0 : e.value) || ot(t)), ba = "modal-open", Ur = or(() => {
  const { count: e, inc: t, dec: a } = cr(), l = Ka("updateHTMLAttrs", (o, n, r) => {
    const s = typeof o == "string" ? window == null ? void 0 : window.document.querySelector(o) : at(o);
    s && (n === "class" ? s.classList.toggle(ba, r === ba) : s.setAttribute(n, r));
  });
  return ue(e, (o) => {
    l("body", "class", o > 0 ? ba : "");
  }), { inc: t, dec: a };
}), Kr = (e) => {
  const { inc: t, dec: a } = Ur();
  ue(
    e,
    (l, o) => {
      l ? t() : o && !l && a();
    },
    { immediate: !0 }
  );
}, Xr = ["id"], Jr = ["innerHTML"], Yr = ["innerHTML"], Ya = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BPopover",
  props: {
    modelValue: { type: [String, Boolean], default: !1 },
    container: { default: void 0 },
    target: { type: [Function, String, null], default: null },
    reference: { type: [Function, String, null], default: null },
    content: { default: void 0 },
    id: { default: void 0 },
    title: { default: void 0 },
    delay: { default: () => ({ show: 100, hide: 300 }) },
    click: { type: [String, Boolean], default: !1 },
    manual: { type: [String, Boolean], default: !1 },
    variant: { default: null },
    offset: { default: null },
    customClass: { default: "" },
    placement: { default: "top" },
    strategy: { default: "absolute" },
    floatingMiddleware: { default: void 0 },
    noFlip: { type: [String, Boolean], default: !1 },
    noShift: { type: [String, Boolean], default: !1 },
    noFade: { type: [String, Boolean], default: !1 },
    noAutoClose: { type: [String, Boolean], default: !1 },
    hide: { type: [String, Boolean], default: !0 },
    realtime: { type: [String, Boolean], default: !1 },
    inline: { type: [String, Boolean], default: !1 },
    tooltip: { type: [String, Boolean], default: !1 },
    html: { type: [String, Boolean], default: !1 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = c(u(a, "modelValue")), o = x(l.value), n = x(l.value);
    qe(() => {
      t("update:modelValue", o.value);
    }), ue(l, () => {
      l.value !== o.value && (l.value ? q() : se(new Event("update:modelValue")));
    });
    const r = Ae(u(a, "id"), "popover"), s = c(u(a, "click")), d = c(u(a, "manual")), f = c(u(a, "noShift")), p = c(u(a, "noFlip")), m = c(u(a, "noFade")), v = c(u(a, "noAutoClose")), b = c(u(a, "hide")), B = c(u(a, "realtime")), w = c(u(a, "inline")), $ = c(u(a, "tooltip")), h = c(u(a, "html")), S = x(!1), y = x(null), C = x(null), O = x(null), k = x(null), I = x(null), F = (J) => {
      if (typeof J == "string" || J instanceof HTMLElement)
        return J;
      if (typeof J == "function")
        return J().$el ? J().$el : J();
      if (typeof J < "u")
        return J.$el;
    }, L = (J) => {
      if (J) {
        if (typeof J == "string") {
          const fe = document.getElementById(J);
          return fe || void 0;
        }
        return J;
      }
    }, _ = i(
      () => a.title ? yt(a.title, bt) : ""
    ), E = i(
      () => a.content ? yt(a.content, bt) : ""
    ), N = i(() => a.placement.startsWith("auto")), R = i(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const J = a.offset ? a.offset : $.value ? 0 : 10, fe = [Oo(J)];
      return p.value === !1 && !N.value && fe.push(Po()), N.value && fe.push(
        xs({
          alignment: a.placement.split("-")[1] || void 0
        })
      ), f.value === !1 && fe.push(Eo()), b.value === !0 && fe.push(Ns({ padding: 10 })), w.value === !0 && fe.push(zs()), fe.push(Gs({ element: O, padding: 10 })), fe;
    }), oe = i(
      () => N.value ? void 0 : a.placement
    ), { x: U, y: G, strategy: te, middlewareData: ve, placement: ye, update: Be } = Do(C, y, {
      placement: oe,
      middleware: R,
      strategy: a.strategy,
      whileElementsMounted: (...J) => js(...J, { animationFrame: B.value })
    }), ge = x({ position: "absolute" });
    ue(ve, () => {
      var J;
      if (b.value === !0 && ((J = ve.value.hide) != null && J.referenceHidden ? S.value = !0 : S.value = !1), ve.value.arrow) {
        const { x: fe, y: P } = ve.value.arrow;
        ge.value = {
          position: "absolute",
          top: P ? `${P}px` : "",
          left: fe ? `${fe}px` : ""
        };
      }
    });
    const be = i(() => {
      const J = $.value ? "tooltip" : "popover";
      return [
        J,
        `b-${J}`,
        {
          [`b-${J}-${a.variant}`]: a.variant !== null,
          show: o.value && !S.value,
          ["pe-none"]: !o.value,
          fade: !m.value,
          ["d-none"]: !o.value && m.value,
          [`${a.customClass}`]: a.customClass !== void 0,
          [`bs-${J}-${Qr(ye.value)}`]: ye.value !== void 0
        }
      ];
    }), { isOutside: W } = Ol(y), { isOutside: Y } = Ol(k), ie = (J) => {
      const fe = J ?? new Event("click");
      o.value ? se(fe) : q();
    }, j = (J, fe = {}) => new zt(J, {
      cancelable: !1,
      target: y.value || null,
      relatedTarget: null,
      trigger: null,
      ...fe,
      componentId: r.value
    }), q = () => {
      const J = j("show", { cancelable: !0 });
      if (t("show", J), J.defaultPrevented) {
        t("show-prevented");
        return;
      }
      n.value = !0, Te(() => {
        var fe;
        Be(), setTimeout(
          () => {
            Be(), o.value = !0, Te(() => {
              t("shown", j("shown"));
            });
          },
          typeof a.delay == "number" ? a.delay : ((fe = a.delay) == null ? void 0 : fe.show) || 0
        );
      });
    }, se = (J) => {
      var K;
      const fe = j("hide", { cancelable: !0 });
      if (t("hide", fe), fe.defaultPrevented) {
        t("hide-prevented");
        return;
      }
      const P = typeof a.delay == "number" ? a.delay : ((K = a.delay) == null ? void 0 : K.hide) || 100;
      setTimeout(() => {
        var me;
        (J == null ? void 0 : J.type) === "click" || (J == null ? void 0 : J.type) === "update:modelValue" && d.value || W.value && Y.value && !((me = y.value) != null && me.contains(document == null ? void 0 : document.activeElement)) ? (o.value = !1, Te(() => {
          setTimeout(
            () => {
              n.value = !1;
            },
            y.value ? ha(y.value) : 150
          ), t("hidden", j("hidden"));
        })) : setTimeout(() => {
          se(J);
        }, P);
      }, P);
    }, he = () => {
      var J;
      if (a.target) {
        const fe = L(F(a.target));
        fe ? k.value = fe : console.warn("Target element not found", a.target);
      } else
        k.value = (J = I.value) == null ? void 0 : J.nextElementSibling;
      if (a.reference) {
        const fe = L(F(a.reference));
        fe ? C.value = fe : console.warn("Reference element not found", a.reference);
      } else
        C.value = k.value;
      !k.value || d.value || Ma && (s.value && k.value.addEventListener("click", ie), !s.value && k.value.addEventListener("pointerenter", q), !s.value && k.value.addEventListener("pointerleave", se), !s.value && k.value.addEventListener("focus", q), !s.value && k.value.addEventListener("blur", se));
    }, we = () => {
      k.value && (k.value.removeEventListener("click", ie), k.value.removeEventListener("pointerenter", q), k.value.removeEventListener("pointerleave", se), k.value.removeEventListener("focus", q), k.value.removeEventListener("blur", se));
    };
    return Xo(
      y,
      () => {
        o.value && s.value && !v.value && !d.value && se(new Event("clickOutside"));
      },
      { ignore: [k] }
    ), ue(
      () => [a.click, a.target, a.reference],
      () => {
        we(), he();
      }
    ), Xe(he), oo(we), (J, fe) => (g(), V(pe, null, [
      Z("span", {
        ref_key: "placeholder",
        ref: I
      }, null, 512),
      A(J.$slots, "target", _e(Oe({ show: q, hide: se, toggle: ie, showState: o.value }))),
      Se(Xa, {
        tag: "Teleport",
        to: J.container,
        skip: !J.container
      }, {
        default: D(() => [
          n.value ? (g(), V("div", ae({
            key: 0,
            id: J.id
          }, J.$attrs, {
            ref_key: "element",
            ref: y,
            class: be.value,
            role: "tooltip",
            tabindex: "-1",
            style: {
              position: T(te),
              top: `${T(G)}px`,
              left: `${T(U)}px`,
              width: "max-content"
            }
          }), [
            Z("div", {
              ref_key: "arrow",
              ref: O,
              class: H(`${T($) ? "tooltip" : "popover"}-arrow`),
              style: Ge(ge.value),
              "data-popper-arrow": ""
            }, null, 6),
            J.title || J.$slots.title ? (g(), V(pe, { key: 0 }, [
              T(h) ? (g(), V("div", {
                key: 1,
                class: H(T($) ? "tooltip-inner" : "popover-header"),
                innerHTML: _.value
              }, null, 10, Jr)) : (g(), V("div", {
                key: 0,
                class: H(T($) ? "tooltip-inner" : "popover-header")
              }, [
                A(J.$slots, "title", {}, () => [
                  de(ee(J.title), 1)
                ])
              ], 2))
            ], 64)) : Q("", !0),
            T($) && !J.$slots.title && !J.title || !T($) ? (g(), V(pe, { key: 1 }, [
              T(h) ? (g(), V("div", {
                key: 1,
                class: H(T($) ? "tooltip-inner" : "popover-body"),
                innerHTML: E.value
              }, null, 10, Yr)) : (g(), V("div", {
                key: 0,
                class: H(T($) ? "tooltip-inner" : "popover-body")
              }, [
                A(J.$slots, "default", {}, () => [
                  de(ee(J.content), 1)
                ])
              ], 2))
            ], 64)) : Q("", !0)
          ], 16, Xr)) : Q("", !0)
        ]),
        _: 3
      }, 8, ["to", "skip"])
    ], 64));
  }
}), Zr = ({
  top: e,
  end: t,
  start: a,
  alignCenter: l,
  alignEnd: o
}) => {
  const n = e ? "top" : a ? "left" : t ? "right" : "bottom", r = o ? "end" : l ? null : "start";
  return `${n}${r ? `-${r}` : ""}`;
}, Qr = (e) => {
  const [t] = e.split("-");
  switch (t) {
    case "left":
      return "start";
    case "right":
      return "end";
    default:
      return t;
  }
}, Ca = (e) => typeof e != "object" || e.active !== !1, oa = (e, t) => {
  if (!Ca(e))
    return {};
  const l = typeof e > "u" || typeof e == "object" && !e.title && !e.content, o = t.getAttribute("title") || t.getAttribute("data-original-title");
  return l ? o ? (t.removeAttribute("title"), t.setAttribute("data-original-title", o), {
    content: yt(o, bt)
  }) : (console.warn(
    "Review tooltip directive usage. Some uses are not defining a title in root component or a value like `v-b-tooltip='{title: \"my title\"}'` nor `v-b-tooltip=\"'my title'\"` to define a title"
  ), {}) : typeof e == "string" ? {
    content: yt(e, bt)
  } : {
    title: e != null && e.title ? yt(e == null ? void 0 : e.title, bt) : void 0,
    content: e != null && e.content ? yt(e == null ? void 0 : e.content, bt) : void 0
  };
}, na = (e, t) => ({
  target: () => t,
  modelValue: e.modifiers.show,
  inline: e.modifiers.inline,
  click: e.modifiers.click,
  realtime: e.modifiers.realtime,
  placement: e.modifiers.left ? "left" : e.modifiers.right ? "right" : e.modifiers.bottom ? "bottom" : e.modifiers.top ? "top" : void 0,
  html: !0,
  ...typeof e.value == "object" ? e.value : {},
  title: null,
  content: null
}), sn = (e, t) => {
  var l;
  const a = document.createElement("span");
  t.modifiers.body ? document.body.appendChild(a) : t.modifiers.child ? e.appendChild(a) : (l = e.parentNode) == null || l.insertBefore(a, e.nextSibling), e.$__app = qn({ render: () => {
    var o;
    return ce(Ya, { ...(o = e.$__state) == null ? void 0 : o.value });
  } }), e.$__app.mount(a), e.$__element = a;
}, rn = (e) => {
  var a;
  const t = e.$__element;
  (a = e.$__app) == null || a.unmount(), delete e.$__app, delete e.$__state, setTimeout(() => {
    t == null || t.remove();
  }, 0), delete e.$__element;
}, ei = ["id"], ti = /* @__PURE__ */ z({
  __name: "BAccordion",
  props: {
    flush: { type: [String, Boolean], default: !1 },
    free: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    modelValue: { default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = Ve(a, "modelValue", t, { passive: !0 }), o = Ae(u(a, "id"), "accordion"), n = c(u(a, "flush")), r = c(u(a, "free")), s = i(() => ({
      "accordion-flush": n.value
    }));
    return Je(_o, {
      openItem: ke(l),
      free: r,
      setOpenItem: (d) => {
        l.value = d;
      }
    }), (d, f) => (g(), V("div", {
      id: T(o),
      class: H(["accordion", s.value])
    }, [
      A(d.$slots, "default")
    ], 10, ei));
  }
}), un = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BCollapse",
  props: {
    id: { default: void 0 },
    modelValue: { type: [String, Boolean], default: !1 },
    tag: { default: "div" },
    toggle: { type: [String, Boolean], default: !1 },
    horizontal: { type: [String, Boolean], default: !1 },
    visible: { type: [String, Boolean], default: !1 },
    isNav: { type: [String, Boolean], default: !1 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = (O, k = {}) => new zt(O, {
      cancelable: !1,
      target: v.value || null,
      relatedTarget: null,
      trigger: null,
      ...k,
      componentId: m.value
    }), n = Ve(l, "modelValue", a, { passive: !0 }), r = c(n), s = c(u(l, "toggle")), d = c(u(l, "horizontal")), f = c(u(l, "isNav")), p = c(u(l, "visible")), m = Ae(u(l, "id"), "collapse"), v = x(null), b = x(!1), B = x(r.value), w = i(() => ({
      show: B.value,
      "navbar-collapse": f.value,
      collapsing: b.value,
      closing: B.value && !r.value,
      "collapse-horizontal": d.value
    })), $ = () => n.value = !1, h = () => n.value = !0, S = () => n.value = !r.value, y = () => {
      B.value = !0, b.value = !0;
      const O = o("show", { cancelable: !0 });
      if (a("show", O), O.defaultPrevented) {
        a("show-prevented");
        return;
      }
      Te(() => {
        v.value !== null && (d.value ? v.value.style.width = `${v.value.scrollWidth}px` : v.value.style.height = `${v.value.scrollHeight}px`, setTimeout(() => {
          b.value = !1, a("shown", o("shown")), v.value !== null && (v.value.style.height = "", v.value.style.width = "");
        }, ha(v.value)));
      });
    }, C = () => {
      const O = o("hide", { cancelable: !0 });
      if (a("hide", O), O.defaultPrevented) {
        a("hide-prevented");
        return;
      }
      v.value !== null && (d.value ? v.value.style.width = `${v.value.scrollWidth}px` : v.value.style.height = `${v.value.scrollHeight}px`, v.value.offsetHeight, b.value = !0, Te(() => {
        v.value !== null && (v.value.style.height = "", v.value.style.width = "", setTimeout(() => {
          B.value = !1, b.value = !1, a("hidden", o("hidden"));
        }, ha(v.value)));
      }));
    };
    return ue([n, B], () => {
      if (r.value === !0) {
        if (B.value)
          return;
        y();
        return;
      }
      C();
    }), Xe(() => {
      v.value !== null && !r.value && s.value && Te(() => {
        n.value = !0;
      });
    }), p.value && (n.value = !0, B.value = !0), ue(p, (O) => {
      O ? h() : $();
    }), Ce(v, "bv-toggle", () => {
      n.value = !r.value;
    }), t({
      close: $,
      open: h,
      toggle: S,
      visible: ke(B),
      isNav: f
    }), Je(qa, {
      id: m,
      close: $,
      open: h,
      toggle: S,
      visible: ke(B),
      isNav: f
    }), (O, k) => (g(), V(pe, null, [
      A(O.$slots, "header", _e(Oe({ visible: T(r), toggle: S, open: h, close: $, id: T(m) }))),
      (g(), M(ne(O.tag), ae({
        id: T(m),
        ref_key: "element",
        ref: v,
        class: ["collapse", w.value],
        "is-nav": T(f)
      }, O.$attrs), {
        default: D(() => [
          A(O.$slots, "default", _e(Oe({ visible: T(r), toggle: S, open: h, close: $ })))
        ]),
        _: 3
      }, 16, ["id", "class", "is-nav"])),
      A(O.$slots, "footer", _e(Oe({ visible: T(r), toggle: S, open: h, close: $, id: T(m) })))
    ], 64));
  }
}), ai = { class: "accordion-item" }, li = ["aria-expanded", "aria-controls", "onClick"], oi = { class: "accordion-body" }, ni = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BAccordionItem",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    modelValue: { type: [String, Boolean], default: !1 },
    headerTag: { default: "h2" },
    tag: { default: void 0 },
    toggle: { type: [String, Boolean], default: void 0 },
    horizontal: { type: [String, Boolean], default: void 0 },
    visible: { type: [String, Boolean], default: !1 },
    isNav: { type: [String, Boolean], default: void 0 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = {
      show: (s) => t("show", s),
      shown: (s) => t("shown", s),
      hide: (s) => t("hide", s),
      hidden: (s) => t("hidden", s),
      "hide-prevented": () => t("hide-prevented"),
      "show-prevented": () => t("show-prevented")
    }, o = Ve(a, "modelValue", t, { passive: !0 }), n = Ee(_o, null), r = Ae(u(a, "id"), "accordion_item");
    return Xe(() => {
      o.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(r.value)), !o.value && (n == null ? void 0 : n.openItem.value) === r.value && (o.value = !0);
    }), ue(
      () => n == null ? void 0 : n.openItem.value,
      () => o.value = (n == null ? void 0 : n.openItem.value) === r.value && !(n != null && n.free.value)
    ), ue(o, () => {
      o.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(r.value));
    }), (s, d) => (g(), V("div", ai, [
      Se(un, ae({
        id: T(r),
        modelValue: T(o),
        "onUpdate:modelValue": d[0] || (d[0] = (f) => lo(o) ? o.value = f : null),
        class: "accordion-collapse"
      }, s.$attrs, {
        "aria-labelledby": `heading${T(r)}`,
        tag: s.tag,
        toggle: s.toggle,
        horizontal: s.horizontal,
        visible: s.visible,
        "is-nav": s.isNav
      }, Gn(l)), {
        header: D(({ visible: f, toggle: p }) => [
          (g(), M(ne(s.headerTag), {
            id: `heading${T(r)}`,
            class: "accordion-header"
          }, {
            default: D(() => [
              Z("button", {
                class: H(["accordion-button", { collapsed: !f }]),
                type: "button",
                "aria-expanded": f ? "true" : "false",
                "aria-controls": T(r),
                onClick: p
              }, [
                A(s.$slots, "title", {}, () => [
                  de(ee(s.title), 1)
                ])
              ], 10, li)
            ]),
            _: 2
          }, 1032, ["id"]))
        ]),
        default: D(() => [
          Z("div", oi, [
            A(s.$slots, "default")
          ])
        ]),
        _: 3
      }, 16, ["id", "modelValue", "aria-labelledby", "tag", "toggle", "horizontal", "visible", "is-nav"])
    ]));
  }
}), Ct = /* @__PURE__ */ z({
  __name: "BTransition",
  props: {
    appear: { type: [String, Boolean], default: !1 },
    mode: { default: void 0 },
    noFade: { type: [String, Boolean], default: !1 },
    transProps: { default: void 0 }
  },
  setup(e) {
    const t = e, a = c(u(t, "appear")), l = c(u(t, "noFade")), o = i(() => {
      const s = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: ""
      }, d = {
        ...s,
        enterActiveClass: "fade showing",
        leaveActiveClass: "fade showing"
      };
      return l.value ? s : d;
    }), n = i(() => ({ mode: t.mode, css: !0, ...o.value })), r = i(
      () => t.transProps !== void 0 ? {
        // Order matters here since the props.transProps would get overwritten if it came first
        // But the goal of props.transProps is to overwrite base properties
        ...n.value,
        ...t.transProps
      } : a.value ? {
        ...n.value,
        appear: !0,
        appearActiveClass: o.value.enterActiveClass,
        appearToClass: o.value.enterToClass
      } : n.value
    );
    return (s, d) => (g(), M(Wn, _e(Oe(r.value)), {
      default: D(() => [
        A(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), si = ["type", "disabled", "aria-label"], Tt = /* @__PURE__ */ z({
  __name: "BCloseButton",
  props: {
    ariaLabel: { default: "Close" },
    disabled: { type: [String, Boolean], default: !1 },
    white: { type: [String, Boolean], default: !1 },
    type: { default: "button" }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(u(a, "disabled")), o = c(u(a, "white")), n = i(() => ({
      "btn-close-white": o.value
    }));
    return (r, s) => (g(), V("button", {
      type: r.type,
      class: H(["btn-close", n.value]),
      disabled: T(l),
      "aria-label": r.ariaLabel,
      onClick: s[0] || (s[0] = (d) => t("click", d))
    }, null, 10, si));
  }
}), ri = {
  key: 0,
  class: "visually-hidden"
}, va = /* @__PURE__ */ z({
  __name: "BSpinner",
  props: {
    label: { default: void 0 },
    role: { default: "status" },
    small: { type: [String, Boolean], default: !1 },
    tag: { default: "span" },
    type: { default: "border" },
    variant: { default: null }
  },
  setup(e) {
    const t = e, a = Le(), l = c(u(t, "small")), o = i(() => ({
      "spinner-border": t.type === "border",
      "spinner-border-sm": t.type === "border" && l.value,
      "spinner-grow": t.type === "grow",
      "spinner-grow-sm": t.type === "grow" && l.value,
      [`text-${t.variant}`]: t.variant !== null
    })), n = i(() => !Ie(a.label));
    return (r, s) => (g(), M(ne(r.tag), {
      class: H(o.value),
      role: r.label || n.value ? r.role : null,
      "aria-hidden": r.label || n.value ? null : !0
    }, {
      default: D(() => [
        r.label || n.value ? (g(), V("span", ri, [
          A(r.$slots, "label", {}, () => [
            de(ee(r.label), 1)
          ])
        ])) : Q("", !0)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
}), vt = {
  active: { type: [Boolean, String, void 0], default: void 0 },
  activeClass: { type: String, default: "router-link-active" },
  append: { type: [Boolean, String], default: !1 },
  disabled: { type: [Boolean, String], default: !1 },
  event: { type: [String, Array], default: "click" },
  href: { type: String },
  // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},
  // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},
  rel: { type: String, default: null },
  replace: { type: [Boolean, String], default: !1 },
  routerComponentName: { type: String, default: "router-link" },
  routerTag: { type: String, default: "a" },
  target: { type: String, default: "_self" },
  to: { type: [String, Object], default: null },
  variant: { type: String, default: null }
}, ii = z({
  // TODO this component will likely have an issue with inheritAttrs
  props: vt,
  emits: ["click"],
  setup(e, { emit: t, attrs: a }) {
    const l = c(u(e, "active")), o = c(u(e, "append")), n = c(u(e, "disabled")), r = c(u(e, "replace")), s = Ee(qa, null), d = Ee(Ga, null), f = () => {
      var h;
      d !== null && ((h = s == null ? void 0 : s.close) == null || h.call(s));
    }, p = ra(), m = x(null), v = i(() => {
      const h = e.routerComponentName.split("-").map((y) => y.charAt(0).toUpperCase() + y.slice(1)).join("");
      return !((p == null ? void 0 : p.appContext.app.component(h)) !== void 0) || n.value || !e.to ? "a" : e.routerComponentName;
    }), b = i(() => {
      const h = "#";
      if (e.href)
        return e.href;
      if (typeof e.to == "string")
        return e.to || h;
      const S = e.to;
      if (Object.prototype.toString.call(S) === "[object Object]" && (S.path || S.query || S.hash)) {
        const y = S.path || "", C = S.query ? `?${Object.keys(S.query).map((k) => `${k}=${S.query[k]}`).join("=")}` : "", O = !S.hash || S.hash.charAt(0) === "#" ? S.hash || "" : `#${S.hash}`;
        return `${y}${C}${O}` || h;
      }
      return h;
    }), B = i(() => ({
      class: e.variant !== null && `link-${e.variant}`,
      to: e.to,
      href: b.value,
      target: e.target,
      rel: e.target === "_blank" && e.rel === null ? "noopener" : e.rel || null,
      tabindex: n.value ? "-1" : typeof a.tabindex > "u" ? null : a.tabindex,
      "aria-disabled": n.value ? !0 : null
    }));
    return {
      computedLinkClasses: i(() => ({
        active: l.value,
        disabled: n.value
      })),
      tag: v,
      routerAttr: B,
      link: m,
      clicked: (h) => {
        var S;
        if (n.value) {
          h.preventDefault(), h.stopImmediatePropagation();
          return;
        }
        (S = s == null ? void 0 : s.close) == null || S.call(s), t("click", h);
      },
      activeBoolean: l,
      appendBoolean: o,
      disabledBoolean: n,
      replaceBoolean: r,
      closeCollapse: f
    };
  }
}), Re = (e, t) => {
  const a = e.__vccOpts || e;
  for (const [l, o] of t)
    a[l] = o;
  return a;
};
function ui(e, t, a, l, o, n) {
  const r = za("router-link");
  return e.tag === "router-link" ? (g(), M(r, ae({ key: 0 }, e.routerAttr, { custom: "" }), {
    default: D(({ href: s, navigate: d, isActive: f }) => [
      (g(), M(ne(e.routerTag), ae({
        ref: "link",
        href: s,
        class: [(e.activeBoolean ?? f) && e.activeClass]
      }, e.$attrs, {
        onClick: (p) => {
          d(p), e.closeCollapse();
        }
      }), {
        default: D(() => [
          A(e.$slots, "default")
        ]),
        _: 2
      }, 1040, ["href", "class", "onClick"]))
    ]),
    _: 3
  }, 16)) : (g(), M(ne(e.tag), ae({
    key: 1,
    ref: "link",
    class: e.computedLinkClasses
  }, e.routerAttr, { onClick: e.clicked }), {
    default: D(() => [
      A(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "onClick"]));
}
const ze = /* @__PURE__ */ Re(ii, [["render", ui]]), di = z({
  components: { BLink: ze, BSpinner: va },
  props: {
    ...vt,
    active: { type: [Boolean, String], default: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    href: { type: String, default: void 0 },
    pill: { type: [Boolean, String], default: !1 },
    pressed: { type: [Boolean, String], default: null },
    rel: { type: String, default: void 0 },
    size: { type: String, default: "md" },
    squared: { type: [Boolean, String], default: !1 },
    tag: { type: String, default: "button" },
    target: { type: String, default: "_self" },
    type: { type: String, default: "button" },
    variant: { type: String, default: "secondary" },
    loading: { type: [Boolean, String], default: !1 },
    loadingMode: { type: String, default: "inline" },
    block: { type: [Boolean, String], default: !1 }
  },
  emits: ["click", "update:pressed"],
  setup(e, { emit: t }) {
    const a = Ve(e, "pressed", t), l = c(u(e, "active")), o = c(u(e, "block")), n = c(u(e, "disabled")), r = c(u(e, "pill")), s = c(u(e, "pressed")), d = c(u(e, "squared")), f = c(u(e, "loading")), p = i(() => typeof s.value == "boolean"), m = i(
      () => e.tag === "button" && e.href === void 0 && e.to === null
    ), v = i(() => It(e)), b = i(() => e.to !== null), B = i(
      () => e.href !== void 0 ? !1 : !m.value
    ), w = i(() => [
      [`btn-${e.size}`],
      {
        [`btn-${e.variant}`]: e.variant !== null,
        "btn-block": o.value,
        active: l.value || s.value,
        "rounded-pill": r.value,
        "rounded-0": d.value,
        disabled: n.value
      }
    ]), $ = i(() => ({
      "aria-disabled": B.value ? n.value : null,
      "aria-pressed": p.value ? s.value : null,
      autocomplete: p.value ? "off" : null,
      disabled: m.value ? n.value : null,
      href: e.href,
      rel: v.value ? e.rel : null,
      role: B.value || v.value ? "button" : null,
      target: v.value ? e.target : null,
      type: m.value ? e.type : null,
      to: m.value ? null : e.to,
      append: v.value ? e.append : null,
      activeClass: b.value ? e.activeClass : null,
      event: b.value ? e.event : null,
      replace: b.value ? e.replace : null,
      routerComponentName: b.value ? e.routerComponentName : null,
      routerTag: b.value ? e.routerTag : null
    })), h = i(
      () => b.value ? ze : e.href ? "a" : e.tag
    );
    return {
      computedClasses: w,
      computedAttrs: $,
      computedTag: h,
      clicked: (y) => {
        if (n.value) {
          y.preventDefault(), y.stopPropagation();
          return;
        }
        t("click", y), p.value && (a.value = !s.value);
      },
      loadingBoolean: f
    };
  }
});
function ci(e, t, a, l, o, n) {
  const r = za("b-spinner");
  return g(), M(ne(e.computedTag), ae({
    class: ["btn", e.computedClasses]
  }, e.computedAttrs, { onClick: e.clicked }), {
    default: D(() => [
      e.loadingBoolean ? (g(), V("div", {
        key: 0,
        class: H(["btn-loading", { "mode-fill": e.loadingMode === "fill", "mode-inline": e.loadingMode === "inline" }])
      }, [
        A(e.$slots, "loading", {}, () => [
          Se(r, {
            class: "btn-spinner",
            small: e.size !== "lg"
          }, null, 8, ["small"])
        ])
      ], 2)) : Q("", !0),
      Z("div", {
        class: H(["btn-content", { "btn-loading-fill": e.loadingBoolean && e.loadingMode === "fill" }])
      }, [
        A(e.$slots, "default")
      ], 2)
    ]),
    _: 3
  }, 16, ["class", "onClick"]);
}
const $t = /* @__PURE__ */ Re(di, [["render", ci]]), fi = ["onMouseenter"], vi = /* @__PURE__ */ z({
  __name: "BAlert",
  props: {
    noHoverPause: { type: [String, Boolean], default: !1 },
    dismissLabel: { default: "Close" },
    dismissible: { type: [String, Boolean], default: !1 },
    fade: { type: [String, Boolean], default: !1 },
    closeVariant: { default: "secondary" },
    modelValue: { type: [Boolean, Number], default: !1 },
    variant: { default: "info" },
    closeContent: { default: void 0 },
    immediate: { type: [String, Boolean], default: !0 },
    interval: { default: 1e3 },
    showOnPause: { type: [String, Boolean], default: !0 }
  },
  emits: ["closed", "close-countdown", "update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = Le(), n = Ve(l, "modelValue", a), r = c(u(l, "dismissible")), s = c(u(l, "fade")), d = c(u(l, "immediate")), f = c(u(l, "showOnPause")), p = c(u(l, "noHoverPause")), m = i(() => !Ie(o.close)), v = i(
      () => typeof n.value == "boolean" ? 0 : n.value
    ), b = i(() => ({
      [`alert-${l.variant}`]: l.variant !== null,
      "alert-dismissible": r.value
    })), {
      isActive: B,
      pause: w,
      restart: $,
      resume: h,
      stop: S,
      isPaused: y,
      value: C
    } = Wr(v, u(l, "interval"), {
      immediate: typeof n.value == "number" && d.value
    }), O = i(
      () => typeof n.value == "boolean" ? n.value : B.value || f.value && y.value
    ), k = i(() => ({
      variant: l.closeVariant,
      type: "button"
    }));
    qe(() => a("close-countdown", C.value));
    const I = () => {
      typeof n.value == "boolean" ? n.value = !1 : (n.value = 0, S()), a("closed");
    }, F = () => {
      p.value || w();
    };
    return oo(S), t({ pause: w, resume: h, restart: $, stop: S }), (L, _) => (g(), M(Ct, {
      "no-fade": !T(s),
      "trans-props": { enterToClass: "show" }
    }, {
      default: D(() => [
        O.value ? (g(), V("div", {
          key: 0,
          class: H(["alert", b.value]),
          role: "alert",
          "aria-live": "polite",
          "aria-atomic": "true",
          onMouseenter: ct(F, ["stop"]),
          onMouseleave: _[0] || (_[0] = ct(
            //@ts-ignore
            (...E) => T(h) && T(h)(...E),
            ["stop"]
          ))
        }, [
          A(L.$slots, "default"),
          T(r) ? (g(), V(pe, { key: 0 }, [
            m.value || L.closeContent ? (g(), M($t, ae({ key: 0 }, k.value, { onClick: I }), {
              default: D(() => [
                A(L.$slots, "close", {}, () => [
                  de(ee(L.closeContent), 1)
                ])
              ]),
              _: 3
            }, 16)) : (g(), M(Tt, ae({
              key: 1,
              "aria-label": L.dismissLabel
            }, k.value, { onClick: I }), null, 16, ["aria-label"]))
          ], 64)) : Q("", !0)
        ], 42, fi)) : Q("", !0)
      ]),
      _: 3
    }, 8, ["no-fade"]));
  }
}), pi = {
  key: 0,
  class: "b-avatar-custom"
}, mi = {
  key: 1,
  class: "b-avatar-img"
}, gi = ["src", "alt"], Ta = (e) => {
  const t = typeof e == "string" && uo(e) ? Vt(e, 0) : e;
  return typeof t == "number" ? `${t}px` : t || null;
}, bi = /* @__PURE__ */ z({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    ariaLabel: { default: void 0 },
    badge: { type: [Boolean, String], default: !1 },
    badgeLeft: { type: [String, Boolean], default: !1 },
    badgeOffset: { default: void 0 },
    badgeTop: { type: [String, Boolean], default: !1 },
    badgeVariant: { default: "primary" },
    button: { type: [String, Boolean], default: !1 },
    buttonType: { default: "button" },
    disabled: { type: [String, Boolean], default: !1 },
    icon: { default: void 0 },
    rounded: { type: [Boolean, String], default: "circle" },
    size: { default: void 0 },
    square: { type: [String, Boolean], default: !1 },
    src: { default: void 0 },
    text: { default: void 0 },
    textVariant: { default: null },
    variant: { default: "secondary" }
  },
  emits: ["click", "img-error"],
  setup(e, { emit: t }) {
    const a = e, l = Le(), o = Ee($o, null), n = ["sm", null, "lg"], r = 0.4, s = r * 0.7, d = c(u(a, "badgeLeft")), f = c(u(a, "badgeTop")), p = c(u(a, "button")), m = c(u(a, "disabled")), v = c(u(a, "square")), b = i(() => !Ie(l.default)), B = i(() => !Ie(l.badge)), w = i(() => !!a.badge || a.badge === "" || B.value), $ = i(
      () => (o == null ? void 0 : o.size.value) ?? Ta(a.size)
    ), h = i(
      () => (o == null ? void 0 : o.variant.value) ?? a.variant
    ), S = i(() => (o == null ? void 0 : o.rounded.value) ?? a.rounded), y = i(() => ({
      type: p.value ? a.buttonType : void 0,
      "aria-label": a.ariaLabel || null,
      disabled: m.value || null
    })), C = i(() => ({
      [`bg-${a.badgeVariant}`]: a.badgeVariant !== null
    })), O = i(() => a.badge === !0 ? "" : a.badge), k = i(() => ({
      [`text-${a.badgeVariant !== null && oe(a.badgeVariant)}`]: a.badgeVariant !== null
    })), I = i(() => ({
      [`b-avatar-${a.size}`]: !!a.size && n.indexOf(Ta(a.size)) !== -1,
      [`bg-${h.value}`]: h.value !== null,
      badge: !p.value && h.value !== null && b.value,
      rounded: S.value === "" || S.value === !0,
      ["rounded-circle"]: !v.value && S.value === "circle",
      ["rounded-0"]: v.value || S.value === "0",
      ["rounded-1"]: !v.value && S.value === "sm",
      ["rounded-3"]: !v.value && S.value === "lg",
      ["rounded-top"]: !v.value && S.value === "top",
      ["rounded-bottom"]: !v.value && S.value === "bottom",
      ["rounded-start"]: !v.value && S.value === "left",
      ["rounded-end"]: !v.value && S.value === "right",
      btn: p.value,
      [`btn-${h.value}`]: p.value ? h.value !== null : !1
    })), F = i(() => ({
      [`text-${a.textVariant || h.value !== null && oe(h.value)}`]: a.textVariant || h.value !== null
    })), L = i(() => {
      const te = a.badgeOffset || "0px";
      return {
        fontSize: (n.indexOf($.value || null) === -1 ? `calc(${$.value} * ${s})` : "") || "",
        top: f.value ? te : "",
        bottom: f.value ? "" : te,
        left: d.value ? te : "",
        right: d.value ? "" : te
      };
    }), _ = i(() => {
      const te = n.indexOf($.value || null) === -1 ? `calc(${$.value} * ${r})` : null;
      return te ? { fontSize: te } : {};
    }), E = i(() => {
      var ye;
      const te = ((ye = o == null ? void 0 : o.overlapScale) == null ? void 0 : ye.value) || 0, ve = $.value && te ? `calc(${$.value} * -${te})` : null;
      return ve ? { marginLeft: ve, marginRight: ve } : {};
    }), N = i(() => p.value ? "button" : "span"), R = i(() => ({
      ...E.value,
      width: $.value ?? void 0,
      height: $.value ?? void 0
    })), oe = (te) => te === "light" || te === "warning" ? "dark" : "light", U = (te) => {
      !m.value && p.value && t("click", te);
    }, G = (te) => t("img-error", te);
    return (te, ve) => (g(), M(ne(N.value), ae({
      class: ["b-avatar", I.value],
      style: R.value
    }, y.value, { onClick: U }), {
      default: D(() => [
        b.value ? (g(), V("span", pi, [
          A(te.$slots, "default")
        ])) : te.src ? (g(), V("span", mi, [
          Z("img", {
            src: te.src,
            alt: te.alt,
            onError: G
          }, null, 40, gi)
        ])) : te.text ? (g(), V("span", {
          key: 2,
          class: H(["b-avatar-text", F.value]),
          style: Ge(_.value)
        }, ee(te.text), 7)) : Q("", !0),
        w.value ? (g(), V("span", {
          key: 3,
          class: H(["b-avatar-badge", C.value]),
          style: Ge(L.value)
        }, [
          B.value ? A(te.$slots, "badge", { key: 0 }) : (g(), V("span", {
            key: 1,
            class: H(k.value)
          }, ee(O.value), 3))
        ], 6)) : Q("", !0)
      ]),
      _: 3
    }, 16, ["class", "style"]));
  }
}), yi = /* @__PURE__ */ z({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    rounded: { type: [Boolean, String], default: !1 },
    size: { default: void 0 },
    square: { type: [String, Boolean], default: !1 },
    tag: { default: "div" },
    variant: { default: null }
  },
  setup(e) {
    const t = e, a = c(u(t, "square")), l = i(() => Ta(t.size)), o = i(
      () => Math.min(Math.max(r(t.overlap), 0), 1) / 2
    ), n = i(() => {
      const s = l.value ? `calc(${l.value} * ${o.value})` : null;
      return s ? { paddingLeft: s, paddingRight: s } : {};
    }), r = (s) => typeof s == "string" && uo(s) ? Vt(s, 0) : s || 0;
    return Je($o, {
      overlapScale: o,
      size: ke(u(t, "size")),
      square: a,
      rounded: ke(u(t, "rounded")),
      variant: ke(u(t, "variant"))
    }), (s, d) => (g(), M(ne(s.tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: D(() => [
        Z("div", {
          class: "b-avatar-group-inner",
          style: Ge(n.value)
        }, [
          A(s.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
}), El = Rt(vt, ["event", "routerTag"]), hi = z({
  components: { BLink: ze },
  props: {
    ...El,
    pill: { type: [Boolean, String], default: !1 },
    tag: { type: String, default: "span" },
    textIndicator: { type: [Boolean, String], default: !1 },
    dotIndicator: { type: [Boolean, String], default: !1 },
    variant: { type: String, default: "secondary" }
  },
  setup(e) {
    const t = c(u(e, "pill")), a = c(u(e, "textIndicator")), l = c(u(e, "dotIndicator")), o = c(u(e, "active")), n = c(u(e, "disabled")), r = i(() => It(e)), s = i(
      () => r.value ? ze : e.tag
    ), d = i(() => ({
      [`bg-${e.variant}`]: e.variant !== null,
      active: o.value,
      disabled: n.value,
      "text-dark": e.variant !== null && ["warning", "info", "light"].includes(e.variant),
      "rounded-pill": t.value,
      "position-absolute top-0 start-100 translate-middle": a.value || l.value,
      "p-2 border border-light rounded-circle": l.value,
      "text-decoration-none": r.value
    })), f = i(
      () => r.value ? ja(e, El) : {}
    );
    return {
      computedClasses: d,
      computedLinkProps: f,
      computedTag: s
    };
  }
});
function Bi(e, t, a, l, o, n) {
  return g(), M(ne(e.computedTag), ae({
    class: ["badge", e.computedClasses]
  }, e.computedLinkProps), {
    default: D(() => [
      A(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class"]);
}
const Si = /* @__PURE__ */ Re(hi, [["render", Bi]]), Il = Rt(vt, ["event", "routerTag"]), wi = z({
  components: { BLink: ze },
  props: {
    ...Il,
    active: { type: [Boolean, String], default: !1 },
    ariaCurrent: { type: String, default: "location" },
    disabled: { type: [Boolean, String], default: !1 },
    text: { type: String, default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = c(u(e, "active")), l = c(u(e, "disabled")), o = i(() => ({
      active: a.value
    })), n = i(
      () => a.value ? "span" : ze
    ), r = i(
      () => a.value ? e.ariaCurrent : void 0
    );
    return {
      computedLinkProps: i(
        () => n.value !== "span" ? ja(e, Il) : {}
      ),
      computedClasses: o,
      computedTag: n,
      computedAriaCurrent: r,
      clicked: (f) => {
        if (l.value || a.value) {
          f.preventDefault(), f.stopImmediatePropagation();
          return;
        }
        l.value || t("click", f);
      }
    };
  }
});
function $i(e, t, a, l, o, n) {
  return g(), V("li", {
    class: H(["breadcrumb-item", e.computedClasses])
  }, [
    (g(), M(ne(e.computedTag), ae({ "aria-current": e.computedAriaCurrent }, e.computedLinkProps, { onClick: e.clicked }), {
      default: D(() => [
        A(e.$slots, "default", {}, () => [
          de(ee(e.text), 1)
        ])
      ]),
      _: 3
    }, 16, ["aria-current", "onClick"]))
  ], 2);
}
const dn = /* @__PURE__ */ Re(wi, [["render", $i]]), _i = { "aria-label": "breadcrumb" }, ki = { class: "breadcrumb" }, Ci = /* @__PURE__ */ z({
  __name: "BBreadcrumb",
  props: {
    items: { default: void 0 }
  },
  setup(e) {
    const t = e, a = Zo(), l = i(() => {
      const o = t.items || (a == null ? void 0 : a.items) || [];
      let n = !1;
      return o.map((s, d) => (typeof s == "string" && (s = { text: s }, d < o.length - 1 && (s.href = "#")), s.active && (n = !0), !s.active && !n && (s.active = d + 1 === o.length), s));
    });
    return (o, n) => (g(), V("nav", _i, [
      Z("ol", ki, [
        A(o.$slots, "prepend"),
        (g(!0), V(pe, null, $e(l.value, (r, s) => (g(), M(dn, ae({ key: s }, r), {
          default: D(() => [
            de(ee(r.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        A(o.$slots, "default"),
        A(o.$slots, "append")
      ])
    ]));
  }
}), Ti = /* @__PURE__ */ z({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: { default: "md" },
    tag: { default: "div" },
    vertical: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, a = c(u(t, "vertical")), l = i(() => ({
      "btn-group": !a.value,
      [`btn-group-${t.size}`]: t.size !== "md",
      "btn-group-vertical": a.value
    }));
    return (o, n) => (g(), M(ne(o.tag), {
      class: H(l.value),
      role: "group",
      "aria-label": o.ariaLabel
    }, {
      default: D(() => [
        A(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-label"]));
  }
}), Ai = ["role", "aria-label"], Vi = /* @__PURE__ */ z({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    justify: { type: [String, Boolean], default: !1 },
    role: { default: "toolbar" }
  },
  setup(e) {
    const a = c(u(e, "justify")), l = i(() => ({
      "justify-content-between": a.value
    }));
    return (o, n) => (g(), V("div", {
      class: H([l.value, "btn-toolbar"]),
      role: o.role,
      "aria-label": o.ariaLabel
    }, [
      A(o.$slots, "default")
    ], 10, Ai));
  }
}), Pi = '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>', Za = /* @__PURE__ */ z({
  __name: "BImg",
  props: {
    alt: { default: void 0 },
    blank: { type: [String, Boolean], default: !1 },
    blankColor: { default: "transparent" },
    block: { type: [String, Boolean], default: !1 },
    center: { type: [String, Boolean], default: !1 },
    fluid: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    fluidGrow: { type: [String, Boolean], default: !1 },
    height: { default: void 0 },
    start: { type: [String, Boolean], default: !1 },
    end: { type: [String, Boolean], default: !1 },
    rounded: { type: [Boolean, String], default: !1 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    thumbnail: { type: [String, Boolean], default: !1 },
    width: { default: void 0 }
  },
  setup(e) {
    const t = e, a = c(u(t, "lazy")), l = c(u(t, "blank")), o = c(u(t, "block")), n = c(u(t, "center")), r = c(u(t, "fluid")), s = c(u(t, "fluidGrow")), d = c(u(t, "start")), f = c(u(t, "end")), p = c(u(t, "thumbnail")), m = i(
      () => typeof t.srcset == "string" ? t.srcset.split(",").filter((y) => y).join(",") : Array.isArray(t.srcset) ? t.srcset.filter((y) => y).join(",") : void 0
    ), v = i(
      () => typeof t.sizes == "string" ? t.sizes.split(",").filter((y) => y).join(",") : Array.isArray(t.sizes) ? t.sizes.filter((y) => y).join(",") : void 0
    ), b = i(() => {
      const y = (k) => k === void 0 ? void 0 : typeof k == "number" ? k : Number.parseInt(k, 10) || void 0, C = y(t.width), O = y(t.height);
      if (l.value) {
        if (C !== void 0 && O === void 0)
          return { height: C, width: C };
        if (C === void 0 && O !== void 0)
          return { height: O, width: O };
        if (C === void 0 && O === void 0)
          return { height: 1, width: 1 };
      }
      return {
        width: C,
        height: O
      };
    }), B = i(
      () => S(b.value.width, b.value.height, t.blankColor)
    ), w = i(() => ({
      src: l.value ? B.value : t.src,
      alt: t.alt,
      width: b.value.width || void 0,
      height: b.value.height || void 0,
      srcset: l.value ? void 0 : m.value,
      sizes: l.value ? void 0 : v.value,
      loading: a.value ? "lazy" : "eager"
    })), $ = i(
      () => d.value ? "float-start" : f.value ? "float-end" : n.value ? "mx-auto" : void 0
    ), h = i(() => ({
      "img-thumbnail": p.value,
      "img-fluid": r.value || s.value,
      "w-100": s.value,
      rounded: t.rounded === "" || t.rounded === !0,
      [`rounded-${t.rounded}`]: typeof t.rounded == "string" && t.rounded !== "",
      [`${$.value}`]: $.value !== void 0,
      "d-block": o.value || n.value
    })), S = (y, C, O) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(
      Pi.replace("%{w}", String(y)).replace("%{h}", String(C)).replace("%{f}", O)
    )}`;
    return (y, C) => (g(), V("img", ae({ class: h.value }, w.value), null, 16));
  }
}), sa = /* @__PURE__ */ z({
  __name: "BCardImg",
  props: {
    alt: { default: void 0 },
    blank: { type: [String, Boolean], default: !1 },
    blankColor: { default: void 0 },
    bottom: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    height: { default: void 0 },
    start: { type: [String, Boolean], default: !1 },
    end: { type: [String, Boolean], default: !1 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    top: { type: [String, Boolean], default: !1 },
    width: { default: void 0 }
  },
  emits: ["load"],
  setup(e, { emit: t }) {
    const a = e, l = c(u(a, "bottom")), o = c(u(a, "end")), n = c(u(a, "start")), r = c(u(a, "top")), s = i(
      () => r.value ? "card-img-top" : o.value ? "card-img-right" : l.value ? "card-img-bottom" : n.value ? "card-img-left" : "card-img"
    ), d = i(() => ({
      alt: a.alt,
      height: a.height,
      src: a.src,
      lazy: a.lazy,
      width: a.width,
      blank: a.blank,
      blankColor: a.blankColor,
      sizes: a.sizes,
      srcset: a.srcset
    }));
    return (f, p) => (g(), M(Za, ae({ class: s.value }, d.value, {
      onLoad: p[0] || (p[0] = (m) => t("load", m))
    }), null, 16, ["class"]));
  }
}), Oi = ["innerHTML"], cn = /* @__PURE__ */ z({
  __name: "BCardHeadFoot",
  props: {
    text: { default: void 0 },
    bgVariant: { default: null },
    borderVariant: { default: null },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: null }
  },
  setup(e) {
    const t = e, a = i(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== null,
      [`bg-${t.bgVariant}`]: t.bgVariant !== null,
      [`border-${t.borderVariant}`]: t.borderVariant !== null
    }));
    return (l, o) => (g(), M(ne(l.tag), {
      class: H(a.value)
    }, {
      default: D(() => [
        l.html ? (g(), V("div", {
          key: 0,
          innerHTML: l.html
        }, null, 8, Oi)) : A(l.$slots, "default", { key: 1 }, () => [
          de(ee(l.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), fn = /* @__PURE__ */ z({
  __name: "BCardHeader",
  props: {
    text: { default: void 0 },
    bgVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (a, l) => (g(), M(cn, ae({ class: "card-header" }, t), {
      default: D(() => [
        A(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), vn = /* @__PURE__ */ z({
  __name: "BCardTitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h4" }
  },
  setup(e) {
    return (t, a) => (g(), M(ne(t.tag), { class: "card-title" }, {
      default: D(() => [
        A(t.$slots, "default", {}, () => [
          de(ee(t.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), pn = /* @__PURE__ */ z({
  __name: "BCardSubtitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h6" },
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, a = i(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== null
    }));
    return (l, o) => (g(), M(ne(l.tag), {
      class: H(["card-subtitle mb-2", a.value])
    }, {
      default: D(() => [
        A(l.$slots, "default", {}, () => [
          de(ee(l.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), mn = /* @__PURE__ */ z({
  __name: "BCardBody",
  props: {
    bodyBgVariant: { default: null },
    bodyTag: { default: "div" },
    bodyTextVariant: { default: null },
    overlay: { type: [String, Boolean], default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h4" },
    subtitleTextVariant: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    text: { default: void 0 }
  },
  setup(e) {
    const t = e, a = Le(), l = c(u(t, "overlay")), o = i(() => !Ie(a.title)), n = i(() => !Ie(a.subtitle)), r = i(() => ({
      "card-img-overlay": l.value,
      [`text-${t.bodyTextVariant}`]: t.bodyTextVariant !== null,
      [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant !== null
    }));
    return (s, d) => (g(), M(ne(s.bodyTag), {
      class: H(["card-body", r.value])
    }, {
      default: D(() => [
        s.title || o.value ? (g(), M(vn, {
          key: 0,
          tag: s.titleTag
        }, {
          default: D(() => [
            A(s.$slots, "title", {}, () => [
              de(ee(s.title), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag"])) : Q("", !0),
        s.subtitle || n.value ? (g(), M(pn, {
          key: 1,
          tag: s.subtitleTag,
          "text-variant": s.subtitleTextVariant
        }, {
          default: D(() => [
            A(s.$slots, "subtitle", {}, () => [
              de(ee(s.subtitle), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag", "text-variant"])) : Q("", !0),
        A(s.$slots, "default", {}, () => [
          de(ee(s.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), gn = /* @__PURE__ */ z({
  __name: "BCardFooter",
  props: {
    text: { default: void 0 },
    bgVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (a, l) => (g(), M(cn, ae({ class: "card-footer" }, t), {
      default: D(() => [
        A(a.$slots, "default", {}, () => [
          de(ee(a.text), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), bn = /* @__PURE__ */ z({
  __name: "BCard",
  props: {
    align: { default: void 0 },
    bgVariant: { default: null },
    bodyBgVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTag: { default: "div" },
    bodyTextVariant: { default: void 0 },
    borderVariant: { default: null },
    footer: { default: void 0 },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: { default: void 0 },
    header: { default: void 0 },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerTextVariant: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBottom: { type: [String, Boolean], default: !1 },
    imgEnd: { type: [String, Boolean], default: !1 },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgStart: { type: [String, Boolean], default: !1 },
    imgTop: { type: [String, Boolean], default: !1 },
    imgWidth: { default: void 0 },
    noBody: { type: [String, Boolean], default: !1 },
    overlay: { type: [String, Boolean], default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h6" },
    subtitleTextVariant: { default: "muted" },
    tag: { default: "div" },
    textVariant: { default: null },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    bodyText: { default: "" }
  },
  setup(e) {
    const t = e, a = Le(), l = c(u(t, "imgBottom")), o = c(u(t, "imgEnd")), n = c(u(t, "imgStart")), r = c(u(t, "noBody")), s = i(() => !Ie(a.header)), d = i(() => !Ie(a.footer)), f = i(() => ({
      [`text-${t.align}`]: t.align !== void 0,
      [`text-${t.textVariant}`]: t.textVariant !== null,
      [`bg-${t.bgVariant}`]: t.bgVariant !== null,
      [`border-${t.borderVariant}`]: t.borderVariant !== null,
      "flex-row": n.value,
      "flex-row-reverse": o.value
    })), p = i(() => ({
      bgVariant: t.headerBgVariant,
      borderVariant: t.headerBorderVariant,
      html: t.headerHtml,
      tag: t.headerTag,
      textVariant: t.headerTextVariant
    })), m = i(() => ({
      overlay: t.overlay,
      bodyBgVariant: t.bodyBgVariant,
      bodyTag: t.bodyTag,
      bodyTextVariant: t.bodyTextVariant,
      subtitle: t.subtitle,
      subtitleTag: t.subtitleTag,
      subtitleTextVariant: t.subtitleTextVariant,
      title: t.title,
      titleTag: t.titleTag
    })), v = i(() => ({
      bgVariant: t.footerBgVariant,
      borderVariant: t.footerBorderVariant,
      html: t.footerHtml,
      tag: t.footerTag,
      textVariant: t.footerTextVariant
    })), b = i(() => ({
      src: t.imgSrc,
      alt: t.imgAlt,
      height: t.imgHeight,
      width: t.imgWidth,
      bottom: t.imgBottom,
      end: t.imgEnd,
      start: t.imgStart,
      top: t.imgTop
    }));
    return (B, w) => (g(), M(ne(B.tag), {
      class: H(["card", f.value])
    }, {
      default: D(() => [
        T(l) ? Q("", !0) : A(B.$slots, "img", { key: 0 }, () => [
          B.imgSrc ? (g(), M(sa, _e(ae({ key: 0 }, b.value)), null, 16)) : Q("", !0)
        ]),
        B.header || s.value || B.headerHtml ? (g(), M(fn, ae({ key: 1 }, p.value, { class: B.headerClass }), {
          default: D(() => [
            A(B.$slots, "header", {}, () => [
              de(ee(B.header), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : Q("", !0),
        T(r) ? A(B.$slots, "default", { key: 3 }, () => [
          de(ee(B.bodyText), 1)
        ]) : (g(), M(mn, ae({ key: 2 }, m.value, { class: B.bodyClass }), {
          default: D(() => [
            A(B.$slots, "default", {}, () => [
              de(ee(B.bodyText), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])),
        B.footer || d.value || B.footerHtml ? (g(), M(gn, ae({ key: 4 }, v.value, { class: B.footerClass }), {
          default: D(() => [
            A(B.$slots, "footer", {}, () => [
              de(ee(B.footer), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : Q("", !0),
        T(l) ? A(B.$slots, "img", { key: 5 }, () => [
          B.imgSrc ? (g(), M(sa, _e(ae({ key: 0 }, b.value)), null, 16)) : Q("", !0)
        ]) : Q("", !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ei = /* @__PURE__ */ z({
  __name: "BCardGroup",
  props: {
    columns: { type: [String, Boolean], default: !1 },
    deck: { type: [String, Boolean], default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = c(u(t, "columns")), l = c(u(t, "deck")), o = i(
      () => l.value ? "card-deck" : a.value ? "card-columns" : "card-group"
    ), n = i(() => [o.value]);
    return (r, s) => (g(), M(ne(r.tag), {
      class: H(n.value)
    }, {
      default: D(() => [
        A(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ii = /* @__PURE__ */ z({
  __name: "BCardText",
  props: {
    text: { default: void 0 },
    tag: { default: "p" }
  },
  setup(e) {
    return (t, a) => (g(), M(ne(t.tag), { class: "card-text" }, {
      default: D(() => [
        A(t.$slots, "default", {}, () => [
          de(ee(t.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), Fi = ["id", "onMouseenter", "onMouseleave"], Li = {
  key: 0,
  class: "carousel-indicators"
}, xi = ["aria-current", "aria-label", "onClick"], Ni = /* @__PURE__ */ Z("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1), zi = { class: "visually-hidden" }, Ri = /* @__PURE__ */ Z("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1), Hi = { class: "visually-hidden" }, Mi = /* @__PURE__ */ z({
  __name: "BCarousel",
  props: {
    ride: { type: [Boolean, String], default: !1 },
    noHoverPause: { type: [String, Boolean], default: !1 },
    rideReverse: { type: [String, Boolean], default: !1 },
    fade: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    background: { default: void 0 },
    modelValue: { default: 0 },
    controls: { type: [String, Boolean], default: !1 },
    indicators: { type: [String, Boolean], default: !1 },
    interval: { default: 5e3 },
    noTouch: { type: [String, Boolean], default: !1 },
    noWrap: { type: [String, Boolean], default: !1 },
    controlsPrevText: { default: "Previous" },
    controlsNextText: { default: "Next" },
    indicatorsButtonLabel: { default: "Slide" },
    keyboard: { type: [String, Boolean], default: !0 },
    touchThreshold: { default: 50 }
  },
  emits: ["slid", "slide", "update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = Le(), n = Ae(u(l, "id"), "carousel"), r = Ve(l, "modelValue", a, { passive: !0 }), s = c(u(l, "keyboard")), d = c(u(l, "rideReverse")), f = c(u(l, "noHoverPause")), p = c(u(l, "fade")), m = c(u(l, "controls")), v = c(u(l, "indicators")), b = c(u(l, "noTouch")), B = c(u(l, "noWrap")), w = ht(u(l, "touchThreshold"), {
      nanToZero: !0,
      method: "parseInt"
    }), $ = x(!1), h = x(!1), S = x(!0), y = x(null), C = x(null), O = x(r.value), k = i(
      () => Qn(l.ride) ? ro(l.ride) : l.ride
    ), I = i(
      () => `carousel-item carousel-item-${S.value ? "prev" : "next"} carousel-item-${S.value ? "end" : "start"}`
    ), F = i(
      () => `carousel-item active carousel-item-${S.value ? "start" : "end"}`
    ), { pause: L, resume: _ } = Wo(
      () => {
        d.value ? G() : te();
      },
      u(l, "interval"),
      { immediate: k.value === "carousel" }
    ), E = i(
      () => k.value === !0 && h.value === !0 || k.value === "carousel"
    ), N = i(() => Sa(o.default, "BCarouselSlide")), R = i(() => [
      "carousel",
      "slide",
      "pointer-event",
      { "carousel-fade": p.value }
    ]), oe = (Y) => {
      var ie;
      return new io(Y, {
        componentId: n.value,
        cancelable: !1,
        target: C.value,
        direction: S.value ? "right" : "left",
        from: O.value,
        to: r.value,
        relatedTarget: ((ie = y.value) == null ? void 0 : ie.children[r.value]) ?? null
      });
    }, U = (Y) => {
      if ($.value !== !0) {
        if (k.value === !0 && (h.value = !0), E.value === !0 && _(), S.value = !(Y < r.value), Y >= N.value.length) {
          if (B.value)
            return;
          r.value = 0;
          return;
        }
        if (Y < 0) {
          if (B.value)
            return;
          r.value = N.value.length - 1;
          return;
        }
        O.value = r.value, r.value = Y;
      }
    }, G = () => {
      U(r.value - 1);
    }, te = () => {
      U(r.value + 1);
    }, ve = (Y) => {
      s.value !== !1 && Y();
    }, ye = () => {
      f.value || L();
    }, Be = () => {
      E.value && _();
    }, { lengthX: ge } = jr(C, {
      passive: !0,
      onSwipeStart() {
        b.value !== !0 && L();
      },
      onSwipeEnd() {
        if (b.value === !0)
          return;
        const Y = () => {
          E.value !== !1 && _();
        };
        if (ge.value >= w.value) {
          te(), Y();
          return;
        }
        ge.value <= -w.value && (G(), Y());
      }
    }), be = () => {
      a("slide", oe("slide")), $.value = !0;
    }, W = () => {
      a("slid", oe("slid")), $.value = !1;
    };
    return ue(
      () => l.ride,
      () => h.value = !1
    ), t({ pause: L, resume: _, prev: G, next: te }), Je(yo, {
      background: ke(u(l, "background")),
      width: ke(u(l, "imgWidth")),
      height: ke(u(l, "imgHeight"))
    }), (Y, ie) => (g(), V("div", {
      id: T(n),
      ref_key: "target",
      ref: C,
      class: H(R.value),
      onKeydown: [
        ie[0] || (ie[0] = Et((j) => ve(G), ["left"])),
        ie[1] || (ie[1] = Et((j) => ve(te), ["right"]))
      ],
      onMouseenter: ct(ye, ["stop"]),
      onMouseleave: ct(Be, ["stop"])
    }, [
      T(v) ? (g(), V("div", Li, [
        (g(!0), V(pe, null, $e(N.value.length, (j, q) => (g(), V("button", {
          key: q,
          type: "button",
          "data-bs-target": "",
          class: H(q === T(r) ? "active" : ""),
          "aria-current": q === T(r) ? !0 : void 0,
          "aria-label": `${Y.indicatorsButtonLabel} ${q}`,
          onClick: (se) => U(q)
        }, null, 10, xi))), 128))
      ])) : Q("", !0),
      Z("div", {
        ref_key: "relatedTarget",
        ref: y,
        class: "carousel-inner"
      }, [
        Se(Un, {
          "enter-from-class": I.value,
          "enter-active-class": I.value,
          "enter-to-class": I.value,
          "leave-from-class": F.value,
          "leave-active-class": F.value,
          "leave-to-class": F.value,
          onBeforeLeave: be,
          onAfterLeave: W
        }, {
          default: D(() => [
            (g(!0), V(pe, null, $e(N.value, (j, q) => it((g(), M(ne(j), {
              key: q,
              class: H({ active: q === T(r) && $.value === !1 })
            }, null, 8, ["class"])), [
              [ia, q === T(r)]
            ])), 128))
          ]),
          _: 1
        }, 8, ["enter-from-class", "enter-active-class", "enter-to-class", "leave-from-class", "leave-active-class", "leave-to-class"])
      ], 512),
      T(m) ? (g(), V(pe, { key: 1 }, [
        Z("button", {
          class: "carousel-control-prev",
          type: "button",
          onClick: G
        }, [
          Ni,
          Z("span", zi, ee(Y.controlsPrevText), 1)
        ]),
        Z("button", {
          class: "carousel-control-next",
          type: "button",
          onClick: te
        }, [
          Ri,
          Z("span", Hi, ee(Y.controlsNextText), 1)
        ])
      ], 64)) : Q("", !0)
    ], 42, Fi));
  }
}), Di = ["innerHTML"], ji = { key: 1 }, qi = ["innerHTML"], Gi = { key: 1 }, Wi = /* @__PURE__ */ z({
  __name: "BCarouselSlide",
  props: {
    imgSrc: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    interval: { default: void 0 },
    background: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: { default: void 0 },
    id: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBlank: { type: [String, Boolean], default: !1 },
    imgBlankColor: { default: "transparent" },
    text: { default: void 0 },
    textHtml: { default: void 0 },
    textTag: { default: "p" }
  },
  setup(e) {
    const t = e, a = Le(), l = Ee(yo, null), o = i(() => t.text || t.textHtml || !Ie(a.text)), n = i(() => t.caption || t.captionHtml || !Ie(a.caption)), r = i(() => o.value || n.value || !Ie(a.default)), s = i(() => ({
      background: `${t.background || (l == null ? void 0 : l.background.value) || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), d = i(() => ({
      "d-none": t.contentVisibleUp !== void 0,
      [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp !== void 0
    }));
    return (f, p) => (g(), V("div", {
      class: "carousel-item",
      style: Ge(s.value)
    }, [
      A(f.$slots, "img", {}, () => {
        var m, v;
        return [
          Se(Za, {
            class: "d-block w-100",
            alt: f.imgAlt,
            src: f.imgSrc,
            width: f.imgWidth || ((m = T(l)) == null ? void 0 : m.width.value),
            height: f.imgHeight || ((v = T(l)) == null ? void 0 : v.height.value),
            blank: f.imgBlank,
            "blank-color": f.imgBlankColor
          }, null, 8, ["alt", "src", "width", "height", "blank", "blank-color"])
        ];
      }),
      r.value ? (g(), M(ne(f.contentTag), {
        key: 0,
        class: H(["carousel-caption", d.value])
      }, {
        default: D(() => [
          n.value ? (g(), M(ne(f.captionTag), { key: 0 }, {
            default: D(() => [
              A(f.$slots, "caption", {}, () => [
                f.captionHtml ? (g(), V("span", {
                  key: 0,
                  innerHTML: f.captionHtml
                }, null, 8, Di)) : (g(), V("span", ji, ee(f.caption), 1))
              ])
            ]),
            _: 3
          })) : Q("", !0),
          o.value ? (g(), M(ne(f.textTag), { key: 1 }, {
            default: D(() => [
              A(f.$slots, "text", {}, () => [
                f.textHtml ? (g(), V("span", {
                  key: 0,
                  innerHTML: f.textHtml
                }, null, 8, qi)) : (g(), V("span", Gi, ee(f.text), 1))
              ])
            ]),
            _: 3
          })) : Q("", !0),
          A(f.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : Q("", !0)
    ], 4));
  }
}), Fl = ua("", [], { type: [Boolean, String, Number], default: !1 }), Ll = ua("offset", [""], { type: [String, Number], default: null }), xl = ua("order", [""], { type: [String, Number], default: null }), Ui = z({
  name: "BCol",
  props: {
    col: { type: [Boolean, String], default: !1 },
    // Generic flexbox .col (xs)
    cols: { type: [String, Number], default: null },
    // .col-[1-12]|auto (xs)
    ...Fl,
    offset: { type: [String, Number], default: null },
    ...Ll,
    order: { type: [String, Number], default: null },
    ...xl,
    alignSelf: { type: String, default: null },
    tag: { type: String, default: "div" }
  },
  setup(e) {
    const t = [
      { content: Fl, propPrefix: "cols", classPrefix: "col" },
      { content: Ll, propPrefix: "offset" },
      { content: xl, propPrefix: "order" }
    ], a = c(u(e, "col")), l = i(
      () => t.flatMap((n) => bo(e, n.content, n.propPrefix, n.classPrefix))
    );
    return {
      computedClasses: i(() => [
        l.value,
        {
          col: a.value || !l.value.some((n) => /^col-/.test(n)) && !e.cols,
          [`col-${e.cols}`]: !!e.cols,
          [`offset-${e.offset}`]: !!e.offset,
          [`order-${e.order}`]: !!e.order,
          [`align-self-${e.alignSelf}`]: !!e.alignSelf
        }
      ])
    };
  }
});
function Ki(e, t, a, l, o, n) {
  return g(), M(ne(e.tag), {
    class: H(e.computedClasses)
  }, {
    default: D(() => [
      A(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const At = /* @__PURE__ */ Re(Ui, [["render", Ki]]), mt = {
  autoHide: !0,
  delay: 5e3,
  noCloseButton: !1,
  pos: "top-right",
  value: !0
};
class Nl {
  constructor(t) {
    Pe(this, "vm");
    Pe(this, "containerPositions");
    Kn(t) ? this.vm = t : this.vm = dt(t), this.containerPositions = i(() => {
      const a = /* @__PURE__ */ new Set([]);
      return this.vm.toasts.map((l) => {
        l.options.pos && a.add(l.options.pos);
      }), a;
    });
  }
  toasts(t) {
    return t ? i(
      () => this.vm.toasts.filter((a) => {
        if (a.options.pos === t && a.options.value)
          return a;
      })
    ) : i(() => this.vm.toasts);
  }
  remove(...t) {
    this.vm.toasts = this.vm.toasts.filter((a) => {
      if (a.options.id && !t.includes(a.options.id))
        return a;
    });
  }
  isRoot() {
    return this.vm.root ?? !1;
  }
  show(t, a = mt) {
    const l = { id: ot(), ...mt, ...a }, o = {
      options: dt(l),
      content: t
    };
    return this.vm.toasts.push(o), o;
  }
  info(t, a = mt) {
    return this.show(t, { variant: "info", ...a });
  }
  danger(t, a = mt) {
    return this.show(t, { variant: "danger", ...a });
  }
  warning(t, a = mt) {
    return this.show(t, { variant: "warning", ...a });
  }
  success(t, a = mt) {
    return this.show(t, { variant: "success", ...a });
  }
  hide() {
  }
}
class Xi {
  constructor() {
    Pe(this, "vms");
    Pe(this, "rootInstance");
    Pe(this, "useToast", hn);
    this.vms = {};
  }
  getOrCreateViewModel(t) {
    if (!t) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      const a = { root: !0, toasts: [], container: void 0, id: Symbol("toast") };
      return this.rootInstance = a.id, this.vms[a.id] = a, a;
    }
    if (t.root) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      this.rootInstance = t.id;
    }
    return this.vms[t.id] = t, t;
  }
  getVM(t) {
    if (!t && this.rootInstance)
      return this.vms[this.rootInstance];
    if (t)
      return this.vms[t];
  }
}
const Aa = Symbol("toast"), yn = Symbol("toastFetch"), Ji = {
  container: void 0,
  toasts: [],
  root: !1
};
function Yi() {
  return Ee(yn);
}
function hn(e, t = Aa) {
  const a = Ee(Yi());
  if (!e)
    return new Nl(a.getOrCreateViewModel());
  const l = { id: Symbol("toastInstance") }, o = { ...Ji, ...l, ...e }, n = a.getOrCreateViewModel(o);
  return new Nl(n);
}
const Zi = {
  install: (e, t = {}) => {
    var a, l;
    e.provide(yn, ((a = t == null ? void 0 : t.BToast) == null ? void 0 : a.injectkey) ?? Aa), e.provide(((l = t == null ? void 0 : t.BToast) == null ? void 0 : l.injectkey) ?? Aa, new Xi());
  }
}, Qi = "toast-title", zl = 1e3, Bn = z({
  components: { BLink: ze },
  props: {
    ...vt,
    delay: { type: Number, default: 5e3 },
    bodyClass: { type: String, default: void 0 },
    body: { type: [Object, String], default: void 0 },
    headerClass: { type: String, default: void 0 },
    headerTag: { type: String, default: "div" },
    animation: { type: [Boolean, String], default: !0 },
    id: { type: String, default: void 0 },
    // Switches role to 'status' and aria-live to 'polite'
    isStatus: { type: [Boolean, String], default: !1 },
    autoHide: { type: [Boolean, String], default: !0 },
    noCloseButton: { type: [Boolean, String], default: !1 },
    noFade: { type: [Boolean, String], default: !1 },
    noHoverPause: { type: [Boolean, String], default: !1 },
    solid: { type: [Boolean, String], default: !1 },
    // Render the toast in place, rather than in a portal-target
    static: { type: [Boolean, String], default: !1 },
    title: { type: String, default: void 0 },
    modelValue: { type: [Boolean, String], default: !1 },
    toastClass: { type: Array, default: void 0 },
    variant: { type: String, default: null }
  },
  emits: ["destroyed", "update:modelValue"],
  setup(e, { emit: t, slots: a }) {
    c(u(e, "animation"));
    const l = c(u(e, "isStatus")), o = c(u(e, "autoHide")), n = c(u(e, "noCloseButton")), r = c(u(e, "noFade")), s = c(u(e, "noHoverPause"));
    c(u(e, "solid")), c(u(e, "static"));
    const d = c(u(e, "modelValue")), f = x(!1), p = x(!1), m = x(!1), v = i(() => ({
      [`b-toast-${e.variant}`]: e.variant !== null,
      show: m.value || f.value
    }));
    let b, B, w;
    const $ = () => {
      typeof b > "u" || (clearTimeout(b), b = void 0);
    }, h = i(
      () => (
        // Minimum supported duration is 1 second
        Math.max(nt(e.delay, 0), zl)
      )
    ), S = () => {
      d.value && (B = w = 0, $(), p.value = !0, Mt(() => {
        m.value = !1;
      }));
    }, y = () => {
      $(), t("update:modelValue", !0), B = w = 0, p.value = !1, Te(() => {
        Mt(() => {
          m.value = !0;
        });
      });
    }, C = () => {
      if (!o.value || s.value || !b || w)
        return;
      const N = Date.now() - B;
      N > 0 && ($(), w = Math.max(h.value - N, zl));
    }, O = () => {
      (!o.value || s.value || !w) && (w = B = 0), k();
    };
    ue(d, (N) => {
      N ? y() : S();
    });
    const k = () => {
      $(), o.value && (b = setTimeout(S, w || h.value), B = Date.now(), w = 0);
    }, I = () => {
      f.value = !0, t("update:modelValue", !0);
    }, F = () => {
      f.value = !1, k();
    }, L = () => {
      f.value = !0;
    }, _ = () => {
      f.value = !1, w = B = 0, t("update:modelValue", !1);
    };
    Xn(() => {
      $(), o.value && t("destroyed", e.id);
    }), Xe(() => {
      Te(() => {
        d.value && Mt(() => {
          y();
        });
      });
    });
    const E = () => {
      Te(() => {
        Mt(() => {
          S();
        });
      });
    };
    return () => {
      const N = () => {
        const R = [], oe = De(Qi, { hide: S }, a);
        oe ? R.push(ce(oe)) : e.title && R.push(ce("strong", { class: "me-auto" }, e.title)), !n.value && R.length !== 0 && R.push(
          ce(Tt, {
            class: ["btn-close"],
            onClick: () => {
              S();
            }
          })
        );
        const U = [];
        if (R.length > 0 && U.push(
          ce(
            e.headerTag,
            {
              class: "toast-header"
            },
            { default: () => R }
          )
        ), De("default", { hide: S }, a) || e.body) {
          const G = ce(
            It(e) ? "b-link" : "div",
            {
              class: ["toast-body", e.bodyClass],
              onClick: It(e) ? { click: E } : {}
            },
            De("default", { hide: S }, a) || e.body
          );
          U.push(G);
        }
        return ce(
          "div",
          {
            class: ["toast", e.toastClass, v.value],
            tabindex: "0"
          },
          U
        );
      };
      return ce(
        "div",
        {
          class: ["b-toast"],
          id: e.id,
          role: p.value ? null : l.value ? "status" : "alert",
          "aria-live": p.value ? null : l.value ? "polite" : "assertive",
          "aria-atomic": p.value ? null : !0,
          onmouseenter: C,
          onmouseleave: O
        },
        [
          ce(
            Ct,
            {
              noFade: r.value,
              onAfterEnter: F,
              onBeforeEnter: I,
              onAfterLeave: _,
              onBeforeLeave: L
            },
            () => [m.value ? N() : ""]
          )
        ]
      );
    };
  }
}), Va = /* @__PURE__ */ z({
  __name: "BToaster",
  props: {
    position: { default: "top-right" },
    instance: { default: void 0 }
  },
  setup(e) {
    const t = e, a = {
      "top-left": "top-0 start-0",
      "top-center": "top-0 start-50 translate-middle-x",
      "top-right": "top-0 end-0",
      "middle-left": "top-50 start-0 translate-middle-y",
      "middle-center": "top-50 start-50 translate-middle",
      "middle-right": "top-50 end-0 translate-middle-y",
      "bottom-left": "bottom-0 start-0",
      "bottom-center": "bottom-0 start-50 translate-middle-x",
      "bottom-right": "bottom-0 end-0"
    }, l = i(() => a[t.position]), o = (n) => {
      var r;
      (r = t.instance) == null || r.remove(n);
    };
    return (n, r) => {
      var s;
      return g(), V("div", {
        class: H([[l.value], "b-toaster position-fixed p-3"]),
        style: { "z-index": "11" }
      }, [
        (g(!0), V(pe, null, $e((s = n.instance) == null ? void 0 : s.toasts(n.position).value, (d) => (g(), M(Bn, {
          id: d.options.id,
          key: d.options.id,
          modelValue: d.options.value,
          "onUpdate:modelValue": (f) => d.options.value = f,
          "auto-hide": d.options.autoHide,
          delay: d.options.delay,
          "no-close-button": d.options.noCloseButton,
          title: d.content.title,
          body: d.content.body,
          component: d.content.body,
          variant: d.options.variant,
          onDestroyed: o
        }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "auto-hide", "delay", "no-close-button", "title", "body", "component", "variant"]))), 128))
      ], 2);
    };
  }
}), eu = z({
  props: {
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    fluid: { type: [Boolean, String], default: !1 },
    toast: { type: Object, default: void 0 },
    position: { type: String, default: void 0 }
  },
  setup(e, { slots: t, expose: a }) {
    const l = x();
    let o;
    const n = i(() => ({
      container: !e.fluid,
      ["container-fluid"]: typeof e.fluid == "boolean" && e.fluid,
      [`container-${e.fluid}`]: typeof e.fluid == "string",
      [`gx-${e.gutterX}`]: e.gutterX !== null,
      [`gy-${e.gutterY}`]: e.gutterY !== null
    }));
    return Xe(() => {
      e.toast;
    }), e.toast && (o = hn({ container: l, root: e.toast.root }), a({
      // ...toastInstance?.useMethods,
    })), () => {
      var s;
      const r = [];
      return o == null || o.containerPositions.value.forEach((d) => {
        r.push(ce(Va, { key: d, instance: o, position: d }));
      }), ce("div", { class: [n.value, e.position], ref: l }, [
        ...r,
        (s = t.default) == null ? void 0 : s.call(t)
      ]);
    };
  },
  methods: {}
}), tu = { class: "visually-hidden" }, au = ["aria-labelledby", "role"], Sn = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BDropdown",
  props: {
    id: { default: void 0 },
    menuClass: { default: void 0 },
    size: { default: "md" },
    splitClass: { default: void 0 },
    splitVariant: { default: void 0 },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    block: { type: [String, Boolean], default: !1 },
    dark: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    isNav: { type: [String, Boolean], default: !1 },
    dropup: { type: [String, Boolean], default: !1 },
    dropend: { type: [String, Boolean], default: !1 },
    dropstart: { type: [String, Boolean], default: !1 },
    center: { type: [String, Boolean], default: !1 },
    end: { type: [String, Boolean], default: !1 },
    noFlip: { type: [String, Boolean], default: !1 },
    noShift: { type: [String, Boolean], default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    split: { type: [String, Boolean], default: !1 },
    splitButtonType: { default: "button" },
    splitHref: { default: void 0 },
    splitDisabled: { type: [String, Boolean], default: void 0 },
    noCaret: { type: [String, Boolean], default: !1 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" },
    modelValue: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    strategy: { default: "absolute" },
    floatingMiddleware: { default: void 0 },
    splitTo: { default: void 0 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "click", "toggle", "update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = Ae(u(l, "id"), "dropdown"), n = Ve(l, "modelValue", a, { passive: !0 }), r = c(n), s = c(u(l, "block")), d = c(u(l, "dark")), f = c(u(l, "dropup")), p = c(u(l, "dropend")), m = c(u(l, "isNav")), v = c(u(l, "dropstart")), b = c(u(l, "center")), B = c(u(l, "end")), w = c(u(l, "split")), $ = c(u(l, "noCaret")), h = c(u(l, "noFlip")), S = c(u(l, "noShift")), y = c(u(l, "lazy")), C = c(u(l, "splitDisabled")), O = i(
      () => typeof l.offset == "string" || typeof l.offset == "number" ? l.offset : NaN
    ), k = ht(O, { method: "parseInt", nanToZero: !0 }), I = x(null), F = x(null), L = x(null), _ = i(() => w.value ? F.value : L.value), E = i(
      () => Zr({
        top: f.value,
        start: v.value,
        end: p.value,
        alignCenter: b.value,
        alignEnd: B.value
      })
    ), N = i(() => {
      if (l.floatingMiddleware !== void 0)
        return l.floatingMiddleware;
      const q = typeof l.offset == "string" || typeof l.offset == "number" ? k.value : l.offset, se = [Oo(q)];
      return h.value === !1 && se.push(Po()), S.value === !1 && se.push(Eo()), se;
    }), { x: R, y: oe, strategy: U, update: G } = Do(_, I, {
      placement: E,
      middleware: N,
      strategy: l.strategy
    }), te = i(() => ({
      "d-grid": s.value,
      dropup: f.value,
      dropend: p.value,
      dropstart: v.value,
      "d-flex": s.value && w.value
    })), ve = i(() => [
      w.value ? l.splitClass : l.toggleClass,
      {
        "nav-link": m.value,
        "dropdown-toggle": !w.value,
        "dropdown-toggle-no-caret": $.value && !w.value,
        "w-100": w.value && s.value,
        show: w.value ? void 0 : r.value
      }
    ]), ye = i(() => [
      l.menuClass,
      {
        "dropdown-menu-dark": d.value
      }
    ]), Be = i(() => ({
      "aria-expanded": w.value ? void 0 : r.value,
      "aria-haspopup": w.value ? void 0 : "menu",
      href: w.value ? l.splitHref : void 0,
      to: w.value && l.splitTo ? l.splitTo : void 0
    })), ge = () => {
      a("toggle");
      const q = r.value, se = new Qe(q ? "hide" : "show");
      if (a(q ? "hide" : "show", se), se.defaultPrevented) {
        a(q ? "hide-prevented" : "show-prevented");
        return;
      }
      n.value = !q, a(q ? "hidden" : "shown");
    }, be = (q) => {
      w.value ? a("click", q) : ge();
    };
    Xo(
      I,
      () => {
        r.value && (l.autoClose === !0 || l.autoClose === "outside") && (n.value = !r.value);
      },
      { ignore: [F, L] }
    );
    const W = () => {
      r.value && (l.autoClose === !0 || l.autoClose === "inside") && (n.value = !r.value);
    }, Y = () => n.value = !1, ie = () => n.value = !0, j = () => n.value = !r.value;
    return ue(r, G), t({
      close: Y,
      open: ie,
      toggle: j
    }), Je(To, {
      id: o,
      open: ie,
      close: Y,
      toggle: j,
      visible: r,
      isNav: m
    }), (q, se) => (g(), V(pe, null, [
      Z("div", ae({
        class: [te.value, "btn-group"]
      }, q.$attrs), [
        Se($t, ae({
          id: T(o),
          ref_key: "splitButton",
          ref: L,
          variant: q.splitVariant || q.variant,
          size: q.size,
          class: ve.value,
          disabled: T(C) || q.disabled,
          type: q.splitButtonType
        }, Be.value, {
          onClick: be,
          onKeydown: se[0] || (se[0] = Et((he) => n.value = !T(r), ["esc"]))
        }), {
          default: D(() => [
            A(q.$slots, "button-content", {}, () => [
              de(ee(q.text), 1)
            ])
          ]),
          _: 3
        }, 16, ["id", "variant", "size", "class", "disabled", "type"]),
        T(w) ? (g(), M($t, {
          key: 0,
          ref_key: "button",
          ref: F,
          variant: q.variant,
          size: q.size,
          disabled: q.disabled,
          class: H([[q.toggleClass, T(r) ? "show" : void 0], "dropdown-toggle-split dropdown-toggle"]),
          "aria-expanded": T(r),
          "aria-haspopup": "menu",
          onClick: ge
        }, {
          default: D(() => [
            Z("span", tu, [
              A(q.$slots, "toggle-text", {}, () => [
                de(ee(q.toggleText), 1)
              ])
            ])
          ]),
          _: 3
        }, 8, ["variant", "size", "disabled", "class", "aria-expanded"])) : Q("", !0)
      ], 16),
      !T(y) || T(r) ? it((g(), V("ul", {
        key: 0,
        ref_key: "floating",
        ref: I,
        style: Ge({
          position: T(U) === "absolute" ? void 0 : "fixed",
          top: `${T(oe)}px`,
          left: `${T(R)}px`,
          width: "max-content"
        }),
        class: H(["dropdown-menu show", ye.value]),
        "aria-labelledby": T(o),
        role: q.role,
        onClick: W
      }, [
        A(q.$slots, "default")
      ], 14, au)), [
        [ia, T(y) || T(r)]
      ]) : Q("", !0)
    ], 64));
  }
}), lu = { role: "presentation" }, ou = /* @__PURE__ */ z({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(e) {
    return (t, a) => (g(), V("li", lu, [
      (g(), M(ne(t.tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
}), nu = {}, su = { role: "presentation" }, ru = { class: "px-4 py-3" };
function iu(e, t) {
  return g(), V("li", su, [
    Z("form", ru, [
      A(e.$slots, "default")
    ])
  ]);
}
const uu = /* @__PURE__ */ Re(nu, [["render", iu]]), du = { role: "presentation" }, cu = ["id", "aria-describedby"], fu = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BDropdownGroup",
  props: {
    id: { default: void 0 },
    ariaDescribedby: { default: void 0 },
    header: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "header" },
    headerVariant: { default: null }
  },
  setup(e) {
    const t = e, a = i(
      () => t.id ? `${t.id}_group_dd_header` : void 0
    ), l = i(
      () => t.headerTag === "header" ? void 0 : "heading"
    ), o = i(() => [
      t.headerClass,
      {
        [`text-${t.headerVariant}`]: t.headerVariant !== null
      }
    ]);
    return (n, r) => (g(), V("li", du, [
      (g(), M(ne(n.headerTag), {
        id: a.value,
        class: H(["dropdown-header", o.value]),
        role: l.value
      }, {
        default: D(() => [
          A(n.$slots, "header", {}, () => [
            de(ee(n.header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      Z("ul", ae({
        id: n.id,
        role: "group",
        class: "list-unstyled"
      }, n.$attrs, {
        "aria-describedby": n.ariaDescribedby || a.value
      }), [
        A(n.$slots, "default")
      ], 16, cu)
    ]));
  }
}), vu = {}, pu = { class: "dropdown-header" };
function mu(e, t) {
  return g(), V("li", null, [
    Z("h6", pu, [
      A(e.$slots, "default")
    ])
  ]);
}
const gu = /* @__PURE__ */ Re(vu, [["render", mu]]), bu = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BDropdownItem",
  props: {
    href: { default: void 0 },
    linkClass: { default: void 0 },
    active: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    rel: { default: void 0 },
    target: { default: "_self" },
    variant: { default: null }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(u(a, "active")), o = c(u(a, "disabled")), n = no(), r = i(() => [
      a.linkClass,
      {
        active: l.value,
        disabled: o.value,
        [`text-${a.variant}`]: a.variant !== null
      }
    ]), s = i(
      () => a.href ? "a" : n.to ? ze : "button"
    ), d = i(() => ({
      disabled: o.value,
      "aria-current": l.value ? !0 : null,
      href: s.value === "a" ? a.href : null,
      rel: a.rel,
      type: s.value === "button" ? "button" : null,
      target: a.target,
      ...n.to ? { activeClass: "active", ...n } : n
    })), f = Ee(qa, null), p = Ee(To, null), m = Ee(Ga, null), v = (b) => {
      var B, w;
      t("click", b), m !== null && ((B = f == null ? void 0 : f.close) == null || B.call(f)), (w = p == null ? void 0 : p.close) == null || w.call(p);
    };
    return (b, B) => (g(), V("li", {
      role: "presentation",
      class: H(b.$attrs.class)
    }, [
      (g(), M(ne(s.value), ae({
        class: ["dropdown-item", r.value]
      }, d.value, { onClick: v }), {
        default: D(() => [
          A(b.$slots, "default")
        ]),
        _: 3
      }, 16, ["class"]))
    ], 2));
  }
}), yu = ["disabled"], hu = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BDropdownItemButton",
  props: {
    buttonClass: { default: void 0 },
    active: { type: [String, Boolean], default: !1 },
    activeClass: { default: "active" },
    disabled: { type: [String, Boolean], default: !1 },
    variant: { default: null }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(u(a, "active")), o = c(u(a, "disabled")), n = i(() => [
      a.buttonClass,
      {
        [a.activeClass]: l.value,
        disabled: o.value,
        [`text-${a.variant}`]: a.variant !== null
      }
    ]), r = (s) => t("click", s);
    return (s, d) => (g(), V("li", {
      role: "presentation",
      class: H(s.$attrs.class)
    }, [
      Z("button", {
        role: "menu",
        type: "button",
        class: H(["dropdown-item", n.value]),
        disabled: T(o),
        onClick: r
      }, [
        A(s.$slots, "default")
      ], 10, yu)
    ], 2));
  }
}), Bu = { role: "presentation" }, Su = { class: "px-4 py-1 mb-0 text-muted" }, wu = /* @__PURE__ */ z({
  __name: "BDropdownText",
  props: {
    text: { default: "" }
  },
  setup(e) {
    return (t, a) => (g(), V("li", Bu, [
      Z("p", Su, [
        A(t.$slots, "default", {}, () => [
          de(ee(t.text), 1)
        ])
      ])
    ]));
  }
}), $u = ["id", "novalidate", "onSubmit"], wn = /* @__PURE__ */ z({
  __name: "BForm",
  props: {
    id: { default: void 0 },
    floating: { type: [String, Boolean], default: !1 },
    novalidate: { type: [String, Boolean], default: !1 },
    validated: { type: [String, Boolean], default: !1 }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const a = e, l = c(u(a, "floating")), o = c(u(a, "novalidate")), n = c(u(a, "validated")), r = i(() => ({
      "form-floating": l.value,
      "was-validated": n.value
    })), s = (d) => t("submit", d);
    return (d, f) => (g(), V("form", {
      id: d.id,
      novalidate: T(o),
      class: H(r.value),
      onSubmit: ct(s, ["prevent"])
    }, [
      A(d.$slots, "default")
    ], 42, $u));
  }
}), _u = { class: "form-floating" }, ku = ["for"], Cu = /* @__PURE__ */ z({
  __name: "BFormFloatingLabel",
  props: {
    labelFor: { default: void 0 },
    label: { default: void 0 },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, a) => (g(), V("div", _u, [
      A(t.$slots, "default", {}, () => [
        de(ee(t.text), 1)
      ]),
      Z("label", { for: t.labelFor }, [
        A(t.$slots, "label", {}, () => [
          de(ee(t.label), 1)
        ])
      ], 8, ku)
    ]));
  }
}), Pa = /* @__PURE__ */ z({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    text: { default: void 0 },
    role: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    tag: { default: "div" },
    tooltip: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, a = c(u(t, "forceShow")), l = c(u(t, "state")), o = c(u(t, "tooltip")), n = i(
      () => a.value === !0 || l.value === !1
    ), r = i(() => ({
      "d-block": n.value,
      "invalid-feedback": !o.value,
      "invalid-tooltip": o.value
    })), s = i(() => ({
      id: t.id,
      role: t.role,
      "aria-live": t.ariaLive,
      "aria-atomic": t.ariaLive ? !0 : void 0
    }));
    return (d, f) => (g(), M(ne(d.tag), ae({ class: r.value }, s.value), {
      default: D(() => [
        A(d.$slots, "default", {}, () => [
          de(ee(d.text), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Xt = /* @__PURE__ */ z({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(e) {
    return (t, a) => (g(), M(ne(t.tag), { class: "row d-flex flex-wrap" }, {
      default: D(() => [
        A(t.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Oa = /* @__PURE__ */ z({
  __name: "BFormText",
  props: {
    id: { default: void 0 },
    inline: { type: [String, Boolean], default: !1 },
    tag: { default: "small" },
    text: { default: void 0 },
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, a = c(u(t, "inline")), l = i(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== null,
      "form-text": !a.value
    }));
    return (o, n) => (g(), M(ne(o.tag), {
      id: o.id,
      class: H(l.value)
    }, {
      default: D(() => [
        A(o.$slots, "default", {}, () => [
          de(ee(o.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Ea = /* @__PURE__ */ z({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    role: { default: void 0 },
    text: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    tag: { default: "div" },
    tooltip: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, a = c(u(t, "forceShow")), l = c(u(t, "state")), o = c(u(t, "tooltip")), n = i(
      () => a.value === !0 || l.value === !0
    ), r = i(() => ({
      "d-block": n.value,
      "valid-feedback": !o.value,
      "valid-tooltip": o.value
    })), s = i(() => t.ariaLive ? !0 : void 0);
    return (d, f) => (g(), M(ne(d.tag), {
      id: d.id,
      role: d.role,
      "aria-live": d.ariaLive,
      "aria-atomic": s.value,
      class: H(r.value)
    }, {
      default: D(() => [
        A(d.$slots, "default", {}, () => [
          de(ee(d.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), Tu = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "indeterminate"], Au = ["for"], $n = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BFormCheckbox",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledBy: { default: void 0 },
    form: { default: void 0 },
    indeterminate: { type: [String, Boolean], default: void 0 },
    name: { default: void 0 },
    id: { default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    plain: { type: [String, Boolean], default: !1 },
    button: { type: [String, Boolean], default: !1 },
    buttonGroup: { type: [String, Boolean], default: !1 },
    switch: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    buttonVariant: { default: null },
    inline: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: void 0 },
    size: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    uncheckedValue: { type: [Array, Set, Boolean, String, Object, Number, null], default: !1 },
    value: { type: [Array, Set, Boolean, String, Object, Number, null], default: !0 },
    modelValue: { type: [Array, Set, Boolean, String, Object, Number, null], default: void 0 }
  },
  emits: ["update:modelValue", "input", "change"],
  setup(e, { emit: t }) {
    const a = e, l = Le(), o = Ve(a, "modelValue", t, { passive: !0 }), n = Ae(u(a, "id"), "form-check"), r = c(u(a, "indeterminate")), s = c(u(a, "autofocus")), d = c(u(a, "plain")), f = c(u(a, "button")), p = c(u(a, "buttonGroup")), m = c(u(a, "switch")), v = c(u(a, "disabled")), b = c(u(a, "inline")), B = c(u(a, "required")), w = c(u(a, "state")), $ = Ee(ko, null), h = x(null);
    je(h, {
      initialValue: s.value
    });
    const S = i(() => !Ie(l.default)), y = i({
      get: () => $ !== null ? $.modelValue.value.map((_) => JSON.stringify(_)).includes(JSON.stringify(a.value)) : JSON.stringify(o.value) === JSON.stringify(a.value),
      set: (_) => {
        const E = _ ? a.value : a.uncheckedValue;
        t("input", E), o.value = E, Te(() => {
          t("change", E);
        });
      }
    });
    ue(o, (_) => {
      if ($ !== null) {
        if (_ === !1) {
          $.remove(a.value);
          return;
        }
        $.set(a.value);
      }
    });
    const C = i(
      () => !!(a.name ?? ($ == null ? void 0 : $.name.value)) && (B.value || ($ == null ? void 0 : $.required.value))
    ), O = i(
      () => p.value || (($ == null ? void 0 : $.buttons.value) ?? !1)
    ), k = i(() => ({
      plain: d.value || (($ == null ? void 0 : $.plain.value) ?? !1),
      button: f.value || (($ == null ? void 0 : $.buttons.value) ?? !1),
      inline: b.value || (($ == null ? void 0 : $.inline.value) ?? !1),
      switch: m.value || (($ == null ? void 0 : $.switch.value) ?? !1),
      state: w.value || ($ == null ? void 0 : $.state.value),
      size: a.size !== void 0 ? a.size : ($ == null ? void 0 : $.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant !== null ? a.buttonVariant : ($ == null ? void 0 : $.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), I = Qo(k), F = en(k), L = tn(k);
    return (_, E) => (g(), M(Xa, {
      skip: O.value,
      class: H(T(I))
    }, {
      default: D(() => {
        var N, R, oe;
        return [
          it(Z("input", ae({ id: T(n) }, _.$attrs, {
            ref_key: "input",
            ref: h,
            "onUpdate:modelValue": E[0] || (E[0] = (U) => y.value = U),
            class: T(F),
            type: "checkbox",
            disabled: T(v) || ((N = T($)) == null ? void 0 : N.disabled.value),
            required: C.value ? !0 : void 0,
            name: _.name || ((R = T($)) == null ? void 0 : R.name.value),
            form: _.form || ((oe = T($)) == null ? void 0 : oe.form.value),
            "aria-label": _.ariaLabel,
            "aria-labelledby": _.ariaLabelledBy,
            "aria-required": C.value ? !0 : void 0,
            value: _.value,
            indeterminate: T(r)
          }), null, 16, Tu), [
            [Jn, y.value]
          ]),
          S.value || T(d) === !1 ? (g(), V("label", {
            key: 0,
            for: T(n),
            class: H(T(L))
          }, [
            A(_.$slots, "default")
          ], 10, Au)) : Q("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), Vu = ["id"], Pu = ["innerHTML"], Ou = ["textContent"], Eu = /* @__PURE__ */ z({
  __name: "BFormCheckboxGroup",
  props: {
    id: { default: void 0 },
    form: { default: void 0 },
    modelValue: { default: () => [] },
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    size: { default: "md" },
    stacked: { type: [String, Boolean], default: !1 },
    state: { type: [String, Boolean, null], default: null },
    switches: { type: [String, Boolean], default: !1 },
    textField: { default: "text" },
    validated: { type: [String, Boolean], default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e, l = Ve(a, "modelValue", t), o = Ae(u(a, "id"), "checkbox"), n = Ae(u(a, "name"), "checkbox"), r = c(u(a, "autofocus")), s = c(u(a, "buttons")), d = c(u(a, "disabled")), f = c(u(a, "plain")), p = c(u(a, "required")), m = c(u(a, "stacked")), v = c(u(a, "state")), b = c(u(a, "switches")), B = c(u(a, "validated")), w = x(null);
    je(w, {
      initialValue: r.value
    }), Je(ko, {
      set: (C) => {
        const O = [...l.value];
        O.push(C), t("input", O), l.value = O, Te(() => {
          t("change", O);
        });
      },
      remove: (C) => {
        const O = [...l.value];
        O.splice(l.value.indexOf(C), 1), t("input", O), l.value = O, Te(() => {
          t("change", O);
        });
      },
      modelValue: i(() => l.value),
      switch: b,
      buttonVariant: ke(u(a, "buttonVariant")),
      form: ke(u(a, "form")),
      name: n,
      state: v,
      plain: f,
      size: ke(u(a, "size")),
      inline: i(() => !m.value),
      required: p,
      buttons: s,
      disabled: d
    });
    const $ = i(
      () => a.options.map(
        (C, O) => typeof C == "string" || typeof C == "number" ? {
          props: {
            value: C,
            disabled: d.value
          },
          text: C.toString(),
          html: void 0,
          self: Symbol(`checkboxGroupOptionItem${O}`)
        } : {
          props: {
            value: C[a.valueField],
            disabled: C[a.disabledField],
            ...C.props ? C.props : {}
          },
          text: C[a.textField],
          html: C[a.htmlField],
          self: Symbol(`checkboxGroupOptionItem${O}`)
        }
      )
    ), h = i(() => ({
      required: p.value,
      ariaInvalid: a.ariaInvalid,
      state: v.value,
      validated: B.value,
      buttons: s.value,
      stacked: m.value,
      size: a.size
    })), S = an(h), y = ln(h);
    return (C, O) => (g(), V("div", ae(T(S), {
      id: T(o),
      ref_key: "element",
      ref: w,
      role: "group",
      class: [T(y), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      A(C.$slots, "first"),
      (g(!0), V(pe, null, $e($.value, (k) => (g(), M($n, ae({
        key: k.self
      }, k.props), {
        default: D(() => [
          k.html ? (g(), V("span", {
            key: 0,
            innerHTML: k.html
          }, null, 8, Pu)) : (g(), V("span", {
            key: 1,
            textContent: ee(k.text)
          }, null, 8, Ou))
        ]),
        _: 2
      }, 1040))), 128)),
      A(C.$slots, "default")
    ], 16, Vu));
  }
}), _n = ["input", "select", "textarea"], Iu = _n.map((e) => `${e}:not([disabled])`).join(), Fu = [..._n, "a", "button", "label"], Lu = "label", xu = "invalid-feedback", Nu = "valid-feedback", zu = "description", Ru = "default", Hu = z({
  components: { BCol: At, BFormInvalidFeedback: Pa, BFormRow: Xt, BFormText: Oa, BFormValidFeedback: Ea },
  props: {
    contentCols: { type: [Boolean, String, Number], default: void 0 },
    contentColsLg: { type: [Boolean, String, Number], default: void 0 },
    contentColsMd: { type: [Boolean, String, Number], default: void 0 },
    contentColsSm: { type: [Boolean, String, Number], default: void 0 },
    contentColsXl: { type: [Boolean, String, Number], default: void 0 },
    description: { type: [String], default: void 0 },
    disabled: { type: [Boolean, String], default: !1 },
    feedbackAriaLive: { type: String, default: "assertive" },
    id: { type: String, default: void 0 },
    invalidFeedback: { type: String, default: void 0 },
    label: { type: String, default: void 0 },
    labelAlign: { type: [Boolean, String, Number], default: void 0 },
    labelAlignLg: { type: [Boolean, String, Number], default: void 0 },
    labelAlignMd: { type: [Boolean, String, Number], default: void 0 },
    labelAlignSm: { type: [Boolean, String, Number], default: void 0 },
    labelAlignXl: { type: [Boolean, String, Number], default: void 0 },
    labelClass: { type: [Array, Object, String], default: void 0 },
    labelCols: { type: [Boolean, String, Number], default: void 0 },
    labelColsLg: { type: [Boolean, String, Number], default: void 0 },
    labelColsMd: { type: [Boolean, String, Number], default: void 0 },
    labelColsSm: { type: [Boolean, String, Number], default: void 0 },
    labelColsXl: { type: [Boolean, String, Number], default: void 0 },
    labelFor: { type: String, default: void 0 },
    labelSize: { type: String, default: void 0 },
    labelSrOnly: { type: [Boolean, String], default: !1 },
    state: { type: [Boolean, String], default: null },
    tooltip: { type: [Boolean, String], default: !1 },
    validFeedback: { type: String, default: void 0 },
    validated: { type: [Boolean, String], default: !1 },
    floating: { type: [Boolean, String], default: !1 }
  },
  setup(e, { attrs: t }) {
    const a = c(u(e, "disabled")), l = c(u(e, "labelSrOnly")), o = c(u(e, "state")), n = c(u(e, "tooltip")), r = c(u(e, "validated")), s = c(u(e, "floating")), d = null, f = ["xs", "sm", "md", "lg", "xl"], p = (k, I) => f.reduce((F, L) => {
      const _ = il(L === "xs" ? "" : L, `${I}Align`), E = k[_] || null;
      return E && (L === "xs" ? F.push(`text-${E}`) : F.push(`text-${L}-${E}`)), F;
    }, []), m = (k, I) => f.reduce((F, L) => {
      const _ = il(L === "xs" ? "" : L, `${I}Cols`);
      let E = k[_];
      return E = E === "" ? !0 : E || !1, typeof E != "boolean" && E !== "auto" && (E = Os(E, 0), E = E > 0 ? E : !1), E && (L === "xs" ? F[typeof E == "boolean" ? "col" : "cols"] = E : F[L || (typeof E == "boolean" ? "col" : "cols")] = E), F;
    }, {}), v = x(), b = (k, I = null) => {
      if (Ma && e.labelFor) {
        const F = mo(`#${cs(e.labelFor)}`, v);
        if (F) {
          const L = "aria-describedby", _ = (k || "").split(Ut), E = (I || "").split(Ut), N = (Da(F, L) || "").split(Ut).filter((R) => !E.includes(R)).concat(_).filter((R, oe, U) => U.indexOf(R) === oe).filter((R) => R).join(" ").trim();
          N ? Ts(F, L, N) : As(F, L);
        }
      }
    }, B = i(() => m(e, "content")), w = i(() => p(e, "label")), $ = i(() => m(e, "label")), h = i(
      () => (
        // Determine if the form group will be rendered horizontal
        // based on the existence of 'content-col' or 'label-col' props
        Object.keys(B.value).length > 0 || Object.keys($.value).length > 0
      )
    ), S = i(
      () => (
        // If not a boolean, ensure that value is null
        typeof o.value == "boolean" ? o.value : null
      )
    ), y = i(() => {
      const k = S.value;
      return k === !0 ? "is-valid" : k === !1 ? "is-invalid" : null;
    }), C = i(
      () => da(t.ariaInvalid, o.value)
    );
    return ue(
      () => d,
      (k, I) => {
        k !== I && b(k, I);
      }
    ), Xe(() => {
      Te(() => {
        b(d);
      });
    }), {
      disabledBoolean: a,
      labelSrOnlyBoolean: l,
      stateBoolean: o,
      tooltipBoolean: n,
      validatedBoolean: r,
      floatingBoolean: s,
      ariaDescribedby: d,
      computedAriaInvalid: C,
      contentColProps: B,
      isHorizontal: h,
      labelAlignClasses: w,
      labelColProps: $,
      onLegendClick: (k) => {
        if (e.labelFor)
          return;
        const { target: I } = k, F = I ? I.tagName : "";
        if (Fu.indexOf(F) !== -1)
          return;
        const L = ks(Iu, v).filter(_s);
        L.length === 1 && ws(L[0]);
      },
      stateClass: y
    };
  },
  render() {
    const e = this.$props, t = this.$slots, a = Ae(), l = !e.labelFor;
    let o = null;
    const n = De(Lu, {}, t) || e.label, r = n ? ot("_BV_label_") : null;
    if (n || this.isHorizontal) {
      const C = l ? "legend" : "label";
      if (this.labelSrOnlyBoolean)
        n && (o = ce(
          C,
          {
            class: "visually-hidden",
            id: r,
            for: e.labelFor || null
          },
          n
        )), this.isHorizontal ? o = ce(At, this.labelColProps, { default: () => o }) : o = ce("div", {}, [o]);
      else {
        const O = {
          onClick: l ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? C : null,
          id: r,
          for: e.labelFor || null,
          tabIndex: l ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": l,
              "col-form-label": this.isHorizontal || l,
              "pt-0": !this.isHorizontal && l,
              "d-block": !this.isHorizontal && !l,
              [`col-form-label-${e.labelSize}`]: !!e.labelSize
            },
            this.labelAlignClasses,
            e.labelClass
          ]
        };
        this.isHorizontal ? o = ce(At, O, { default: () => n }) : o = ce(C, O, n);
      }
    }
    let s = null;
    const d = De(xu, {}, t) || this.invalidFeedback, f = d ? ot("_BV_feedback_invalid_") : void 0;
    d && (s = ce(
      Pa,
      {
        ariaLive: e.feedbackAriaLive,
        id: f,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => d }
    ));
    let p = null;
    const m = De(Nu, {}, t) || this.validFeedback, v = m ? ot("_BV_feedback_valid_") : void 0;
    m && (p = ce(
      Ea,
      {
        ariaLive: e.feedbackAriaLive,
        id: v,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => m }
      // validFeedbackContent
    ));
    let b = null;
    const B = De(zu, {}, t) || this.description, w = B ? ot("_BV_description_") : void 0;
    B && (b = ce(
      Oa,
      {
        id: w
      },
      { default: () => B }
    ));
    const $ = this.ariaDescribedby = [
      w,
      this.stateBoolean === !1 ? f : null,
      this.stateBoolean === !0 ? v : null
    ].filter((C) => C).join(" ") || null, h = [
      De(Ru, { ariaDescribedby: $, descriptionId: w, id: a, labelId: r }, t) || "",
      s,
      p,
      b
    ];
    !this.isHorizontal && this.floatingBoolean && h.push(o);
    let S = ce(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && this.floatingBoolean
          }
        ]
      },
      h
    );
    this.isHorizontal && (S = ce(At, { ref: "content", ...this.contentColProps }, { default: () => h }));
    const y = {
      class: [
        this.stateClass,
        {
          "was-validated": this.validatedBoolean
        }
      ],
      id: Ae(u(e, "id")).value,
      disabled: l ? this.disabledBoolean : null,
      role: l ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      // Only apply `aria-labelledby` if we are a horizontal fieldset
      // as the legend is no longer a direct child of fieldset
      "aria-labelledby": l && this.isHorizontal ? r : null
    };
    return this.isHorizontal && !l ? ce(Xt, y, { default: () => [o, S] }) : ce(
      l ? "fieldset" : "div",
      y,
      this.isHorizontal && l ? [ce(Xt, null, { default: () => [o, S] })] : this.isHorizontal || !this.floatingBoolean ? [o, S] : [S]
    );
  }
}), Rl = [
  "text",
  "number",
  "email",
  "password",
  "search",
  "url",
  "tel",
  "date",
  "time",
  "range",
  "color",
  "datetime",
  "datetime-local",
  "month",
  "week"
], Mu = z({
  props: {
    ...on,
    // debounce: {type: [String, Number], default: 0}, TODO: not implemented yet
    max: { type: [String, Number], default: void 0 },
    min: { type: [String, Number], default: void 0 },
    // noWheel: {type: [Boolean, String] as PropType<Booleanish>, default: false}, TODO: not implemented yet
    step: { type: [String, Number], default: void 0 },
    type: {
      type: String,
      default: "text",
      validator: (e) => Rl.includes(e)
    }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { emit: t }) {
    const { input: a, computedId: l, computedAriaInvalid: o, onInput: n, onChange: r, onBlur: s, focus: d, blur: f } = nn(e, t), p = x(!1), m = i(() => {
      const B = e.type === "range", w = e.type === "color";
      return {
        "form-control-highlighted": p.value,
        "form-range": B,
        "form-control": w || !e.plaintext && !B,
        "form-control-color": w,
        "form-control-plaintext": e.plaintext && !B && !w,
        [`form-control-${e.size}`]: !!e.size,
        "is-valid": e.state === !0,
        "is-invalid": e.state === !1
      };
    }), v = i(
      () => Rl.includes(e.type) ? e.type : "text"
    );
    return {
      computedClasses: m,
      localType: v,
      input: a,
      computedId: l,
      computedAriaInvalid: o,
      onInput: n,
      onChange: r,
      onBlur: s,
      focus: d,
      blur: f,
      highlight: () => {
        p.value !== !0 && (p.value = !0, setTimeout(() => {
          p.value = !1;
        }, 2e3));
      }
    };
  }
}), Du = ["id", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"];
function ju(e, t, a, l, o, n) {
  return g(), V("input", {
    id: e.computedId,
    ref: "input",
    class: H(e.computedClasses),
    name: e.name || void 0,
    form: e.form || void 0,
    type: e.localType,
    disabled: e.disabled,
    placeholder: e.placeholder,
    required: e.required,
    autocomplete: e.autocomplete || void 0,
    readonly: e.readonly || e.plaintext,
    min: e.min,
    max: e.max,
    step: e.step,
    list: e.type !== "password" ? e.list : void 0,
    "aria-required": e.required ? !0 : void 0,
    "aria-invalid": e.computedAriaInvalid,
    onInput: t[0] || (t[0] = (r) => e.onInput(r)),
    onChange: t[1] || (t[1] = (r) => e.onChange(r)),
    onBlur: t[2] || (t[2] = (r) => e.onBlur(r))
  }, null, 42, Du);
}
const qu = /* @__PURE__ */ Re(Mu, [["render", ju]]), Gu = ["id", "checked", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"], Wu = ["for"], kn = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BFormRadio",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    form: { default: void 0 },
    id: { default: void 0 },
    name: { default: void 0 },
    size: { default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    modelValue: { type: [Boolean, String, Array, Object, Number, null], default: void 0 },
    plain: { type: [String, Boolean], default: !1 },
    button: { type: [String, Boolean], default: !1 },
    buttonGroup: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    buttonVariant: { default: null },
    inline: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    state: { type: [String, Boolean, null], default: null },
    value: { type: [String, Boolean, Object, Number], default: !0 }
  },
  emits: ["input", "change", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = Le(), o = Ve(a, "modelValue", t, { passive: !0 }), n = Ae(u(a, "id"), "form-check"), r = c(u(a, "autofocus")), s = c(u(a, "plain")), d = c(u(a, "button")), f = c(u(a, "buttonGroup")), p = c(u(a, "disabled")), m = c(u(a, "inline")), v = c(u(a, "required")), b = c(u(a, "state")), B = Ee(Co, null), w = x(null);
    je(w, {
      initialValue: r.value
    });
    const $ = i(() => !Ie(l.default)), h = i({
      get: () => B !== null ? JSON.stringify(B.modelValue.value) === JSON.stringify(a.value) : JSON.stringify(o.value) === JSON.stringify(a.value),
      set: (F) => {
        const L = F || F === 0 ? a.value : !1;
        t("input", L), o.value = L, Te(() => {
          t("change", L);
        });
      }
    });
    ue(
      () => B == null ? void 0 : B.modelValue.value,
      (F) => {
        JSON.stringify(F) === JSON.stringify(a.value) !== !0 && (h.value = !1);
      }
    ), ue(o, (F) => {
      B === null || F === !1 || B.set(a.value);
    });
    const S = i(
      () => !!(a.name ?? (B == null ? void 0 : B.name.value)) && (v.value || (B == null ? void 0 : B.required.value))
    ), y = i(
      () => f.value || ((B == null ? void 0 : B.buttons.value) ?? !1)
    ), C = i(() => ({
      plain: s.value || ((B == null ? void 0 : B.plain.value) ?? !1),
      button: d.value || ((B == null ? void 0 : B.buttons.value) ?? !1),
      inline: m.value || ((B == null ? void 0 : B.inline.value) ?? !1),
      state: b.value || (B == null ? void 0 : B.state.value),
      size: a.size !== void 0 ? a.size : (B == null ? void 0 : B.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant !== null ? a.buttonVariant : (B == null ? void 0 : B.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), O = Qo(C), k = en(C), I = tn(C);
    return (F, L) => (g(), M(Xa, {
      skip: y.value,
      class: H(T(O))
    }, {
      default: D(() => {
        var _, E, N;
        return [
          it(Z("input", ae({ id: T(n) }, F.$attrs, {
            ref_key: "input",
            ref: w,
            "onUpdate:modelValue": L[0] || (L[0] = (R) => h.value = R),
            checked: h.value,
            class: T(k),
            type: "radio",
            disabled: T(p) || ((_ = T(B)) == null ? void 0 : _.disabled.value),
            required: S.value ? !0 : void 0,
            name: F.name || ((E = T(B)) == null ? void 0 : E.name.value),
            form: F.form || ((N = T(B)) == null ? void 0 : N.form.value),
            "aria-label": F.ariaLabel,
            "aria-labelledby": F.ariaLabelledby,
            value: F.value,
            "aria-required": S.value ? !0 : void 0
          }), null, 16, Gu), [
            [Yn, h.value]
          ]),
          $.value || T(s) === !1 ? (g(), V("label", {
            key: 0,
            for: T(n),
            class: H(T(I))
          }, [
            A(F.$slots, "default")
          ], 10, Wu)) : Q("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), Uu = ["id"], Ku = ["innerHTML"], Xu = ["textContent"], Ju = /* @__PURE__ */ z({
  __name: "BFormRadioGroup",
  props: {
    size: { default: "md" },
    form: { default: void 0 },
    id: { default: void 0 },
    name: { default: void 0 },
    modelValue: { type: [String, Boolean, Array, Object, Number, null], default: null },
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    plain: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    stacked: { type: [String, Boolean], default: !1 },
    state: { type: [String, Boolean, null], default: null },
    textField: { default: "text" },
    validated: { type: [String, Boolean], default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e, l = Ve(a, "modelValue", t), o = Ae(u(a, "id"), "radio"), n = Ae(u(a, "name"), "checkbox"), r = c(u(a, "autofocus")), s = c(u(a, "buttons")), d = c(u(a, "disabled")), f = c(u(a, "plain")), p = c(u(a, "required")), m = c(u(a, "stacked")), v = c(u(a, "state")), b = c(u(a, "validated")), B = x(null);
    je(B, {
      initialValue: r.value
    }), Je(Co, {
      set: (y) => {
        t("input", y), l.value = y, Te(() => {
          t("change", y);
        });
      },
      modelValue: i(() => l.value),
      buttonVariant: ke(u(a, "buttonVariant")),
      form: ke(u(a, "form")),
      name: n,
      buttons: s,
      state: v,
      plain: f,
      size: ke(u(a, "size")),
      inline: i(() => !m.value),
      required: p,
      disabled: d
    });
    const w = i(
      () => a.options.map(
        (y, C) => typeof y == "string" || typeof y == "number" ? {
          props: {
            value: y,
            disabled: d.value
          },
          text: y.toString(),
          html: void 0,
          self: Symbol(`radioGroupOptionItem${C}`)
        } : {
          props: {
            value: y[a.valueField],
            disabled: y[a.disabledField],
            ...y.props ? y.props : {}
          },
          text: y[a.textField],
          html: y[a.htmlField],
          self: Symbol(`radioGroupOptionItem${C}`)
        }
      )
    ), $ = i(() => ({
      required: p.value,
      ariaInvalid: a.ariaInvalid,
      state: v.value,
      validated: b.value,
      buttons: s.value,
      stacked: m.value,
      size: a.size
    })), h = an($), S = ln($);
    return (y, C) => (g(), V("div", ae(T(h), {
      id: T(o),
      ref_key: "element",
      ref: B,
      role: "radiogroup",
      class: [T(S), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      A(y.$slots, "first"),
      (g(!0), V(pe, null, $e(w.value, (O) => (g(), M(kn, ae({
        key: O.self
      }, O.props), {
        default: D(() => [
          O.html ? (g(), V("span", {
            key: 0,
            innerHTML: O.html
          }, null, 8, Ku)) : (g(), V("span", {
            key: 1,
            textContent: ee(O.text)
          }, null, 8, Xu))
        ]),
        _: 2
      }, 1040))), 128)),
      A(y.$slots, "default")
    ], 16, Uu));
  }
}), Yu = ["value", "disabled"], Qa = /* @__PURE__ */ z({
  __name: "BFormSelectOption",
  props: {
    value: { default: void 0 },
    disabled: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const a = c(u(e, "disabled"));
    return (l, o) => (g(), V("option", {
      value: l.value,
      disabled: T(a)
    }, [
      A(l.$slots, "default")
    ], 8, Yu));
  }
}), Zu = ["label"], Cn = /* @__PURE__ */ z({
  __name: "BFormSelectOptionGroup",
  props: {
    label: { default: void 0 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(e) {
    const t = e, a = i(
      () => Ja(t.options, "BFormSelectOptionGroup", t)
    );
    return (l, o) => (g(), V("optgroup", { label: l.label }, [
      A(l.$slots, "first"),
      (g(!0), V(pe, null, $e(a.value, (n, r) => (g(), M(Qa, ae({
        key: r,
        value: n.value,
        disabled: n.disabled
      }, l.$attrs, {
        innerHTML: n.html || n.text
      }), null, 16, ["value", "disabled", "innerHTML"]))), 128)),
      A(l.$slots, "default")
    ], 8, Zu));
  }
}), Qu = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"], ed = /* @__PURE__ */ z({
  __name: "BFormSelect",
  props: {
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    labelField: { default: "label" },
    multiple: { type: [String, Boolean], default: !1 },
    name: { default: void 0 },
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    selectSize: { default: 0 },
    size: { default: "md" },
    state: { type: [String, Boolean, null], default: null },
    textField: { default: "text" },
    valueField: { default: "value" },
    modelValue: { default: "" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e, l = Ve(a, "modelValue", t), o = Ae(u(a, "id"), "input"), n = c(u(a, "autofocus")), r = c(u(a, "disabled")), s = c(u(a, "multiple")), d = c(u(a, "plain")), f = c(u(a, "required")), p = c(u(a, "state")), m = x();
    je(m, {
      initialValue: n.value
    });
    const v = i(() => ({
      "form-control": d.value,
      [`form-control-${a.size}`]: a.size !== "md" && d.value,
      "form-select": !d.value,
      [`form-select-${a.size}`]: a.size !== "md" && !d.value,
      "is-valid": p.value === !0,
      "is-invalid": p.value === !1
    })), b = i(
      () => a.selectSize || d.value ? a.selectSize : void 0
    ), B = i(
      () => da(a.ariaInvalid, p.value)
    ), w = i(() => Ja(a.options, "BFormSelect", a)), $ = i({
      get: () => l.value,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set: (h) => {
        t("input", h), l.value = h, Te(() => {
          t("change", h);
        });
      }
    });
    return (h, S) => it((g(), V("select", ae({
      id: T(o),
      ref_key: "input",
      ref: m
    }, h.$attrs, {
      "onUpdate:modelValue": S[0] || (S[0] = (y) => $.value = y),
      class: v.value,
      name: h.name,
      form: h.form || void 0,
      multiple: T(s) || void 0,
      size: b.value,
      disabled: T(r),
      required: T(f),
      "aria-required": T(f) ? !0 : void 0,
      "aria-invalid": B.value
    }), [
      A(h.$slots, "first"),
      (g(!0), V(pe, null, $e(w.value, (y, C) => (g(), V(pe, { key: C }, [
        Array.isArray(y.options) ? (g(), M(Cn, {
          key: 0,
          label: y.label,
          options: y.options
        }, null, 8, ["label", "options"])) : (g(), M(Qa, {
          key: 1,
          value: y.value,
          disabled: y.disabled,
          innerHTML: y.html || y.text
        }, null, 8, ["value", "disabled", "innerHTML"]))
      ], 64))), 128)),
      A(h.$slots, "default")
    ], 16, Qu)), [
      [Zn, $.value]
    ]);
  }
}), td = ["id"], Tn = /* @__PURE__ */ z({
  __name: "BFormTag",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    disabled: { type: [String, Boolean], default: !1 },
    noRemove: { type: [String, Boolean], default: !1 },
    pill: { type: [String, Boolean], default: !1 },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(e, { emit: t }) {
    const a = e, l = Le(), o = Ae(u(a, "id")), n = c(u(a, "disabled")), r = c(u(a, "noRemove")), s = c(u(a, "pill")), d = i(
      () => {
        var m;
        return ((((m = l.default) == null ? void 0 : m.call(l)[0].children) ?? "").toString() || a.title) ?? "";
      }
    ), f = i(() => `${o.value}taglabel__`), p = i(() => ({
      [`bg-${a.variant}`]: a.variant !== null,
      "text-dark": a.variant !== null && ["warning", "info", "light"].includes(a.variant),
      "rounded-pill": s.value,
      disabled: n.value
    }));
    return (m, v) => (g(), M(ne(m.tag), {
      id: T(o),
      title: d.value,
      class: H(["badge b-form-tag d-inline-flex align-items-center mw-100", p.value]),
      "aria-labelledby": f.value
    }, {
      default: D(() => [
        Z("span", {
          id: f.value,
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          A(m.$slots, "default", {}, () => [
            de(ee(d.value), 1)
          ])
        ], 8, td),
        !T(n) && !T(r) ? (g(), M(Tt, {
          key: 0,
          "aria-keyshortcuts": "Delete",
          "aria-label": m.removeLabel,
          class: "b-form-tag-remove",
          white: m.variant !== null && !["warning", "info", "light"].includes(m.variant),
          "aria-describedby": f.value,
          "aria-controls": m.id,
          onClick: v[0] || (v[0] = (b) => t("remove", d.value))
        }, null, 8, ["aria-label", "white", "aria-describedby", "aria-controls"])) : Q("", !0)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
}), ad = ["id"], ld = ["id", "for", "aria-live"], od = ["id", "aria-live"], nd = ["id"], sd = ["aria-controls"], rd = {
  role: "group",
  class: "d-flex"
}, id = ["id", "disabled", "value", "type", "placeholder", "form", "required"], ud = ["disabled"], dd = {
  "aria-live": "polite",
  "aria-atomic": "true"
}, cd = {
  key: 0,
  class: "d-block invalid-feedback"
}, fd = {
  key: 1,
  class: "form-text text-muted"
}, vd = {
  key: 2,
  class: "form-text text-muted"
}, pd = ["name", "value"], md = /* @__PURE__ */ z({
  __name: "BFormTags",
  props: {
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { type: [String, Boolean], default: !1 },
    autofocus: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    duplicateTagText: { default: "Duplicate tag(s)" },
    inputAttrs: { default: void 0 },
    inputClass: { default: void 0 },
    inputId: { default: void 0 },
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    form: { default: void 0 },
    limit: { default: void 0 },
    limitTagsText: { default: "Tag limit reached" },
    modelValue: { default: () => [] },
    name: { default: void 0 },
    noAddOnEnter: { type: [String, Boolean], default: !1 },
    noOuterFocus: { type: [String, Boolean], default: !1 },
    noTagRemove: { type: [String, Boolean], default: !1 },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    separator: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    size: { default: "md" },
    tagClass: { default: void 0 },
    tagPills: { type: [String, Boolean], default: !1 },
    tagRemoveLabel: { default: void 0 },
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => !0 },
    tagVariant: { default: "secondary" }
  },
  emits: ["update:modelValue", "input", "tag-state", "focus", "focusin", "focusout", "blur"],
  setup(e, { emit: t }) {
    const a = e, l = Ve(a, "modelValue", t), o = Ae(), n = c(u(a, "addOnChange")), r = c(u(a, "autofocus")), s = c(u(a, "disabled")), d = c(u(a, "noAddOnEnter")), f = c(u(a, "noOuterFocus")), p = c(u(a, "noTagRemove")), m = c(u(a, "removeOnDelete")), v = c(u(a, "required")), b = c(u(a, "state")), B = c(u(a, "tagPills")), w = x(null), { focused: $ } = je(w, {
      initialValue: r.value
    }), h = i(() => a.inputId || `${o.value}input__`), S = x(l.value), y = x(""), C = x(l.value.length > 0), O = x(!1), k = x(""), I = x([]), F = x([]), L = x([]), _ = i(() => ({
      [`form-control-${a.size}`]: a.size !== "md",
      disabled: s.value,
      focus: O.value,
      "is-invalid": b.value === !1,
      "is-valid": b.value === !0
    })), E = i(() => S.value.includes(y.value)), N = i(
      () => y.value === "" ? !1 : !a.tagValidator(y.value)
    ), R = i(() => S.value.length === a.limit), oe = i(() => !N.value && !E.value), U = i(() => ({
      addButtonText: a.addButtonText,
      addButtonVariant: a.addButtonVariant,
      addTag: Y,
      disableAddButton: oe.value,
      disabled: s.value,
      duplicateTagText: a.duplicateTagText,
      duplicateTags: L.value,
      form: a.form,
      inputAttrs: {
        ...a.inputAttrs,
        disabled: s.value,
        form: a.form,
        id: h,
        value: y
      },
      inputHandlers: {
        input: ye,
        keydown: ge,
        change: Be
      },
      inputId: h,
      inputType: a.inputType,
      invalidTagText: a.invalidTagText,
      invalidTags: F.value,
      isDuplicate: E.value,
      isInvalid: N.value,
      isLimitReached: R.value,
      limitTagsText: a.limitTagsText,
      limit: a.limit,
      noTagRemove: p.value,
      placeholder: a.placeholder,
      removeTag: ie,
      required: v.value,
      separator: a.separator,
      size: a.size,
      state: b.value,
      tagClass: a.tagClass,
      tagPills: B.value,
      tagRemoveLabel: a.tagRemoveLabel,
      tagVariant: a.tagVariant,
      tags: S.value
    }));
    ue(l, (j) => {
      S.value = j;
    });
    const G = (j) => {
      if (s.value) {
        j.target.blur();
        return;
      }
      t("focusin", j);
    }, te = (j) => {
      s.value || f.value || (O.value = !0, t("focus", j));
    }, ve = (j) => {
      O.value = !1, t("blur", j);
    }, ye = (j) => {
      var se, he;
      const q = typeof j == "string" ? j : j.target.value;
      if (C.value = !1, (se = a.separator) != null && se.includes(q.charAt(0)) && q.length > 0) {
        w.value && (w.value.value = "");
        return;
      }
      if (y.value = q, (he = a.separator) != null && he.includes(q.charAt(q.length - 1))) {
        Y(q.slice(0, q.length - 1));
        return;
      }
      I.value = a.tagValidator(q) && !E.value ? [q] : [], F.value = a.tagValidator(q) ? [] : [q], L.value = E.value ? [q] : [], t("tag-state", I.value, F.value, L.value);
    }, Be = (j) => {
      n.value && (ye(j), E.value || Y(y.value));
    }, ge = (j) => {
      if (j.key === "Enter" && !d.value) {
        Y(y.value);
        return;
      }
      (j.key === "Backspace" || j.key === "Delete") && m.value && y.value === "" && C.value && S.value.length > 0 ? ie(S.value[S.value.length - 1]) : C.value = !0;
    }, be = i(() => {
      if (a.separator)
        return typeof a.separator == "string" ? a.separator : a.separator.join("");
    }), W = i(() => {
      if (be.value)
        return new RegExp(`[${ds(be.value)}]+`);
    }), Y = (j) => {
      j = (j ?? y.value).trim();
      const q = W.value ? j.split(W.value).map((we) => we.trim()) : [j], se = [];
      for (const we of q)
        if (!(we === "" || E.value || !a.tagValidator(we))) {
          if (a.limit && R.value)
            break;
          se.push(we);
        }
      const he = [...l.value, ...se];
      y.value = "", C.value = !0, l.value = he, t("input", he), $.value = !0;
    }, ie = (j) => {
      const q = S.value.indexOf((j == null ? void 0 : j.toString()) ?? "");
      k.value = S.value.splice(q, 1).toString(), l.value = S.value;
    };
    return (j, q) => (g(), V("div", {
      id: T(o),
      class: H(["b-form-tags form-control h-auto", _.value]),
      role: "group",
      tabindex: "-1",
      onFocusin: G,
      onFocusout: q[1] || (q[1] = (se) => t("focusout", se))
    }, [
      Z("output", {
        id: `${T(o)}selected_tags__`,
        class: "visually-hidden",
        for: h.value,
        "aria-live": O.value ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, ee(S.value.join(", ")), 9, ld),
      Z("div", {
        id: `${T(o)}removed_tags__`,
        role: "status",
        "aria-live": O.value ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + ee(j.tagRemovedLabel) + ") " + ee(k.value), 9, od),
      A(j.$slots, "default", _e(Oe(U.value)), () => [
        Z("ul", {
          id: `${T(o)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (g(!0), V(pe, null, $e(S.value, (se, he) => A(j.$slots, "tag", _e(ae({ key: he }, { tag: se, tagClass: j.tagClass, tagVariant: j.tagVariant, tagPills: T(B), removeTag: ie })), () => [
            (g(), M(Tn, {
              key: se,
              class: H(j.tagClass),
              tag: "li",
              variant: j.tagVariant,
              pill: j.tagPills,
              onRemove: ie
            }, {
              default: D(() => [
                de(ee(se), 1)
              ]),
              _: 2
            }, 1032, ["class", "variant", "pill"]))
          ])), 128)),
          Z("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${T(o)}tag_list__`
          }, [
            Z("div", rd, [
              Z("input", ae({
                id: h.value,
                ref_key: "input",
                ref: w,
                disabled: T(s),
                value: y.value,
                type: j.inputType,
                placeholder: j.placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, j.inputAttrs, {
                form: j.form,
                required: T(v),
                onInput: ye,
                onChange: Be,
                onKeydown: ge,
                onFocus: te,
                onBlur: ve
              }), null, 16, id),
              oe.value ? (g(), V("button", {
                key: 0,
                type: "button",
                class: H(["btn b-form-tags-button py-0", [
                  j.inputClass,
                  {
                    [`btn-${j.addButtonVariant}`]: j.addButtonVariant !== null,
                    "disabled invisible": y.value.length === 0
                  }
                ]]),
                style: { "font-size": "90%" },
                disabled: T(s) || y.value.length === 0 || R.value,
                onClick: q[0] || (q[0] = (se) => Y(y.value))
              }, [
                A(j.$slots, "add-button-text", {}, () => [
                  de(ee(j.addButtonText), 1)
                ])
              ], 10, ud)) : Q("", !0)
            ])
          ], 8, sd)
        ], 8, nd),
        Z("div", dd, [
          N.value ? (g(), V("div", cd, ee(j.invalidTagText) + ": " + ee(y.value), 1)) : Q("", !0),
          E.value ? (g(), V("small", fd, ee(j.duplicateTagText) + ": " + ee(y.value), 1)) : Q("", !0),
          S.value.length === j.limit ? (g(), V("small", vd, "Tag limit reached")) : Q("", !0)
        ])
      ]),
      j.name ? (g(!0), V(pe, { key: 0 }, $e(S.value, (se, he) => (g(), V("input", {
        key: he,
        type: "hidden",
        name: j.name,
        value: se
      }, null, 8, pd))), 128)) : Q("", !0)
    ], 42, ad));
  }
}), gd = z({
  props: {
    ...on,
    noResize: { type: [Boolean, String], default: !1 },
    rows: { type: [String, Number], required: !1, default: 2 },
    wrap: { type: String, default: "soft" }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { emit: t }) {
    const { input: a, computedId: l, computedAriaInvalid: o, onInput: n, onChange: r, onBlur: s, focus: d, blur: f } = nn(e, t), p = c(u(e, "noResize")), m = i(() => ({
      "form-control": !e.plaintext,
      "form-control-plaintext": e.plaintext,
      [`form-control-${e.size}`]: !!e.size,
      "is-valid": e.state === !0,
      "is-invalid": e.state === !1
    })), v = i(() => ({
      resize: p.value ? "none" : void 0
    }));
    return {
      input: a,
      computedId: l,
      computedAriaInvalid: o,
      onInput: n,
      onChange: r,
      onBlur: s,
      focus: d,
      blur: f,
      computedClasses: m,
      computedStyles: v
    };
  }
}), bd = ["id", "name", "form", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"];
function yd(e, t, a, l, o, n) {
  return g(), V("textarea", {
    id: e.computedId,
    ref: "input",
    class: H(e.computedClasses),
    name: e.name || void 0,
    form: e.form || void 0,
    disabled: e.disabled,
    placeholder: e.placeholder,
    required: e.required,
    autocomplete: e.autocomplete || void 0,
    readonly: e.readonly || e.plaintext,
    "aria-required": e.required ? !0 : void 0,
    "aria-invalid": e.computedAriaInvalid,
    rows: e.rows,
    style: Ge(e.computedStyles),
    wrap: e.wrap || void 0,
    onInput: t[0] || (t[0] = (r) => e.onInput(r)),
    onChange: t[1] || (t[1] = (r) => e.onChange(r)),
    onBlur: t[2] || (t[2] = (r) => e.onBlur(r))
  }, null, 46, bd);
}
const hd = /* @__PURE__ */ Re(gd, [["render", yd]]), Bd = {
  key: 0,
  class: "input-group-text"
}, Sd = ["innerHTML"], wd = { key: 1 }, $d = {
  key: 0,
  class: "input-group-text"
}, _d = ["innerHTML"], kd = { key: 1 }, Cd = /* @__PURE__ */ z({
  __name: "BInputGroup",
  props: {
    append: { default: void 0 },
    appendHtml: { default: void 0 },
    id: { default: void 0 },
    prepend: { default: void 0 },
    prependHtml: { default: void 0 },
    size: { default: "md" },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = i(() => ({
      [`input-group-${t.size}`]: t.size !== "md"
    })), l = i(() => !!t.append || !!t.appendHtml), o = i(() => !!t.prepend || !!t.prependHtml);
    return (n, r) => (g(), M(ne(n.tag), {
      id: n.id,
      class: H(["input-group", a.value]),
      role: "group"
    }, {
      default: D(() => [
        A(n.$slots, "prepend", {}, () => [
          o.value ? (g(), V("span", Bd, [
            n.prependHtml ? (g(), V("span", {
              key: 0,
              innerHTML: n.prependHtml
            }, null, 8, Sd)) : (g(), V("span", wd, ee(n.prepend), 1))
          ])) : Q("", !0)
        ]),
        A(n.$slots, "default"),
        A(n.$slots, "append", {}, () => [
          l.value ? (g(), V("span", $d, [
            n.appendHtml ? (g(), V("span", {
              key: 0,
              innerHTML: n.appendHtml
            }, null, 8, _d)) : (g(), V("span", kd, ee(n.append), 1))
          ])) : Q("", !0)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), An = /* @__PURE__ */ z({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, a) => (g(), M(ne(t.tag), { class: "input-group-text" }, {
      default: D(() => [
        A(t.$slots, "default", {}, () => [
          de(ee(t.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), el = /* @__PURE__ */ z({
  __name: "BInputGroupAddon",
  props: {
    isText: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const a = c(u(e, "isText"));
    return (l, o) => T(a) ? (g(), M(An, { key: 0 }, {
      default: D(() => [
        A(l.$slots, "default")
      ]),
      _: 3
    })) : A(l.$slots, "default", { key: 1 });
  }
}), Td = /* @__PURE__ */ z({
  __name: "BInputGroupAppend",
  props: {
    isText: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    return (t, a) => (g(), M(el, { "is-text": t.isText }, {
      default: D(() => [
        A(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["is-text"]));
  }
}), Ad = /* @__PURE__ */ z({
  __name: "BInputGroupPrepend",
  props: {
    isText: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    return (t, a) => (g(), M(el, { "is-text": t.isText }, {
      default: D(() => [
        A(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["is-text"]));
  }
}), Vd = /* @__PURE__ */ z({
  __name: "BListGroup",
  props: {
    flush: { type: [String, Boolean], default: !1 },
    horizontal: { type: [Boolean, String], default: !1 },
    numbered: { type: [String, Boolean], default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = c(u(t, "flush")), l = c(u(t, "numbered")), o = i(() => {
      const r = a.value ? !1 : t.horizontal;
      return {
        "list-group-flush": a.value,
        "list-group-horizontal": r === !0,
        [`list-group-horizontal-${r}`]: typeof r == "string",
        "list-group-numbered": l.value
      };
    }), n = i(() => l.value === !0 ? "ol" : t.tag);
    return Je(wo, {
      numbered: l
    }), (r, s) => (g(), M(ne(n.value), {
      class: H(["list-group", o.value])
    }, {
      default: D(() => [
        A(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Pd = /* @__PURE__ */ z({
  __name: "BListGroupItem",
  props: {
    action: { type: [String, Boolean], default: !1 },
    active: { type: [String, Boolean], default: !1 },
    button: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    href: { default: void 0 },
    tag: { default: "div" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, a = no(), l = Ee(wo, null), o = c(u(t, "action")), n = c(u(t, "active")), r = c(u(t, "button")), s = c(u(t, "disabled")), d = i(() => !r.value && (!!t.href || !!t.to)), f = i(
      () => l != null && l.numbered.value ? "li" : r.value ? "button" : d.value ? ze : t.tag
    ), p = i(
      () => o.value || d.value || r.value || ["a", "router-link", "button", "b-link"].includes(t.tag)
    ), m = i(() => ({
      [`list-group-item-${t.variant}`]: t.variant !== null,
      "list-group-item-action": p.value,
      active: n.value,
      disabled: s.value
    })), v = i(() => {
      const b = {};
      return r.value && ((!a || !a.type) && (b.type = "button"), s.value && (b.disabled = !0)), b;
    });
    return (b, B) => (g(), M(ne(f.value), ae({
      class: ["list-group-item", m.value],
      "aria-current": T(n) ? !0 : void 0,
      "aria-disabled": T(s) ? !0 : void 0,
      target: d.value ? b.target : void 0,
      href: T(r) ? void 0 : b.href,
      to: T(r) ? void 0 : b.to
    }, v.value), {
      default: D(() => [
        A(b.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
}), Od = ["id", "aria-labelledby", "aria-describedby"], Ed = ["id"], Id = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BModal",
  props: {
    bodyBgVariant: { default: null },
    bodyClass: { default: void 0 },
    bodyTextVariant: { default: null },
    busy: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    buttonSize: { default: "md" },
    cancelDisabled: { type: [String, Boolean], default: !1 },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { type: [String, Boolean], default: !1 },
    contentClass: { default: void 0 },
    dialogClass: { default: void 0 },
    footerBgVariant: { default: null },
    footerBorderVariant: { default: null },
    footerClass: { default: void 0 },
    footerTextVariant: { default: null },
    fullscreen: { type: [Boolean, String], default: !1 },
    headerBgVariant: { default: null },
    headerBorderVariant: { default: null },
    headerClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseWhite: { type: [String, Boolean], default: !1 },
    headerTextVariant: { default: null },
    hideBackdrop: { type: [String, Boolean], default: !1 },
    hideFooter: { type: [String, Boolean], default: !1 },
    hideHeader: { type: [String, Boolean], default: !1 },
    hideHeaderClose: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    modalClass: { default: void 0 },
    modelValue: { type: [String, Boolean], default: !1 },
    noCloseOnBackdrop: { type: [String, Boolean], default: !1 },
    noCloseOnEsc: { type: [String, Boolean], default: !1 },
    noFade: { type: [String, Boolean], default: !1 },
    autoFocus: { type: [String, Boolean], default: !0 },
    okDisabled: { type: [String, Boolean], default: !1 },
    okOnly: { type: [String, Boolean], default: !1 },
    okTitle: { default: "Ok" },
    okVariant: { default: "primary" },
    scrollable: { type: [String, Boolean], default: !1 },
    show: { type: [String, Boolean], default: !1 },
    size: { default: "md" },
    title: { default: void 0 },
    titleClass: { default: void 0 },
    titleSrOnly: { type: [String, Boolean], default: !1 },
    titleTag: { default: "h5" },
    static: { type: [String, Boolean], default: !1 },
    autoFocusButton: { default: void 0 }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "ok", "cancel", "close"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = Le(), n = Ae(u(l, "id"), "modal"), r = Ve(l, "modelValue", a), s = c(u(l, "busy")), d = c(u(l, "lazy")), f = c(u(l, "cancelDisabled")), p = c(u(l, "centered")), m = c(u(l, "hideBackdrop")), v = c(u(l, "hideFooter")), b = c(u(l, "hideHeader")), B = c(u(l, "hideHeaderClose")), w = c(r), $ = c(u(l, "noCloseOnBackdrop")), h = c(u(l, "noCloseOnEsc")), S = c(u(l, "noFade")), y = c(u(l, "autoFocus")), C = c(u(l, "okDisabled")), O = c(u(l, "okOnly")), k = c(u(l, "scrollable")), I = c(u(l, "titleSrOnly")), F = c(u(l, "static")), L = x(null), _ = x(null), E = x(null), N = x(null), R = x(w.value), oe = x(!1), { focused: U } = je(L, {
      initialValue: w.value && l.autoFocusButton === void 0
    }), { focused: G } = je(_, {
      initialValue: w.value && l.autoFocusButton === "ok"
    }), { focused: te } = je(E, {
      initialValue: w.value && l.autoFocusButton === "cancel"
    }), { focused: ve } = je(N, {
      initialValue: w.value && l.autoFocusButton === "close"
    }), ye = i(() => [
      l.modalClass,
      {
        fade: !S.value,
        show: R.value
      }
    ]), Be = i(
      () => d.value === !1 || d.value === !0 && oe.value === !0 || d.value === !0 && w.value === !0
    ), ge = i(() => !Ie(o["header-close"])), be = i(() => [
      l.dialogClass,
      {
        "modal-fullscreen": l.fullscreen === !0,
        [`modal-fullscreen-${l.fullscreen}-down`]: typeof l.fullscreen == "string",
        [`modal-${l.size}`]: l.size !== "md",
        "modal-dialog-centered": p.value,
        "modal-dialog-scrollable": k.value
      }
    ]), W = i(() => [
      l.bodyClass,
      {
        [`bg-${l.bodyBgVariant}`]: l.bodyBgVariant !== null,
        [`text-${l.bodyTextVariant}`]: l.bodyTextVariant !== null
      }
    ]), Y = i(() => [
      l.headerClass,
      {
        [`bg-${l.headerBgVariant}`]: l.headerBgVariant !== null,
        [`border-${l.headerBorderVariant}`]: l.headerBorderVariant !== null,
        [`text-${l.headerTextVariant}`]: l.headerTextVariant !== null
      }
    ]), ie = i(() => [
      l.footerClass,
      {
        [`bg-${l.footerBgVariant}`]: l.footerBgVariant !== null,
        [`border-${l.footerBorderVariant}`]: l.footerBorderVariant !== null,
        [`text-${l.footerTextVariant}`]: l.footerTextVariant !== null
      }
    ]), j = i(() => [
      l.titleClass,
      {
        ["visually-hidden"]: I.value
      }
    ]), q = i(() => f.value || s.value), se = i(() => C.value || s.value), he = (le, re = {}) => new zt(le, {
      cancelable: !1,
      target: L.value || null,
      relatedTarget: null,
      trigger: null,
      ...re,
      componentId: n.value
    }), we = (le = "") => {
      const re = he("hide", { cancelable: le !== "", trigger: le });
      if (le === "ok" && a(le, re), le === "cancel" && a(le, re), le === "close" && a(le, re), a("hide", re), re.defaultPrevented || le === "backdrop" && $.value || le === "esc" && h.value) {
        a("hide-prevented");
        return;
      }
      r.value = !1;
    }, J = () => {
      const le = he("show", { cancelable: !0 });
      if (a("show", le), le.defaultPrevented) {
        r.value = !1, a("show-prevented");
        return;
      }
      r.value = !0;
    }, fe = () => {
      y.value !== !1 && (l.autoFocusButton === "ok" ? G.value = !0 : l.autoFocusButton === "close" ? ve.value = !0 : l.autoFocusButton === "cancel" ? te.value = !0 : U.value = !0);
    }, P = () => J(), K = () => {
      R.value = !0, fe(), a("shown", he("shown")), d.value === !0 && (oe.value = !0);
    }, me = () => R.value = !1, X = () => {
      a("hidden", he("hidden")), d.value === !0 && (oe.value = !1);
    };
    return Kr(R), Ce(L, "bv-toggle", () => {
      w.value ? we() : J();
    }), t({
      hide: we,
      show: J
    }), (le, re) => (g(), M(Na, {
      to: "body",
      disabled: T(F)
    }, [
      Se(Ct, {
        "no-fade": !0,
        "trans-props": { enterToClass: "show" },
        onBeforeEnter: P,
        onAfterEnter: K,
        onLeave: me,
        onAfterLeave: X
      }, {
        default: D(() => [
          it(Z("div", ae({
            id: T(n),
            ref_key: "element",
            ref: L,
            class: ["modal", ye.value],
            role: "dialog",
            "aria-labelledby": `${T(n)}-label`,
            "aria-describedby": `${T(n)}-body`,
            tabindex: "-1"
          }, le.$attrs, {
            onKeyup: re[5] || (re[5] = Et((tt) => we("esc"), ["esc"]))
          }), [
            Z("div", {
              class: H(["modal-dialog", be.value])
            }, [
              Be.value ? (g(), V("div", {
                key: 0,
                class: H(["modal-content", le.contentClass])
              }, [
                T(b) ? Q("", !0) : (g(), V("div", {
                  key: 0,
                  class: H(["modal-header", Y.value])
                }, [
                  A(le.$slots, "header", {}, () => [
                    (g(), M(ne(le.titleTag), {
                      id: `${T(n)}-label`,
                      class: H(["modal-title", j.value])
                    }, {
                      default: D(() => [
                        A(le.$slots, "title", {}, () => [
                          de(ee(le.title), 1)
                        ], !0)
                      ]),
                      _: 3
                    }, 8, ["id", "class"])),
                    T(B) ? Q("", !0) : (g(), V(pe, { key: 0 }, [
                      ge.value ? (g(), V("button", {
                        key: 0,
                        type: "button",
                        onClick: re[0] || (re[0] = (tt) => we("close"))
                      }, [
                        A(le.$slots, "header-close", {}, void 0, !0)
                      ])) : (g(), M(Tt, {
                        key: 1,
                        ref_key: "closeButton",
                        ref: N,
                        "aria-label": le.headerCloseLabel,
                        white: le.headerCloseWhite,
                        onClick: re[1] || (re[1] = (tt) => we("close"))
                      }, null, 8, ["aria-label", "white"]))
                    ], 64))
                  ], !0)
                ], 2)),
                Z("div", {
                  id: `${T(n)}-body`,
                  class: H(["modal-body", W.value])
                }, [
                  A(le.$slots, "default", {}, void 0, !0)
                ], 10, Ed),
                T(v) ? Q("", !0) : (g(), V("div", {
                  key: 1,
                  class: H(["modal-footer", ie.value])
                }, [
                  A(le.$slots, "footer", {}, () => [
                    A(le.$slots, "cancel", {}, () => [
                      T(O) ? Q("", !0) : (g(), M($t, {
                        key: 0,
                        ref_key: "cancelButton",
                        ref: E,
                        disabled: q.value,
                        size: le.buttonSize,
                        variant: le.cancelVariant,
                        onClick: re[2] || (re[2] = (tt) => we("cancel"))
                      }, {
                        default: D(() => [
                          de(ee(le.cancelTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"]))
                    ], !0),
                    A(le.$slots, "ok", {}, () => [
                      Se($t, {
                        ref_key: "okButton",
                        ref: _,
                        disabled: se.value,
                        size: le.buttonSize,
                        variant: le.okVariant,
                        onClick: re[3] || (re[3] = (tt) => we("ok"))
                      }, {
                        default: D(() => [
                          de(ee(le.okTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"])
                    ], !0)
                  ], !0)
                ], 2))
              ], 2)) : Q("", !0)
            ], 2),
            T(m) ? Q("", !0) : A(le.$slots, "backdrop", { key: 0 }, () => [
              Z("div", {
                class: "modal-backdrop fade show",
                onClick: re[4] || (re[4] = (tt) => we("backdrop"))
              })
            ], !0)
          ], 16, Od), [
            [ia, T(w)]
          ])
        ]),
        _: 3
      })
    ], 8, ["disabled"]));
  }
});
const Fd = /* @__PURE__ */ Re(Id, [["__scopeId", "data-v-fe44b380"]]), Ld = /* @__PURE__ */ z({
  __name: "BNav",
  props: {
    align: { default: void 0 },
    cardHeader: { type: [String, Boolean], default: !1 },
    fill: { type: [String, Boolean], default: !1 },
    justified: { type: [String, Boolean], default: !1 },
    pills: { type: [String, Boolean], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    tabs: { type: [String, Boolean], default: !1 },
    tag: { default: "ul" },
    vertical: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, a = c(u(t, "cardHeader")), l = c(u(t, "fill")), o = c(u(t, "justified")), n = c(u(t, "pills")), r = c(u(t, "small")), s = c(u(t, "tabs")), d = c(u(t, "vertical")), f = Ht(u(t, "align")), p = i(() => ({
      "nav-tabs": s.value,
      "nav-pills": n.value && !s.value,
      "card-header-tabs": !d.value && a.value && s.value,
      "card-header-pills": !d.value && a.value && n.value && !s.value,
      "flex-column": d.value,
      "nav-fill": !d.value && l.value,
      "nav-justified": !d.value && o.value,
      [f.value]: !d.value && t.align !== void 0,
      small: r.value
    }));
    return (m, v) => (g(), M(ne(m.tag), {
      class: H(["nav", p.value])
    }, {
      default: D(() => [
        A(m.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), xd = /* @__PURE__ */ z({
  __name: "BNavForm",
  props: {
    role: { default: void 0 },
    id: { default: void 0 },
    floating: { type: [String, Boolean], default: !1 },
    novalidate: { type: [String, Boolean], default: !1 },
    validated: { type: [String, Boolean], default: !1 }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const a = e, l = i(() => ({
      floating: a.floating,
      role: a.role,
      id: a.id,
      novalidate: a.novalidate,
      validated: a.validated
    })), o = (n) => t("submit", n);
    return (n, r) => (g(), M(wn, ae(l.value, {
      class: "d-flex",
      onSubmit: ct(o, ["prevent"])
    }), {
      default: D(() => [
        A(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["onSubmit"]));
  }
}), Nd = z({
  components: { BLink: ze },
  props: {
    ...Rt(vt, ["event", "routerTag"])
  },
  setup(e) {
    return { disabledBoolean: c(u(e, "disabled")) };
  }
}), zd = { class: "nav-item" };
function Rd(e, t, a, l, o, n) {
  const r = za("b-link");
  return g(), V("li", zd, [
    Se(r, ae({ class: "nav-link" }, e.$props, {
      "active-class": "active",
      tabindex: e.disabledBoolean ? -1 : void 0,
      "aria-disabled": e.disabledBoolean ? !0 : void 0
    }), {
      default: D(() => [
        A(e.$slots, "default")
      ]),
      _: 3
    }, 16, ["tabindex", "aria-disabled"])
  ]);
}
const Hd = /* @__PURE__ */ Re(Nd, [["render", Rd]]), Md = { class: "nav-item dropdown" }, Dd = /* @__PURE__ */ z({
  __name: "BNavItemDropdown",
  props: {
    id: { default: void 0 },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    size: { default: "md" },
    offset: { default: void 0 },
    autoClose: { type: [Boolean, String], default: void 0 },
    dark: { type: [String, Boolean], default: void 0 },
    splitVariant: { default: void 0 },
    noCaret: { type: [String, Boolean], default: void 0 },
    variant: { default: "link" },
    modelValue: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: void 0 },
    strategy: { default: void 0 },
    floatingMiddleware: { default: void 0 },
    noFlip: { type: [String, Boolean], default: void 0 },
    noShift: { type: [String, Boolean], default: void 0 },
    dropup: { type: [String, Boolean], default: void 0 },
    dropend: { type: [String, Boolean], default: void 0 },
    dropstart: { type: [String, Boolean], default: void 0 },
    center: { type: [String, Boolean], default: void 0 },
    end: { type: [String, Boolean], default: void 0 },
    menuClass: { default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = Ve(a, "modelValue", t), o = c(l), n = i({
      get: () => o.value,
      set: (s) => l.value = s
    }), r = i(() => Rt(a, ["modelValue"]));
    return (s, d) => (g(), V("li", Md, [
      Se(Sn, ae({
        modelValue: n.value,
        "onUpdate:modelValue": d[0] || (d[0] = (f) => n.value = f)
      }, r.value, { "is-nav": "" }), {
        "button-content": D(() => [
          A(s.$slots, "button-content")
        ]),
        "toggle-text": D(() => [
          A(s.$slots, "toggle-text")
        ]),
        default: D(() => [
          A(s.$slots, "default")
        ]),
        _: 3
      }, 16, ["modelValue"])
    ]));
  }
}), jd = { class: "navbar-text" }, qd = /* @__PURE__ */ z({
  __name: "BNavText",
  props: {
    text: { default: void 0 }
  },
  setup(e) {
    return (t, a) => (g(), V("li", jd, [
      A(t.$slots, "default", {}, () => [
        de(ee(t.text), 1)
      ])
    ]));
  }
}), Gd = /* @__PURE__ */ z({
  __name: "BNavbar",
  props: {
    fixed: { default: void 0 },
    print: { type: [String, Boolean], default: !1 },
    sticky: { default: void 0 },
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: !1 },
    dark: { type: [String, Boolean], default: !1 },
    variant: { default: null },
    container: { type: [String, Boolean], default: "fluid" }
  },
  setup(e) {
    const t = e, a = c(u(t, "print")), l = c(u(t, "dark")), o = i(
      () => t.tag === "nav" ? void 0 : "navigation"
    ), n = i(
      () => typeof t.toggleable == "string" ? `navbar-expand-${t.toggleable}` : t.toggleable === !1 ? "navbar-expand" : void 0
    ), r = i(
      () => t.container === !0 ? "container" : "container-fluid"
    ), s = i(() => ({
      "d-print": a.value,
      [`sticky-${t.sticky}`]: t.sticky !== void 0,
      "navbar-dark": l.value,
      [`bg-${t.variant}`]: t.variant !== null,
      [`fixed-${t.fixed}`]: t.fixed !== void 0,
      [`${n.value}`]: n.value !== void 0
    }));
    return Je(Ga, {
      tag: ke(u(t, "tag"))
    }), (d, f) => (g(), M(ne(d.tag), {
      class: H(["navbar", s.value]),
      role: o.value
    }, {
      default: D(() => [
        d.container !== !1 ? (g(), V("div", {
          key: 0,
          class: H(r.value)
        }, [
          A(d.$slots, "default")
        ], 2)) : A(d.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
}), Hl = Rt(vt, ["event", "routerTag"]), Wd = z({
  components: {
    BLink: ze
  },
  props: {
    ...Hl,
    tag: { type: String, default: "div" }
  },
  setup(e) {
    const t = i(() => It(e)), a = i(
      () => t.value ? ze : e.tag
    );
    return {
      computedLinkProps: i(
        () => t.value ? ja(e, Hl) : {}
      ),
      computedTag: a
    };
  }
});
function Ud(e, t, a, l, o, n) {
  return g(), M(ne(e.computedTag), ae({ class: "navbar-brand" }, e.computedLinkProps), {
    default: D(() => [
      A(e.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const Kd = /* @__PURE__ */ Re(Wd, [["render", Ud]]), Xd = /* @__PURE__ */ z({
  __name: "BNavbarNav",
  props: {
    align: { default: void 0 },
    fill: { type: [String, Boolean], default: !1 },
    justified: { type: [String, Boolean], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    tag: { default: "ul" }
  },
  setup(e) {
    const t = e, a = c(u(t, "fill")), l = c(u(t, "justified")), o = c(u(t, "small")), n = Ht(u(t, "align")), r = i(() => ({
      "nav-fill": a.value,
      "nav-justified": l.value,
      [n.value]: t.align !== void 0,
      small: o.value
    }));
    return (s, d) => (g(), V("ul", {
      class: H(["navbar-nav", r.value])
    }, [
      A(s.$slots, "default")
    ], 2));
  }
}), Ml = (e, t) => e.setAttribute("data-bs-theme", t), Jd = {
  mounted(e, t) {
    Ml(e, t.value);
  },
  updated(e, t) {
    Ml(e, t.value);
  }
}, tl = (e, t) => {
  const { modifiers: a, arg: l, value: o } = e, n = Object.keys(a || {}), r = typeof o == "string" ? o.split(Ut) : o;
  if (Vs(t.tagName, "a")) {
    const s = Da(t, "href") || "";
    os.test(s) && n.push(s.replace(ls, ""));
  }
  return Array.prototype.concat.apply([], [l, r]).forEach((s) => typeof s == "string" && n.push(s)), n.filter((s, d, f) => s && f.indexOf(s) === d);
}, Yd = (e, t) => {
  tl(e, t).forEach((l) => {
    const o = document.getElementById(l);
    o !== null && o.dispatchEvent(new Event("bv-toggle"));
  }), setTimeout(() => Vn(e, t), 50);
}, Vn = (e, t) => {
  const a = tl(e, t);
  let l = !1;
  a.forEach((o) => {
    const n = document.getElementById(o);
    n != null && n.classList.contains("show") && (l = !0), n != null && n.classList.contains("closing") && (l = !1);
  }), t.setAttribute("aria-expanded", l ? "true" : "false");
}, Ia = {
  mounted(e, t) {
    e.__toggle = () => Yd(t, e), e.addEventListener("click", e.__toggle), Vn(t, e), e.setAttribute("aria-controls", tl(t, e).join(" "));
  },
  unmounted(e) {
    e.removeEventListener("click", e.__toggle), e.removeAttribute("aria-controls"), e.removeAttribute("aria-expanded");
  }
}, Zd = {
  mounted(e, t) {
    const a = oa(t.value, e);
    e.$__state = x({
      ...na(t, e),
      ...a
    }), sn(e, t);
  },
  updated(e, t) {
    const a = oa(t.value, e);
    e.$__state && (e.$__state.value = {
      ...na(t, e),
      ...a
    });
  },
  beforeUnmount(e) {
    rn(e);
  }
}, Qd = {
  mounted(e, t) {
    const a = Ca(t.value), l = oa(t.value, e);
    e.$__state = x({
      ...na(t, e),
      title: l.title ?? l.content ?? "",
      tooltip: a
    }), sn(e, t);
  },
  updated(e, t) {
    const a = Ca(t.value), l = oa(t.value, e);
    e.$__state && (e.$__state.value = {
      ...na(t, e),
      title: l.title ?? l.content ?? "",
      tooltip: a
    });
  },
  beforeUnmount(e) {
    rn(e);
  }
}, ec = /* @__PURE__ */ Z("span", { class: "navbar-toggler-icon" }, null, -1), tc = /* @__PURE__ */ z({
  __name: "BNavbarToggle",
  props: {
    disabled: { type: [String, Boolean], default: !1 },
    label: { default: "Toggle navigation" },
    target: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(u(a, "disabled")), o = i(() => ({
      disabled: l.value,
      "aria-label": a.label
    })), n = i(() => ({
      disabled: l.value
    })), r = (s) => {
      l.value || t("click", s);
    };
    return (s, d) => it((g(), V("button", ae({
      class: ["navbar-toggler", n.value],
      type: "button"
    }, o.value, { onClick: r }), [
      A(s.$slots, "default", {}, () => [
        ec
      ])
    ], 16)), [
      [T(Ia), T(l) ? void 0 : s.target]
    ]);
  }
}), Pn = /* @__PURE__ */ z({
  __name: "BOverlay",
  props: {
    bgColor: { default: void 0 },
    blur: { default: "2px" },
    fixed: { type: [String, Boolean], default: !1 },
    noCenter: { type: [String, Boolean], default: !1 },
    noFade: { type: [String, Boolean], default: !1 },
    noWrap: { type: [String, Boolean], default: !1 },
    opacity: { default: 0.85 },
    overlayTag: { default: "div" },
    rounded: { type: [Boolean, String], default: !1 },
    show: { type: [String, Boolean], default: !1 },
    spinnerSmall: { type: [String, Boolean], default: !1 },
    spinnerType: { default: "border" },
    spinnerVariant: { default: void 0 },
    noSpinner: { type: [String, Boolean], default: !1 },
    variant: { default: "light" },
    wrapTag: { default: "div" },
    zIndex: { default: 10 }
  },
  emits: ["click", "hidden", "shown"],
  setup(e, { emit: t }) {
    const a = e, l = { top: 0, left: 0, bottom: 0, right: 0 }, o = c(u(a, "fixed")), n = c(u(a, "noSpinner")), r = c(u(a, "noCenter")), s = c(u(a, "noWrap")), d = c(u(a, "show")), f = c(u(a, "spinnerSmall")), p = i(
      () => a.rounded === !0 || a.rounded === "" ? "rounded" : a.rounded === !1 ? "" : `rounded-${a.rounded}`
    ), m = i(
      () => a.variant !== null && !a.bgColor ? `bg-${a.variant}` : ""
    ), v = i(() => d.value ? !0 : null), b = i(() => ({
      type: a.spinnerType,
      variant: a.spinnerVariant,
      small: f.value
    })), B = i(() => ({
      ...l,
      zIndex: a.zIndex || 10
    })), w = i(() => [
      "b-overlay",
      {
        "position-absolute": !s.value || !o.value,
        "position-fixed": s.value && o.value
      }
    ]), $ = i(() => [m.value, p.value]), h = i(() => ({
      ...l,
      opacity: a.opacity,
      backgroundColor: a.bgColor || void 0,
      backdropFilter: a.blur ? `blur(${a.blur})` : void 0
    })), S = i(
      () => r.value ? l : {
        top: "50%",
        left: "50%",
        transform: "translateX(-50%) translateY(-50%)"
      }
    );
    return (y, C) => (g(), M(ne(y.wrapTag), {
      class: "b-overlay-wrap position-relative",
      "aria-busy": v.value
    }, {
      default: D(() => [
        A(y.$slots, "default"),
        Se(Ct, {
          "no-fade": y.noFade,
          "trans-props": { enterToClass: "show" },
          name: "fade",
          onOnAfterEnter: C[1] || (C[1] = (O) => t("shown")),
          onOnAfterLeave: C[2] || (C[2] = (O) => t("hidden"))
        }, {
          default: D(() => [
            T(d) ? (g(), M(ne(y.overlayTag), {
              key: 0,
              class: H(w.value),
              style: Ge(B.value),
              onClick: C[0] || (C[0] = (O) => t("click", O))
            }, {
              default: D(() => [
                Z("div", {
                  class: H(["position-absolute", $.value]),
                  style: Ge(h.value)
                }, null, 6),
                Z("div", {
                  class: "position-absolute",
                  style: Ge(S.value)
                }, [
                  A(y.$slots, "overlay", _e(Oe(b.value)), () => [
                    T(n) ? Q("", !0) : (g(), M(va, _e(ae({ key: 0 }, b.value)), null, 16))
                  ])
                ], 4)
              ]),
              _: 3
            }, 8, ["class", "style"])) : Q("", !0)
          ]),
          _: 3
        }, 8, ["no-fade"])
      ]),
      _: 3
    }, 8, ["aria-busy"]));
  }
}), ac = {
  key: 0,
  class: "offcanvas-header"
}, lc = {
  id: "offcanvasLabel",
  class: "offcanvas-title"
}, oc = { class: "offcanvas-body" }, nc = { key: 1 }, sc = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BOffcanvas",
  props: {
    dismissLabel: { default: "Close" },
    modelValue: { type: [String, Boolean], default: !1 },
    bodyScrolling: { type: [String, Boolean], default: !1 },
    backdrop: { type: [String, Boolean], default: !0 },
    noCloseOnBackdrop: { type: [String, Boolean], default: !1 },
    noCloseOnEsc: { type: [String, Boolean], default: !1 },
    placement: { default: "start" },
    title: { default: void 0 },
    noHeaderClose: { type: [String, Boolean], default: !1 },
    noHeader: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    noFocus: { type: [String, Boolean], default: !1 },
    static: { type: [String, Boolean], default: !1 },
    backdropVariant: { default: "dark" }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "esc", "close"],
  setup(e, { emit: t }) {
    const a = e, l = Le(), o = Ve(a, "modelValue", t), n = c(o);
    c(u(a, "bodyScrolling"));
    const r = c(u(a, "backdrop")), s = c(u(a, "noHeaderClose")), d = c(u(a, "noHeader")), f = c(u(a, "noFocus")), p = c(u(a, "noCloseOnBackdrop")), m = c(u(a, "noCloseOnEsc")), v = c(u(a, "lazy")), b = c(u(a, "static")), B = Ae(u(a, "id"), "offcanvas"), w = x(null), { focused: $ } = je(w, {
      initialValue: n.value && f.value === !1
    }), h = x(n.value), S = x(!1), y = i(
      () => r.value === !0 && n.value === !0
    ), C = i(
      () => v.value === !1 || v.value === !0 && S.value === !0 || v.value === !0 && n.value === !0
    ), O = i(() => !Ie(l.footer)), k = i(() => [
      // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,
      "offcanvas",
      // Remove when above check is fixed
      `offcanvas-${a.placement}`,
      {
        show: n.value && h.value === !0
      }
    ]), I = (U, G = {}) => new zt(U, {
      cancelable: !1,
      target: w.value || null,
      relatedTarget: null,
      trigger: null,
      ...G,
      componentId: B.value
    }), F = (U = "") => {
      const G = I("hide", { cancelable: U !== "", trigger: U });
      if (U === "close" && t(U, G), U === "esc" && t(U, G), t("hide", G), G.defaultPrevented || U === "backdrop" && p.value || U === "esc" && m.value) {
        t("hide-prevented");
        return;
      }
      o.value = !1;
    }, L = () => {
      const U = I("show", { cancelable: !0 });
      if (t("show", U), U.defaultPrevented) {
        o.value = !1, t("show-prevented");
        return;
      }
      o.value = !0;
    }, _ = () => {
      Te(() => {
        f.value === !1 && ($.value = !0);
      });
    }, E = () => L(), N = () => {
      h.value = !0, _(), t("shown", I("shown")), v.value === !0 && (S.value = !0);
    }, R = () => h.value = !1, oe = () => {
      t("hidden", I("hidden")), v.value === !0 && (S.value = !1);
    };
    return Ce(w, "bv-toggle", () => {
      n.value ? F() : L();
    }), (U, G) => (g(), M(Na, {
      to: "body",
      disabled: T(b)
    }, [
      Se(Ct, {
        "no-fade": !0,
        "trans-props": {
          enterToClass: "showing",
          enterFromClass: "",
          leaveToClass: "hiding show",
          leaveFromClass: "show"
        },
        onBeforeEnter: E,
        onAfterEnter: N,
        onLeave: R,
        onAfterLeave: oe
      }, {
        default: D(() => [
          it(Z("div", ae({
            ref_key: "element",
            ref: w,
            "aria-modal": "true",
            role: "dialog",
            class: k.value,
            tabindex: "-1",
            "aria-labelledby": "offcanvasLabel",
            "data-bs-backdrop": "false"
          }, U.$attrs, {
            onKeyup: G[1] || (G[1] = Et((te) => F("esc"), ["esc"]))
          }), [
            C.value ? (g(), V(pe, { key: 0 }, [
              T(d) ? Q("", !0) : (g(), V("div", ac, [
                A(U.$slots, "header", _e(Oe({ visible: T(n), placement: U.placement, hide: F })), () => [
                  Z("h5", lc, [
                    A(U.$slots, "title", {}, () => [
                      de(ee(U.title), 1)
                    ])
                  ]),
                  T(s) ? Q("", !0) : (g(), M(Tt, {
                    key: 0,
                    class: "text-reset",
                    "aria-label": U.dismissLabel,
                    onClick: G[0] || (G[0] = (te) => F("close"))
                  }, null, 8, ["aria-label"]))
                ])
              ])),
              Z("div", oc, [
                A(U.$slots, "default")
              ]),
              O.value ? (g(), V("div", nc, [
                A(U.$slots, "footer", _e(Oe({ visible: T(n), placement: U.placement, hide: F })))
              ])) : Q("", !0)
            ], 64)) : Q("", !0)
          ], 16), [
            [ia, T(o)]
          ])
        ]),
        _: 3
      }),
      Se(Pn, {
        variant: U.backdropVariant,
        show: y.value,
        fixed: !0,
        "no-wrap": "",
        "no-spinner": !0,
        onClick: G[2] || (G[2] = (te) => F("backdrop"))
      }, null, 8, ["variant", "show"])
    ], 8, ["disabled"]));
  }
}), rc = 5, On = 20, En = 0, Ye = 3, ic = "ellipsis-text", uc = "first-text", dc = "last-text", cc = "next-text", fc = "page", vc = "prev-text", Dl = (e) => Math.max(nt(e) || On, 1), jl = (e) => Math.max(nt(e) || En, 0), pc = (e, t) => {
  const a = nt(e) || 1;
  return a > t ? t : a < 1 ? 1 : a;
}, mc = z({
  name: "BPagination",
  props: {
    align: { type: String, default: "start" },
    ariaControls: { type: String, default: void 0 },
    ariaLabel: { type: String, default: "Pagination" },
    disabled: { type: [Boolean, String], default: !1 },
    ellipsisClass: { type: [Array, String], default: () => [] },
    ellipsisText: { type: String, default: "â¦" },
    firstClass: { type: [Array, String], default: () => [] },
    firstNumber: { type: [Boolean, String], default: !1 },
    firstText: { type: String, default: "Â«" },
    hideEllipsis: { type: [Boolean, String], default: !1 },
    hideGotoEndButtons: { type: [Boolean, String], default: !1 },
    labelFirstPage: { type: String, default: "Go to first page" },
    labelLastPage: { type: String, default: "Go to last page" },
    labelNextPage: { type: String, default: "Go to next page" },
    labelPage: { type: String, default: "Go to page" },
    labelPrevPage: { type: String, default: "Go to previous page" },
    lastClass: { type: [Array, String], default: () => [] },
    lastNumber: { type: [Boolean, String], default: !1 },
    lastText: { type: String, default: "Â»" },
    limit: { type: Number, default: rc },
    modelValue: { type: Number, default: 1 },
    // V-model prop
    nextClass: { type: [Array, String], default: () => [] },
    nextText: { type: String, default: "âº" },
    pageClass: { type: [Array, String], default: () => [] },
    perPage: { type: Number, default: On },
    pills: { type: [Boolean, String], default: !1 },
    prevClass: { type: [Array, String], default: () => [] },
    prevText: { type: String, default: "â¹" },
    size: { type: String, default: "md" },
    totalRows: { type: Number, default: En }
  },
  emits: ["update:modelValue", "page-click"],
  setup(e, { emit: t, slots: a }) {
    const l = Ve(e, "modelValue", t), o = c(u(e, "disabled")), n = c(u(e, "firstNumber")), r = c(u(e, "hideEllipsis")), s = c(u(e, "hideGotoEndButtons")), d = c(u(e, "lastNumber")), f = c(u(e, "pills")), p = i(
      () => e.align === "fill" ? "start" : e.align
    ), m = Ht(u(p, "value")), v = i(
      () => Math.ceil(jl(e.totalRows) / Dl(e.perPage))
    ), b = i(() => {
      let k;
      return v.value - l.value + 2 < e.limit && e.limit > Ye ? k = v.value - w.value + 1 : k = l.value - Math.floor(w.value / 2), k < 1 ? k = 1 : k > v.value - w.value && (k = v.value - w.value + 1), e.limit <= Ye && d.value && v.value === k + w.value - 1 && (k = Math.max(k - 1, 1)), k;
    }), B = i(() => {
      const k = v.value - l.value;
      let I = !1;
      return k + 2 < e.limit && e.limit > Ye ? e.limit > Ye && (I = !0) : e.limit > Ye && (I = !!(!r.value || n.value)), b.value <= 1 && (I = !1), I && n.value && b.value < 4 && (I = !1), I;
    }), w = i(() => {
      let k = e.limit;
      return v.value <= e.limit ? k = v.value : l.value < e.limit - 1 && e.limit > Ye ? ((!r.value || d.value) && (k = e.limit - (n.value ? 0 : 1)), k = Math.min(k, e.limit)) : v.value - l.value + 2 < e.limit && e.limit > Ye ? (!r.value || n.value) && (k = e.limit - (d.value ? 0 : 1)) : e.limit > Ye && (k = e.limit - (r.value ? 0 : 2)), k;
    }), $ = i(() => {
      const k = v.value - w.value;
      let I = !1;
      l.value < e.limit - 1 && e.limit > Ye ? (!r.value || d.value) && (I = !0) : e.limit > Ye && (I = !!(!r.value || d.value)), b.value > k && (I = !1);
      const F = b.value + w.value - 1;
      return I && d.value && F > v.value - 3 && (I = !1), I;
    }), h = dt({
      pageSize: Dl(e.perPage),
      totalRows: jl(e.totalRows),
      numberOfPages: v.value
    }), S = (k, I) => {
      if (I === l.value)
        return;
      const { target: F } = k, L = new Qe("page-click", {
        cancelable: !0,
        target: F
      });
      t("page-click", L, I), !L.defaultPrevented && (l.value = I);
    }, y = i(() => e.size ? `pagination-${e.size}` : ""), C = i(() => f.value ? "b-pagination-pills" : "");
    ue(l, (k) => {
      const I = pc(k, v.value);
      I !== l.value && (l.value = I);
    }), ue(h, (k, I) => {
      k != null && (I.pageSize !== k.pageSize && I.totalRows === k.totalRows || I.numberOfPages !== k.numberOfPages && l.value > I.numberOfPages) && (l.value = 1);
    });
    const O = i(() => {
      const k = [];
      for (let I = 0; I < w.value; I++)
        k.push({ number: b.value + I, classes: null });
      return k;
    });
    return () => {
      const k = [], I = O.value.map((G) => G.number), F = (G) => G === l.value, L = l.value < 1, _ = e.align === "fill", E = (G, te, ve, ye, Be, ge) => {
        const be = o.value || F(ge) || L || G < 1 || G > v.value, W = G < 1 ? 1 : G > v.value ? v.value : G, Y = { disabled: be, page: W, index: W - 1 }, ie = De(ve, Y, a) || ye || "";
        return ce(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: be,
                "flex-fill": _,
                "d-flex": _ && !be
              },
              Be
            ]
          },
          // render inner content
          ce(
            be ? "span" : "button",
            {
              class: ["page-link", { "flex-grow-1": !be && _ }],
              "aria-label": te,
              "aria-controls": e.ariaControls || null,
              "aria-disabled": be ? !0 : null,
              role: "menuitem",
              type: be ? null : "button",
              tabindex: be ? null : "-1",
              onClick: (j) => {
                be || S(j, W);
              }
            },
            ie
          )
        );
      }, N = (G) => ce(
        "li",
        {
          class: [
            "page-item",
            "disabled",
            "bv-d-xs-down-none",
            _ ? "flex-fill" : "",
            e.ellipsisClass
          ],
          role: "separator",
          key: `ellipsis-${G ? "last" : "first"}`
        },
        [
          ce(
            "span",
            { class: ["page-link"] },
            De(ic, {}, a) || e.ellipsisText || "..."
          )
        ]
      ), R = (G, te) => {
        const ve = F(G.number) && !L, ye = o.value ? null : ve || L && te === 0 ? "0" : "-1", Be = {
          active: ve,
          disabled: o.value,
          page: G.number,
          index: G.number - 1,
          content: G.number
        }, ge = De(fc, Be, a) || G.number, be = ce(
          o.value ? "span" : "button",
          {
            class: ["page-link", { "flex-grow-1": !o.value && _ }],
            "aria-controls": e.ariaControls || null,
            "aria-disabled": o.value ? !0 : null,
            "aria-label": e.labelPage ? `${e.labelPage} ${G.number}` : null,
            role: "menuitemradio",
            type: o.value ? null : "button",
            tabindex: ye,
            onClick: (W) => {
              o.value || S(W, G.number);
            }
          },
          ge
        );
        return ce(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: o.value,
                active: ve,
                "flex-fill": _,
                "d-flex": _ && !o.value
              },
              e.pageClass
            ],
            role: "presentation",
            key: `page-${G.number}`
          },
          be
        );
      };
      if (!s.value && !n.value) {
        const G = E(
          1,
          e.labelFirstPage,
          uc,
          e.firstText,
          e.firstClass,
          1
        );
        k.push(G);
      }
      const oe = E(
        l.value - 1,
        e.labelFirstPage,
        vc,
        e.prevText,
        e.prevClass,
        1
      );
      k.push(oe), n.value && I[0] !== 1 && k.push(R({ number: 1 }, 0)), B.value && k.push(N(!1)), O.value.forEach((G, te) => {
        const ve = B.value && n.value && I[0] !== 1 ? 1 : 0;
        k.push(R(G, te + ve));
      }), $.value && k.push(N(!0)), d.value && I[I.length - 1] !== v.value && k.push(R({ number: v.value }, -1));
      const U = E(
        l.value + 1,
        e.labelNextPage,
        cc,
        e.nextText,
        e.nextClass,
        v.value
      );
      if (k.push(U), !d.value && !s.value) {
        const G = E(
          v.value,
          e.labelLastPage,
          dc,
          e.lastText,
          e.lastClass,
          v.value
        );
        k.push(G);
      }
      return ce(
        "ul",
        {
          class: ["pagination", y.value, m.value, C.value],
          role: "menubar",
          "aria-disabled": o.value,
          "aria-label": e.ariaLabel || null
        },
        k
      );
    };
  }
}), Me = /* @__PURE__ */ z({
  inheritAttrs: !1,
  __name: "BPlaceholder",
  props: {
    tag: { default: "span" },
    wrapperTag: { default: "span" },
    width: { default: void 0 },
    cols: { default: 12 },
    variant: { default: null },
    size: { default: "md" },
    animation: { default: void 0 }
  },
  setup(e) {
    const t = e, a = i(
      () => t.width === void 0 ? void 0 : typeof t.width == "number" ? t.width.toString() : t.width.replace("%", "")
    ), l = i(
      () => t.cols === void 0 ? void 0 : typeof t.cols == "number" ? t.cols.toString() : t.cols
    ), o = i(() => ({
      [`col-${l.value}`]: l.value !== void 0 && a.value === void 0,
      [`bg-${t.variant}`]: t.variant !== null,
      [`placeholder-${t.size}`]: t.size !== "md"
    })), n = i(() => ({
      [`placeholder-${t.animation}`]: t.animation !== void 0
    })), r = i(() => ({
      width: a.value === void 0 ? void 0 : `${a.value}%`
    }));
    return (s, d) => (g(), M(ne(s.wrapperTag), {
      class: H(n.value)
    }, {
      default: D(() => [
        (g(), M(ne(s.tag), ae(s.$attrs, {
          class: ["placeholder", o.value],
          style: r.value
        }), null, 16, ["class", "style"]))
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), In = /* @__PURE__ */ z({
  __name: "BPlaceholderButton",
  props: {
    tag: { default: "div" },
    width: { default: void 0 },
    cols: { default: void 0 },
    variant: { default: "primary" },
    animation: { default: void 0 }
  },
  setup(e) {
    const t = e, a = i(() => [
      "btn",
      "disabled",
      {
        [`btn-${t.variant}`]: t.variant !== null
      }
    ]), l = i(() => ({
      animation: t.animation,
      width: t.width,
      cols: t.cols,
      tag: t.tag
    }));
    return (o, n) => (g(), M(Me, ae({ class: a.value }, l.value), null, 16, ["class"]));
  }
}), gc = /* @__PURE__ */ z({
  __name: "BPlaceholderCard",
  props: {
    noHeader: { type: [String, Boolean], default: !1 },
    headerWidth: { default: 100 },
    headerVariant: { default: void 0 },
    headerAnimation: { default: void 0 },
    headerSize: { default: "md" },
    noFooter: { type: [String, Boolean], default: !1 },
    footerWidth: { default: 100 },
    footerVariant: { default: void 0 },
    footerAnimation: { default: void 0 },
    footerSize: { default: "md" },
    animation: { default: void 0 },
    size: { default: "md" },
    variant: { default: void 0 },
    noButton: { type: [String, Boolean], default: !1 },
    imgBottom: { type: [String, Boolean], default: !1 },
    imgSrc: { default: void 0 },
    imgBlankColor: { default: "#868e96" },
    imgHeight: { default: 100 },
    noImg: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, a = c(u(t, "noButton")), l = c(u(t, "noHeader")), o = c(u(t, "noFooter")), n = c(u(t, "noImg")), r = i(() => ({
      width: t.headerWidth,
      variant: t.headerVariant,
      animation: t.headerAnimation,
      size: t.headerSize
    })), s = i(() => ({
      width: t.footerWidth,
      animation: t.footerAnimation,
      size: a.value ? t.footerSize : void 0,
      variant: t.footerVariant
    })), d = i(() => ({
      animation: t.animation,
      size: t.size,
      variant: t.variant
    })), f = i(() => ({
      blank: !t.imgSrc,
      blankColor: t.imgBlankColor,
      height: t.imgSrc ? void 0 : t.imgHeight,
      src: t.imgSrc,
      top: !t.imgBottom,
      bottom: t.imgBottom
    }));
    return (p, m) => (g(), M(bn, { "img-bottom": p.imgBottom }, so({
      default: D(() => [
        A(p.$slots, "default", {}, () => [
          Se(Me, ae({ cols: "7" }, d.value), null, 16),
          Se(Me, ae({ cols: "4" }, d.value), null, 16),
          Se(Me, ae({ cols: "4" }, d.value), null, 16),
          Se(Me, ae({ cols: "6" }, d.value), null, 16),
          Se(Me, ae({ cols: "8" }, d.value), null, 16)
        ])
      ]),
      _: 2
    }, [
      T(n) ? void 0 : {
        name: "img",
        fn: D(() => [
          A(p.$slots, "img", {}, () => [
            Se(sa, _e(Oe(f.value)), null, 16)
          ])
        ]),
        key: "0"
      },
      T(l) ? void 0 : {
        name: "header",
        fn: D(() => [
          A(p.$slots, "header", {}, () => [
            Se(Me, _e(Oe(r.value)), null, 16)
          ])
        ]),
        key: "1"
      },
      T(o) ? void 0 : {
        name: "footer",
        fn: D(() => [
          A(p.$slots, "footer", {}, () => [
            T(a) ? (g(), M(Me, _e(ae({ key: 1 }, s.value)), null, 16)) : (g(), M(In, _e(ae({ key: 0 }, s.value)), null, 16))
          ])
        ]),
        key: "2"
      }
    ]), 1032, ["img-bottom"]));
  }
}), al = /* @__PURE__ */ z({
  __name: "BTableSimple",
  props: {
    bordered: { type: [String, Boolean], default: !1 },
    borderless: { type: [String, Boolean], default: !1 },
    borderVariant: { default: null },
    captionTop: { type: [String, Boolean], default: !1 },
    dark: { type: [String, Boolean], default: !1 },
    hover: { type: [String, Boolean], default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    striped: { type: [String, Boolean], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    tableClass: { default: void 0 },
    tableVariant: { default: null },
    stickyHeader: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, a = c(u(t, "captionTop")), l = c(u(t, "borderless")), o = c(u(t, "bordered")), n = c(u(t, "dark")), r = c(u(t, "hover")), s = c(u(t, "small")), d = c(u(t, "striped")), f = c(u(t, "stickyHeader")), p = i(() => [
      "table",
      "b-table",
      {
        "table-bordered": o.value,
        "table-borderless": l.value,
        [`border-${t.borderVariant}`]: t.borderVariant !== null,
        "caption-top": a.value,
        "table-dark": n.value,
        "table-hover": r.value,
        "b-table-stacked": typeof t.stacked == "boolean" && t.stacked,
        [`b-table-stacked-${t.stacked}`]: typeof t.stacked == "string",
        "table-striped": d.value,
        "table-sm": s.value,
        [`table-${t.tableVariant}`]: t.tableVariant !== null
      },
      t.tableClass
    ]), m = i(() => [
      {
        "table-responsive": t.responsive === !0,
        [`table-responsive-${t.responsive}`]: typeof t.responsive == "string",
        "b-table-sticky-header": f.value
      }
    ]);
    return (v, b) => v.responsive ? (g(), V("div", {
      key: 1,
      class: H(m.value)
    }, [
      Z("table", {
        class: H(p.value)
      }, [
        A(v.$slots, "default")
      ], 2)
    ], 2)) : (g(), V("table", {
      key: 0,
      class: H(p.value)
    }, [
      A(v.$slots, "default")
    ], 2));
  }
}), bc = /* @__PURE__ */ z({
  __name: "BPlaceholderTable",
  props: {
    rows: { default: 3 },
    columns: { default: 5 },
    cellWidth: { default: 100 },
    size: { default: "md" },
    animation: { default: void 0 },
    variant: { default: void 0 },
    headerColumns: { default: void 0 },
    hideHeader: { type: [String, Boolean], default: !1 },
    headerCellWidth: { default: 100 },
    headerSize: { default: "md" },
    headerAnimation: { default: void 0 },
    headerVariant: { default: void 0 },
    footerColumns: { default: void 0 },
    showFooter: { type: [String, Boolean], default: !1 },
    footerCellWidth: { default: 100 },
    footerSize: { default: "md" },
    footerAnimation: { default: void 0 },
    footerVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = ht(u(t, "columns"), { nanToZero: !0, method: "parseInt" }), l = ht(u(t, "rows"), { nanToZero: !0, method: "parseInt" }), o = i(() => t.headerColumns ?? NaN), n = i(() => t.footerColumns ?? NaN), r = ht(o, {
      nanToZero: !0,
      method: "parseInt"
    }), s = ht(n, {
      nanToZero: !0,
      method: "parseInt"
    }), d = i(() => a.value || 5), f = i(() => l.value || 3), p = i(
      () => t.headerColumns === void 0 ? d.value : r.value
    ), m = i(
      () => t.footerColumns === void 0 ? d.value : s.value
    ), v = i(() => ({
      size: t.size,
      variant: t.variant,
      animation: t.animation,
      width: t.cellWidth
    })), b = i(() => ({
      size: t.headerSize,
      variant: t.headerVariant,
      animation: t.headerAnimation,
      width: t.headerCellWidth
    })), B = i(() => ({
      size: t.footerSize,
      variant: t.footerVariant,
      animation: t.footerAnimation,
      width: t.footerCellWidth
    })), w = c(u(t, "hideHeader")), $ = c(u(t, "showFooter"));
    return (h, S) => (g(), M(al, null, {
      default: D(() => [
        T(w) ? Q("", !0) : A(h.$slots, "thead", { key: 0 }, () => [
          Z("thead", null, [
            Z("tr", null, [
              (g(!0), V(pe, null, $e(p.value, (y, C) => (g(), V("th", { key: C }, [
                Se(Me, _e(Oe(b.value)), null, 16)
              ]))), 128))
            ])
          ])
        ]),
        A(h.$slots, "default", {}, () => [
          Z("tbody", null, [
            (g(!0), V(pe, null, $e(f.value, (y, C) => (g(), V("tr", { key: C }, [
              (g(!0), V(pe, null, $e(d.value, (O, k) => (g(), V("td", { key: k }, [
                Se(Me, _e(Oe(v.value)), null, 16)
              ]))), 128))
            ]))), 128))
          ])
        ]),
        T($) ? A(h.$slots, "tfoot", { key: 1 }, () => [
          Z("tfoot", null, [
            Z("tr", null, [
              (g(!0), V(pe, null, $e(m.value, (y, C) => (g(), V("th", { key: C }, [
                Se(Me, _e(Oe(B.value)), null, 16)
              ]))), 128))
            ])
          ])
        ]) : Q("", !0)
      ]),
      _: 3
    }));
  }
}), yc = /* @__PURE__ */ z({
  __name: "BPlaceholderWrapper",
  props: {
    loading: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const a = c(u(e, "loading"));
    return (l, o) => T(a) ? A(l.$slots, "loading", { key: 0 }) : A(l.$slots, "default", { key: 1 });
  }
}), hc = ["aria-valuenow", "aria-valuemax"], Fn = /* @__PURE__ */ z({
  __name: "BProgressBar",
  props: {
    animated: { type: [String, Boolean], default: !1 },
    label: { default: void 0 },
    labelHtml: { default: void 0 },
    max: { default: void 0 },
    precision: { default: 0 },
    showProgress: { type: [String, Boolean], default: !1 },
    showValue: { type: [String, Boolean], default: !1 },
    striped: { type: [String, Boolean], default: !1 },
    value: { default: 0 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, a = Ee(So, null), l = c(u(t, "animated")), o = c(u(t, "showProgress")), n = c(u(t, "showValue")), r = c(u(t, "striped")), s = i(() => ({
      "progress-bar-animated": l.value || (a == null ? void 0 : a.animated.value),
      "progress-bar-striped": r.value || (a == null ? void 0 : a.striped.value) || l.value || (a == null ? void 0 : a.animated.value),
      [`bg-${t.variant}`]: t.variant !== null
    })), d = i(
      () => typeof t.precision == "number" ? t.precision : Number.parseFloat(t.precision)
    ), f = i(
      () => typeof t.value == "number" ? t.value : Number.parseFloat(t.value)
    ), p = i(
      () => typeof t.max == "number" ? t.max : t.max === void 0 ? void 0 : Number.parseFloat(t.max)
    ), m = i(
      () => t.labelHtml !== void 0 ? t.labelHtml : n.value || a != null && a.showValue.value ? f.value.toFixed(d.value) : o.value || a != null && a.showProgress.value ? (f.value * 100 / (p.value || 100)).toFixed(d.value) : t.label !== void 0 ? t.label : ""
    ), v = i(
      () => a != null && a.max.value ? `${f.value * 100 / (typeof a.max.value == "number" ? a.max.value : Number.parseInt(a.max.value))}%` : t.max ? `${f.value * 100 / (typeof t.max == "number" ? t.max : Number.parseInt(t.max))}%` : typeof t.value == "string" ? t.value : `${t.value}%`
    );
    return (b, B) => (g(), V("div", {
      class: H(["progress-bar", s.value]),
      role: "progressbar",
      "aria-valuenow": b.value,
      "aria-valuemin": "0",
      "aria-valuemax": b.max,
      style: Ge({ width: v.value })
    }, [
      A(b.$slots, "default", {}, () => [
        de(ee(m.value), 1)
      ])
    ], 14, hc));
  }
}), Bc = /* @__PURE__ */ z({
  __name: "BProgress",
  props: {
    variant: { default: void 0 },
    max: { default: 100 },
    height: { default: void 0 },
    animated: { type: [String, Boolean], default: !1 },
    precision: { default: 0 },
    showProgress: { type: [String, Boolean], default: !1 },
    showValue: { type: [String, Boolean], default: !1 },
    striped: { type: [String, Boolean], default: !1 },
    value: { default: 0 }
  },
  setup(e) {
    const t = e, a = c(u(t, "animated")), l = c(u(t, "showProgress")), o = c(u(t, "showValue")), n = c(u(t, "striped")), r = i(() => ({
      animated: t.animated,
      max: t.max,
      precision: t.precision,
      showProgress: t.showProgress,
      showValue: t.showValue,
      striped: t.striped,
      value: t.value,
      variant: t.variant
    }));
    return Je(So, {
      animated: a,
      max: ke(u(t, "max")),
      showProgress: l,
      showValue: o,
      striped: n
    }), (s, d) => (g(), V("div", {
      class: "progress",
      style: Ge({ height: s.height })
    }, [
      A(s.$slots, "default", {}, () => [
        Se(Fn, _e(Oe(r.value)), null, 16)
      ])
    ], 4));
  }
}), ql = ua("cols", [""], { type: [String, Number], default: null }), Sc = z({
  name: "BRow",
  props: {
    tag: { type: String, default: "div" },
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    noGutters: { type: [Boolean, String], default: !1 },
    alignV: { type: String, default: null },
    alignH: { type: String, default: null },
    alignContent: { type: String, default: null },
    ...ql
  },
  setup(e) {
    const t = c(u(e, "noGutters")), a = Ht(u(e, "alignH")), l = i(() => bo(e, ql, "cols", "row-cols"));
    return {
      computedClasses: i(() => [
        l.value,
        {
          [`gx-${e.gutterX}`]: e.gutterX !== null,
          [`gy-${e.gutterY}`]: e.gutterY !== null,
          "g-0": t.value,
          [`align-items-${e.alignV}`]: e.alignV !== null,
          [a.value]: e.alignH !== null,
          [`align-content-${e.alignContent}`]: e.alignContent !== null
        }
      ])
    };
  }
});
function wc(e, t, a, l, o, n) {
  return g(), M(ne(e.tag), {
    class: H(["row", e.computedClasses])
  }, {
    default: D(() => [
      A(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const $c = /* @__PURE__ */ Re(Sc, [["render", wc]]), Gl = [
  "ar",
  "az",
  "ckb",
  "fa",
  "he",
  "ks",
  "lrc",
  "mzn",
  "ps",
  "sd",
  "te",
  "ug",
  "ur",
  "yi"
].map((e) => e.toLowerCase()), _c = (e) => {
  const t = Jt(e).toLowerCase().replace(ns, "").split("-"), a = t.slice(0, 2).join("-"), [l] = t;
  return Gl.includes(a) || Gl.includes(l);
}, kc = (e) => bs ? ya(e) ? e : { capture: !!e || !1 } : !!(ya(e) ? e.capture : e), Cc = (e, t, a, l) => {
  e && e.addEventListener && e.addEventListener(t, a, kc(l));
}, Tc = (e, t, a, l) => {
  e && e.removeEventListener && e.removeEventListener(t, a, l);
}, Wl = (e, t) => {
  (e ? Cc : Tc)(...t);
}, Gt = (e, { preventDefault: t = !0, propagation: a = !0, immediatePropagation: l = !1 } = {}) => {
  t && e.preventDefault(), a && e.stopPropagation(), l && e.stopImmediatePropagation();
}, Fa = "ArrowDown", Ln = "End", xn = "Home", Nn = "PageDown", zn = "PageUp", La = "ArrowUp", Ul = 1, Kl = 100, Xl = 1, Jl = 500, Yl = 100, Zl = 10, Ql = 4, eo = [La, Fa, xn, Ln, zn, Nn], Ac = z({
  props: {
    ariaControls: { type: String, default: void 0 },
    ariaLabel: { type: String, default: void 0 },
    labelIncrement: { type: String, default: "Increment" },
    labelDecrement: { type: String, default: "Decrement" },
    modelValue: { type: Number, default: null },
    // V-model prop
    name: { type: String, default: "BFormSpinbutton" },
    disabled: { type: [Boolean, String], default: !1 },
    placeholder: { type: String, default: void 0 },
    locale: { type: String, default: "locale" },
    form: { type: String, default: void 0 },
    inline: { type: Boolean, default: !1 },
    size: { type: String, default: void 0 },
    formatterFn: {
      type: Function,
      default: void 0
    },
    readonly: { type: Boolean, default: !1 },
    vertical: { type: Boolean, default: !1 },
    repeatDelay: {
      type: [String, Number],
      default: Jl
    },
    repeatInterval: {
      type: [String, Number],
      default: Yl
    },
    repeatStepMultiplier: {
      type: [String, Number],
      default: Ql
    },
    repeatThreshold: {
      type: [String, Number],
      default: Zl
    },
    required: { type: [Boolean, String], default: !1 },
    step: { type: [String, Number], default: Xl },
    min: { type: [String, Number], default: Ul },
    max: { type: [String, Number], default: Kl },
    wrap: { type: Boolean, default: !1 },
    state: { type: [Boolean, String], default: null }
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = Ve(e, "modelValue", t), l = x(!1), o = i(() => 1), n = () => {
      t("change", s.value);
    }, r = x(null), s = i({
      get: () => a.value === null ? r.value : a.value,
      set: (W) => {
        a.value === null ? r.value = W : a.value = W;
      }
    });
    let d, f, p = !1;
    const m = i(() => Vt(e.step, Xl)), v = i(() => Vt(e.min, Ul)), b = i(() => {
      const W = Vt(e.max, Kl), Y = m.value, ie = v.value;
      return Math.floor((W - ie) / Y) * Y + ie;
    }), B = i(() => {
      const W = nt(e.repeatDelay, 0);
      return W > 0 ? W : Jl;
    }), w = i(() => {
      const W = nt(e.repeatInterval, 0);
      return W > 0 ? W : Yl;
    }), $ = i(
      () => Math.max(nt(e.repeatThreshold, Zl), 1)
    ), h = i(
      () => Math.max(nt(e.repeatStepMultiplier, Ql), 1)
    ), S = i(() => {
      const W = m.value;
      return Math.floor(W) === W ? 0 : (W.toString().split(".")[1] || "").length;
    }), y = i(() => Math.pow(10, S.value || 0)), C = i(() => {
      const { value: W } = s;
      return W === null ? "" : W.toFixed(S.value);
    }), O = i(() => {
      const W = [e.locale];
      return new Intl.NumberFormat(W).resolvedOptions().locale;
    }), k = i(
      () => (
        //todo
        _c(O.value)
      )
    ), I = () => {
      const W = S.value;
      return new Intl.NumberFormat(O.value, {
        style: "decimal",
        useGrouping: !1,
        minimumIntegerDigits: 1,
        minimumFractionDigits: W,
        maximumFractionDigits: W,
        notation: "standard"
      }).format;
    }, F = i(() => e.formatterFn ?? I()), L = i(() => ({
      role: "group",
      lang: O.value,
      tabindex: e.disabled ? null : "-1",
      title: e.ariaLabel
    })), _ = i(() => a.value !== null || r.value !== null), E = i(() => ({
      dir: k.value,
      spinId: o.value,
      tabindex: e.disabled ? null : "0",
      role: "spinbutton",
      "aria-live": "off",
      "aria-label": e.ariaLabel || null,
      "aria-controls": e.ariaControls || null,
      "aria-invalid": e.state === !1 || !_.value && e.required ? !0 : null,
      "aria-required": e.required ? !0 : null,
      "aria-valuemin": v.value,
      "aria-valuemax": b.value,
      "aria-valuenow": s.value !== null ? s.value : null,
      "aria-valuetext": s.value !== null ? F.value(s.value) : null
    })), N = (W) => {
      let { value: Y } = s;
      if (!e.disabled && Y !== null) {
        const ie = m.value * W, j = v.value, q = b.value, se = y.value, { wrap: he } = e;
        Y = Math.round((Y - j) / ie) * ie + j + ie, Y = Math.round(Y * se) / se, s.value = Y > q ? he ? j : q : Y < j ? he ? q : j : Y;
      }
    }, R = (W = 1) => {
      s.value === null ? s.value = v.value : N(1 * W);
    }, oe = (W = 1) => {
      s.value === null ? s.value = e.wrap ? b.value : v.value : N(-1 * W);
    }, U = (W) => {
      const { code: Y, altKey: ie, ctrlKey: j, metaKey: q } = W;
      if (!(e.disabled || e.readonly || ie || j || q) && eo.includes(Y)) {
        if (Gt(W, { propagation: !1 }), p)
          return;
        ge(), [La, Fa].includes(Y) ? (p = !0, Y === La ? te(W, R) : Y === Fa && te(W, oe)) : Y === zn ? R(h.value) : Y === Nn ? oe(h.value) : Y === xn ? s.value = v.value : Y === Ln && (s.value = b.value);
      }
    }, G = (W) => {
      const { code: Y, altKey: ie, ctrlKey: j, metaKey: q } = W;
      e.disabled || e.readonly || ie || j || q || eo.includes(Y) && (Gt(W, { propagation: !1 }), ge(), p = !1, n());
    }, te = (W, Y) => {
      const { type: ie } = W || {};
      if (!e.disabled && !e.readonly) {
        if (ve(W) && ie === "mousedown" && W.button)
          return;
        ge(), Y(1);
        const j = $.value, q = h.value, se = B.value, he = w.value;
        d = setTimeout(() => {
          let we = 0;
          f = setInterval(() => {
            Y(we < j ? 1 : q), we++;
          }, he);
        }, se);
      }
    };
    function ve(W) {
      return W.type === "mouseup" || W.type === "mousedown";
    }
    const ye = (W) => {
      ve(W) && W.type === "mouseup" && W.button || (Gt(W, { propagation: !1 }), ge(), Be(!1), n());
    }, Be = (W) => {
      try {
        Wl(W, [document.body, "mouseup", ye, !1]), Wl(W, [document.body, "touchend", ye, !1]);
      } catch {
        return 0;
      }
    }, ge = () => {
      clearTimeout(d), clearInterval(f), d = void 0, f = void 0;
    }, be = (W, Y, ie, j, q, se, he) => {
      const we = ce(ie, {
        props: { scale: l.value ? 1.5 : 1.25 },
        attrs: { "aria-hidden": !0 }
      }), J = { hasFocus: l.value }, fe = (P) => {
        !e.disabled && !e.readonly && (Gt(P, { propagation: !1 }), Be(!0), te(P, W));
      };
      return ce(
        "button",
        {
          class: [{ "py-0": !e.vertical }, "btn", "btn-sm", "border-0", "rounded-0"],
          tabindex: "-1",
          type: "button",
          disabled: e.disabled || e.readonly || se,
          "aria-disabled": e.disabled || e.readonly || se ? !0 : null,
          "aria-controls": o.value,
          "aria-label": Y || null,
          "aria-keyshortcuts": q || null,
          onmousedown: fe,
          ontouchstart: fe
          // 'ref': keyRef,
        },
        [De(he, J) || we]
      );
    };
    return () => {
      const W = be(
        R,
        e.labelIncrement,
        ce(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-plus",
            viewBox: "0 0 16 16"
          },
          ce("path", {
            d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"
          })
        ),
        "inc",
        "ArrowUp",
        !1,
        "increment"
      ), Y = be(
        oe,
        e.labelDecrement,
        ce(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-dash",
            viewBox: "0 0 16 16"
          },
          ce("path", { d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z" })
        ),
        "dec",
        "ArrowDown",
        !1,
        "decrement"
      ), ie = [];
      e.name && !e.disabled && ie.push(
        ce("input", {
          type: "hidden",
          name: e.name,
          form: e.form || null,
          // TODO: Should this be set to '' if value is out of range?
          value: C.value,
          key: "hidden"
        })
      );
      const j = ce(
        // We use 'output' element to make this accept a `<label for="id">` (Except IE)
        "output",
        {
          class: [
            { "d-flex": e.vertical },
            { "align-self-center": !e.vertical },
            { "align-items-center": e.vertical },
            { "border-top": e.vertical },
            { "border-bottom": e.vertical },
            { "border-start": !e.vertical },
            { "border-end": !e.vertical },
            "flex-grow-1"
          ],
          ...E.value,
          key: "output"
          // ref: 'spinner',
        },
        [
          ce(
            "bdi",
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            //@ts-ignore How can we narrow this type down
            _.value ? F.value(s.value) : e.placeholder || ""
          )
        ]
      );
      return ce(
        "div",
        {
          class: [
            "b-form-spinbutton form-control",
            { disabled: e.disabled },
            { readonly: e.readonly },
            { focus: l },
            { "d-inline-flex": e.inline || e.vertical },
            { "d-flex": !e.inline && !e.vertical },
            { "align-items-stretch": !e.vertical },
            { "flex-column": e.vertical },
            e.size ? `form-control-${e.size}` : null
            // this.stateClass //TODO
          ],
          ...L.value,
          onkeydown: U,
          onkeyup: G
          // We use capture phase (`!` prefix) since focus and blur do not bubble
          // 'focus': onFocusBlur, //TODO
          // 'blur': onFocusBlur, //TODO
        },
        e.vertical ? [W, ie, j, Y] : [Y, ie, j, W]
      );
    };
  }
}), Vc = ["TD", "TH", "TR"], Pc = [
  "a",
  "a *",
  // Include content inside links
  "button",
  "button *",
  // Include content inside buttons
  "input:not(.disabled):not([disabled])",
  "select:not(.disabled):not([disabled])",
  "textarea:not(.disabled):not([disabled])",
  '[role="link"]',
  '[role="link"] *',
  '[role="button"]',
  '[role="button"] *',
  "[tabindex]:not(.disabled):not([disabled])"
].join(","), Wt = (e) => {
  if (!e || !e.target)
    return !1;
  const t = e.target;
  if ("disabled" in t && t.disabled || Vc.indexOf(t.tagName) !== -1)
    return !1;
  if (rl(".dropdown-menu", t))
    return !0;
  const a = t.tagName === "LABEL" ? t : rl("label", t);
  if (a) {
    const l = Da(a, "for"), o = l ? Cs(l) : mo("input, select, textarea", a);
    if (o && !o.disabled)
      return !0;
  }
  return go(t, Pc);
}, Oc = () => {
  const e = (f, p) => {
    const m = [];
    return !(f != null && f.length) && (p != null && p.length) ? (Object.keys(p[0]).forEach((v) => m.push({ key: v, label: ll(v) })), m) : (Array.isArray(f) && f.forEach((v) => {
      typeof v == "string" ? m.push({ key: v, label: ll(v) }) : ya(v) && v.key && typeof v.key == "string" && m.push({ ...v });
    }), m);
  }, t = x([]), a = (f, p, m, v) => (t.value = Yt(p), "isFilterableTable" in v && v.isFilterableTable.value === !0 && m.filter && (t.value = n(t.value, m.filter, m.filterable)), "isSortable" in v && v.isSortable.value === !0 && (t.value = o(
    f,
    t.value,
    {
      key: m.sortBy,
      desc: v.sortDescBoolean.value
    },
    m.sortCompare
  )), t.value), l = x(void 0), o = (f, p, m, v) => {
    if (!m || !m.key)
      return p;
    const b = m.key;
    return p.sort((B, w) => {
      if (v !== void 0)
        return v(B, w, m.key, m.desc);
      const $ = (y) => typeof y == "object" ? JSON.stringify(y) : y;
      return $(B[b]) > $(w[b]) ? m.desc ? -1 : 1 : $(w[b]) > $(B[b]) ? m.desc ? 1 : -1 : 0;
    });
  }, n = (f, p, m) => f.filter(
    (v) => Object.entries(v).filter((b) => {
      const [B, w] = b;
      return !w || B[0] === "_" || m.length > 0 && !m.includes(B) ? !1 : (typeof w == "object" ? JSON.stringify(Object.values(w)) : typeof w == "string" ? w : w.toString()).toLowerCase().includes(p.toLowerCase());
    }).length > 0
  );
  return {
    normaliseFields: e,
    mapItems: a,
    internalItems: t,
    updateInternalItems: async (f) => {
      try {
        return t.value = await Ba(f), t.value;
      } catch {
        return;
      }
    },
    filterEvent: l,
    notifyFilteredItems: () => {
      l.value && l.value(t.value);
    },
    formatItem: (f, p) => {
      const m = f[p.key];
      return p.formatter && typeof p.formatter == "function" ? p.formatter(m, p.key, f) : f[p.key];
    }
  };
}, Ec = ["title", "abbr", "onClick"], Ic = { class: "d-inline-flex flex-nowrap align-items-center gap-1" }, Fc = { key: 1 }, Lc = ["onClick", "onDblclick", "onMouseenter", "onMouseleave"], xc = {
  key: 0,
  class: "b-table-stacked-label"
}, Nc = ["colspan"], zc = ["colspan"], Rc = { class: "d-flex align-items-center justify-content-center gap-2" }, Hc = /* @__PURE__ */ Z("strong", null, "Loading...", -1), Mc = {
  key: 1,
  class: "b-table-empty-slot"
}, Dc = ["colspan"], jc = { key: 0 }, qc = ["title", "abbr", "onClick"], Gc = { key: 1 }, Wc = { key: 2 }, Uc = { key: 3 }, Kc = /* @__PURE__ */ z({
  __name: "BTable",
  props: {
    align: { default: void 0 },
    caption: { default: void 0 },
    captionTop: { type: [String, Boolean], default: !1 },
    borderless: { type: [String, Boolean], default: !1 },
    bordered: { type: [String, Boolean], default: !1 },
    borderVariant: { default: void 0 },
    dark: { type: [String, Boolean], default: !1 },
    fields: { default: () => [] },
    footClone: { type: [String, Boolean], default: !1 },
    hover: { type: [String, Boolean], default: !1 },
    items: { default: () => [] },
    provider: { type: Function, default: void 0 },
    sortCompare: { type: Function, default: void 0 },
    noProvider: { default: void 0 },
    noProviderPaging: { type: [String, Boolean], default: void 0 },
    noProviderSorting: { type: [String, Boolean], default: void 0 },
    noProviderFiltering: { type: [String, Boolean], default: void 0 },
    responsive: { type: [Boolean, String], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    striped: { type: [String, Boolean], default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    labelStacked: { type: Boolean, default: !1 },
    variant: { default: void 0 },
    sortBy: { default: void 0 },
    sortDesc: { type: [String, Boolean], default: !1 },
    sortInternal: { type: [String, Boolean], default: !0 },
    selectable: { type: [String, Boolean], default: !1 },
    stickySelect: { type: [String, Boolean], default: !1 },
    selectHead: { type: [Boolean, String], default: !0 },
    selectMode: { default: "single" },
    selectionVariant: { default: "primary" },
    stickyHeader: { type: [String, Boolean], default: !1 },
    busy: { type: [String, Boolean], default: !1 },
    showEmpty: { type: [String, Boolean], default: !1 },
    perPage: { default: void 0 },
    currentPage: { default: 1 },
    filter: { default: void 0 },
    filterable: { default: void 0 },
    emptyText: { default: "There are no records to show" },
    emptyFilteredText: { default: "There are no records matching your request" }
  },
  emits: ["headClicked", "rowClicked", "rowDblClicked", "rowHovered", "rowUnhovered", "rowSelected", "rowUnselected", "selection", "update:busy", "update:sortBy", "update:sortDesc", "sorted", "filtered"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = Le(), n = Oc(), r = c(u(l, "footClone")), s = c(u(l, "sortDesc")), d = c(u(l, "sortInternal")), f = c(u(l, "selectable")), p = c(u(l, "stickySelect")), m = c(u(l, "labelStacked")), v = c(u(l, "busy")), b = c(u(l, "showEmpty")), B = c(u(l, "noProviderPaging")), w = c(u(l, "noProviderSorting")), $ = c(u(l, "noProviderFiltering")), h = x(v.value);
    n.filterEvent.value = async (P) => {
      if (L.value) {
        await W();
        return;
      }
      const K = await Ba(P);
      a("filtered", K);
    };
    const S = x(/* @__PURE__ */ new Set([])), y = i(() => S.value.size > 0), C = i(() => ({
      [`align-${l.align}`]: l.align !== void 0,
      "b-table-selectable": f.value,
      [`b-table-select-${l.selectMode}`]: f.value,
      "b-table-selecting user-select-none": f.value && y.value,
      "b-table-busy": h.value,
      "b-table-sortable": E.value,
      "b-table-sort-desc": E.value && s.value === !0,
      "b-table-sort-asc": E.value && s.value === !1
    })), O = i(() => ({
      bordered: l.bordered,
      borderless: l.borderless,
      borderVariant: l.borderVariant,
      captionTop: l.captionTop,
      dark: l.dark,
      hover: l.hover,
      responsive: l.responsive,
      striped: l.striped,
      stacked: l.stacked,
      small: l.small,
      tableClass: C.value,
      tableVariant: l.variant,
      stickyHeader: l.stickyHeader
    })), k = i(() => n.normaliseFields(l.fields, l.items)), I = i(
      () => k.value.length + (f.value ? 1 : 0)
    ), F = i(() => l.filter !== void 0 && l.filter !== ""), L = i(() => l.provider !== void 0), _ = i(
      () => f.value && (!!l.selectHead || o.selectHead !== void 0)
    ), E = i(
      () => l.fields.filter((P) => typeof P == "string" ? !1 : P.sortable).length > 0
    ), N = i(() => E.value && d.value === !0), R = i(() => {
      const P = L.value ? n.internalItems.value : N.value ? n.mapItems(l.fields, l.items, l, {
        isSortable: E,
        isFilterableTable: F,
        sortDescBoolean: s
      }) : l.items;
      if (l.perPage !== void 0) {
        const K = (l.currentPage - 1) * l.perPage, me = K + l.perPage > P.length ? P.length : K + l.perPage;
        return P.slice(K, me);
      }
      return P;
    }), oe = (P) => typeof P == "string" ? ol(P) : P.label !== void 0 ? P.label : typeof P.key == "string" ? ol(P.key) : P.key, U = (P, K, me = !1) => {
      const X = typeof P == "string" ? P : P.key;
      a("headClicked", X, P, K, me), Be(P);
    }, G = (P, K, me) => {
      a("rowClicked", P, K, me), be(P, K, me.shiftKey, me.ctrlKey);
    }, te = (P, K, me) => a("rowDblClicked", P, K, me), ve = (P, K, me) => a("rowHovered", P, K, me), ye = (P, K, me) => a("rowUnhovered", P, K, me), Be = (P) => {
      if (!E.value)
        return;
      const K = typeof P == "string" ? P : P.key, me = typeof P == "string" ? !1 : P.sortable;
      if (E.value === !0 && me === !0) {
        const X = !s.value;
        K !== l.sortBy && a("update:sortBy", K), a("update:sortDesc", X), a("sorted", K, X);
      }
    }, ge = () => {
      f.value && a("selection", Array.from(S.value));
    }, be = (P, K, me = !1, X = !1) => {
      if (f.value) {
        if (me && l.selectMode === "range" && S.value.size > 0) {
          const le = Array.from(S.value).pop(), re = R.value.findIndex((ut) => ut === le), tt = Math.min(re, K), pa = Math.max(re, K);
          R.value.slice(tt, pa + 1).forEach((ut) => {
            S.value.has(ut) || (S.value.add(ut), a("rowSelected", ut));
          });
        } else
          X ? S.value.has(P) ? (S.value.delete(P), a("rowUnselected", P)) : l.selectMode === "range" || l.selectMode === "multi" ? (S.value.add(P), a("rowSelected", P)) : (S.value.forEach((le) => a("rowUnselected", le)), S.value.clear(), S.value.add(P), a("rowSelected", P)) : (S.value.forEach((le) => a("rowUnselected", le)), S.value.clear(), S.value.add(P), a("rowSelected", P));
        ge();
      }
    }, W = async () => {
      if (!L.value || !l.provider || h.value)
        return;
      h.value = !0;
      const P = new Proxy(
        {
          currentPage: l.currentPage,
          filter: l.filter,
          sortBy: l.sortBy,
          sortDesc: l.sortDesc,
          perPage: l.perPage
        },
        {
          get: (me, X) => X in me ? me[X] : void 0,
          set: () => (console.error("BTable provider context is a read-only object."), !0)
        }
      ), K = l.provider(P, n.updateInternalItems);
      if (K !== void 0) {
        if (K instanceof Promise)
          try {
            const me = await K;
            return Array.isArray(me) ? await n.updateInternalItems(me) : void 0;
          } finally {
            h.value && (h.value = !1);
          }
        try {
          return await n.updateInternalItems(K);
        } finally {
          h.value && (h.value = !1);
        }
      }
    }, Y = (P) => {
      P._showDetails = !P._showDetails;
    }, ie = (P) => [
      P.class,
      P.thClass,
      {
        [`table-${P.variant}`]: P.variant !== null,
        "b-table-sortable-column": E.value && P.sortable,
        "b-table-sticky-column": P.stickyColumn
      }
    ], j = (P, K) => [
      P.class,
      P.tdClass,
      K != null && K._cellVariants && (K != null && K._cellVariants[P.key]) ? `table-${K == null ? void 0 : K._cellVariants[P.key]}` : void 0,
      {
        [`table-${P.variant}`]: P.variant !== null,
        "b-table-sticky-column": P.stickyColumn
      }
    ], q = (P) => [
      P._rowVariant ? `table-${P._rowVariant}` : null,
      P._rowVariant ? `table-${P._rowVariant}` : null,
      f.value && S.value.has(P) ? `selected table-${l.selectionVariant}` : null
    ], se = () => {
      if (!f.value)
        return;
      const P = S.value.size > 0 ? Array.from(S.value) : [];
      S.value = /* @__PURE__ */ new Set([...R.value]), S.value.forEach((K) => {
        P.includes(K) || a("rowSelected", K);
      }), ge();
    }, he = () => {
      f.value && (S.value.forEach((P) => {
        a("rowUnselected", P);
      }), S.value = /* @__PURE__ */ new Set([]), ge());
    }, we = (P) => {
      if (!f.value)
        return;
      const K = R.value[P];
      !K || S.value.has(K) || (S.value.add(K), a("rowSelected", K), ge());
    }, J = (P) => {
      if (!f.value)
        return;
      const K = R.value[P];
      !K || !S.value.has(K) || (S.value.delete(K), a("rowUnselected", K), ge());
    }, fe = async (P, K, me) => {
      if (K === me)
        return;
      const X = (ut) => l.noProvider && l.noProvider.includes(ut), le = !["currentPage", "perPage"].includes(P), re = ["currentPage", "perPage"].includes(P) && (X("paging") || B.value === !0), tt = ["filter"].includes(P) && (X("filtering") || $.value === !0), pa = ["sortBy", "sortDesc"].includes(P) && (X("sorting") || w.value === !0);
      re || tt || pa || (await W(), le && n.notifyFilteredItems());
    };
    return ue(
      () => l.filter,
      (P, K) => {
        P === K || L.value || P || Ba(l.items).then((me) => a("filtered", me));
      }
    ), ue(
      h,
      () => h.value !== v.value && a("update:busy", h.value)
    ), ue(
      v,
      () => h.value !== v.value && (h.value = v.value)
    ), ue(
      () => l.filter,
      (P, K) => fe("filter", P, K)
    ), ue(
      () => l.currentPage,
      (P, K) => fe("currentPage", P, K)
    ), ue(
      () => l.perPage,
      (P, K) => fe("perPage", P, K)
    ), ue(
      () => l.sortBy,
      (P, K) => fe("sortBy", P, K)
    ), ue(
      () => l.sortDesc,
      (P, K) => fe("sortDesc", P, K)
    ), Xe(() => {
      L.value && W();
    }), t({
      selectAllRows: se,
      clearSelected: he,
      selectRow: we,
      unselectRow: J,
      refresh: W
    }), (P, K) => (g(), M(al, _e(Oe(O.value)), {
      default: D(() => {
        var me;
        return [
          Z("thead", null, [
            P.$slots["thead-top"] ? A(P.$slots, "thead-top", { key: 0 }) : Q("", !0),
            Z("tr", null, [
              _.value ? (g(), V("th", {
                key: 0,
                class: H(["b-table-selection-column", {
                  "b-table-sticky-column": T(p)
                }])
              }, [
                A(P.$slots, "select-head", {}, () => [
                  de(ee(typeof P.selectHead == "boolean" ? "Selected" : P.selectHead), 1)
                ])
              ], 2)) : Q("", !0),
              (g(!0), V(pe, null, $e(k.value, (X) => (g(), V("th", ae({
                key: X.key,
                scope: "col",
                class: ie(X),
                title: X.headerTitle,
                abbr: X.headerAbbr,
                style: X.thStyle
              }, X.thAttr, {
                onClick: (le) => U(X, le)
              }), [
                Z("div", Ic, [
                  A(P.$slots, "sort-icon", {
                    field: X,
                    sortBy: P.sortBy,
                    selected: X.key === P.sortBy,
                    isDesc: T(s),
                    direction: T(s) ? "desc" : "asc"
                  }, () => [
                    E.value && X.sortable ? (g(), V("span", {
                      key: 0,
                      class: H(["b-table-sort-icon", {
                        sorted: X.key === P.sortBy,
                        [`sorted-${T(s) ? "desc" : "asc"}`]: X.key === P.sortBy
                      }])
                    }, null, 2)) : Q("", !0)
                  ]),
                  Z("div", null, [
                    P.$slots["head(" + X.key + ")"] || P.$slots["head()"] ? A(P.$slots, P.$slots["head(" + X.key + ")"] ? "head(" + X.key + ")" : "head()", {
                      key: 0,
                      label: X.label
                    }) : (g(), V(pe, { key: 1 }, [
                      de(ee(oe(X)), 1)
                    ], 64))
                  ])
                ])
              ], 16, Ec))), 128))
            ]),
            P.$slots["thead-sub"] ? (g(), V("tr", Fc, [
              (g(!0), V(pe, null, $e(k.value, (X) => (g(), V("td", {
                key: X.key,
                scope: "col",
                class: H([X.class, X.thClass, X.variant ? `table-${X.variant}` : ""])
              }, [
                P.$slots["thead-sub"] ? A(P.$slots, "thead-sub", ae({
                  key: 0,
                  items: k.value
                }, X)) : (g(), V(pe, { key: 1 }, [
                  de(ee(X.label), 1)
                ], 64))
              ], 2))), 128))
            ])) : Q("", !0)
          ]),
          Z("tbody", null, [
            (g(!0), V(pe, null, $e(R.value, (X, le) => (g(), V(pe, { key: le }, [
              Z("tr", {
                class: H(q(X)),
                onClick: (re) => !T(Wt)(re) && G(X, le, re),
                onDblclick: (re) => !T(Wt)(re) && te(X, le, re),
                onMouseenter: (re) => !T(Wt)(re) && ve(X, le, re),
                onMouseleave: (re) => !T(Wt)(re) && ye(X, le, re)
              }, [
                _.value ? (g(), V("td", {
                  key: 0,
                  class: H(["b-table-selection-column", {
                    "b-table-sticky-column": T(p)
                  }])
                }, [
                  A(P.$slots, "select-cell", {}, () => [
                    Z("span", {
                      class: H(S.value.has(X) ? "text-primary" : "")
                    }, "ð¹", 2)
                  ])
                ], 2)) : Q("", !0),
                (g(!0), V(pe, null, $e(k.value, (re) => (g(), V("td", ae({
                  key: re.key
                }, re.tdAttr, {
                  class: j(re, X)
                }), [
                  P.stacked && T(m) ? (g(), V("label", xc, ee(oe(re)), 1)) : Q("", !0),
                  P.$slots["cell(" + re.key + ")"] || P.$slots["cell()"] ? A(P.$slots, P.$slots["cell(" + re.key + ")"] ? "cell(" + re.key + ")" : "cell()", {
                    key: 1,
                    value: X[re.key],
                    index: le,
                    item: X,
                    field: re,
                    items: P.items,
                    toggleDetails: () => Y(X),
                    detailsShowing: X._showDetails
                  }) : (g(), V(pe, { key: 2 }, [
                    de(ee(T(n).formatItem(X, re)), 1)
                  ], 64))
                ], 16))), 128))
              ], 42, Lc),
              X._showDetails === !0 && P.$slots["row-details"] ? (g(), V("tr", {
                key: 0,
                class: H(q(X))
              }, [
                Z("td", { colspan: I.value }, [
                  A(P.$slots, "row-details", {
                    item: X,
                    toggleDetails: () => Y(X)
                  })
                ], 8, Nc)
              ], 2)) : Q("", !0)
            ], 64))), 128)),
            h.value ? (g(), V("tr", {
              key: 0,
              class: H(["b-table-busy-slot", { "b-table-static-busy": R.value.length === 0 }])
            }, [
              Z("td", { colspan: I.value }, [
                A(P.$slots, "table-busy", {}, () => [
                  Z("div", Rc, [
                    Se(va, { class: "align-middle" }),
                    Hc
                  ])
                ])
              ], 8, zc)
            ], 2)) : Q("", !0),
            T(b) && R.value.length === 0 ? (g(), V("tr", Mc, [
              Z("td", { colspan: I.value }, [
                A(P.$slots, "empty", {
                  items: R.value,
                  filtered: F.value
                }, () => [
                  de(ee(F.value ? P.emptyFilteredText : P.emptyText), 1)
                ])
              ], 8, Dc)
            ])) : Q("", !0)
          ]),
          T(r) ? (g(), V("tfoot", jc, [
            Z("tr", null, [
              (g(!0), V(pe, null, $e(k.value, (X) => (g(), V("th", ae({
                key: X.key
              }, X.thAttr, {
                scope: "col",
                class: [X.class, X.thClass, X.variant ? `table-${X.variant}` : ""],
                title: X.headerTitle,
                abbr: X.headerAbbr,
                style: X.thStyle,
                onClick: (le) => U(X, le, !0)
              }), ee(X.label), 17, qc))), 128))
            ])
          ])) : P.$slots["custom-foot"] ? (g(), V("tfoot", Gc, [
            A(P.$slots, "custom-foot", {
              fields: k.value,
              items: P.items,
              columns: (me = k.value) == null ? void 0 : me.length
            })
          ])) : Q("", !0),
          P.$slots["table-caption"] ? (g(), V("caption", Wc, [
            A(P.$slots, "table-caption")
          ])) : P.caption ? (g(), V("caption", Uc, ee(P.caption), 1)) : Q("", !0)
        ];
      }),
      _: 3
    }, 16));
  }
}), Xc = /* @__PURE__ */ z({
  __name: "BTbody",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, a = i(() => ({
      [`thead-${t.variant}`]: t.variant !== null
    }));
    return (l, o) => (g(), V("tbody", {
      class: H(a.value)
    }, [
      A(l.$slots, "default")
    ], 2));
  }
}), Jc = ["scope", "colspan", "rowspan", "data-label"], Yc = { key: 0 }, Zc = /* @__PURE__ */ z({
  __name: "BTd",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: [String, Boolean], default: !1 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, a = c(u(t, "stickyColumn")), l = i(() => ({
      [`table-${t.variant}`]: t.variant !== null,
      "b-table-sticky-column": a.value,
      "table-b-table-default": a.value && t.variant === null
    })), o = i(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, r) => (g(), V("td", {
      scope: o.value,
      class: H(l.value),
      colspan: n.colspan,
      rowspan: n.rowspan,
      "data-label": n.stackedHeading
    }, [
      n.stackedHeading ? (g(), V("div", Yc, [
        A(n.$slots, "default")
      ])) : A(n.$slots, "default", { key: 1 })
    ], 10, Jc));
  }
}), Qc = /* @__PURE__ */ z({
  __name: "BTfoot",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, a = i(() => ({
      [`table-${t.variant}`]: t.variant !== null
    }));
    return (l, o) => (g(), V("tfoot", {
      class: H(a.value)
    }, [
      A(l.$slots, "default")
    ], 2));
  }
}), ef = ["scope", "colspan", "rowspan", "data-label"], tf = { key: 0 }, af = /* @__PURE__ */ z({
  __name: "BTh",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: [String, Boolean], default: !1 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, a = c(u(t, "stickyColumn")), l = i(() => ({
      [`table-${t.variant}`]: t.variant !== null,
      "b-table-sticky-column": a.value,
      "table-b-table-default": a.value && t.variant === null
    })), o = i(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, r) => (g(), V("th", {
      scope: o.value,
      class: H(l.value),
      colspan: n.colspan,
      rowspan: n.rowspan,
      "data-label": n.stackedHeading
    }, [
      n.stackedHeading !== void 0 ? (g(), V("div", tf, [
        A(n.$slots, "default")
      ])) : A(n.$slots, "default", { key: 1 })
    ], 10, ef));
  }
}), lf = /* @__PURE__ */ z({
  __name: "BThead",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, a = i(() => ({
      [`table-${t.variant}`]: t.variant !== null
    }));
    return (l, o) => (g(), V("thead", {
      class: H(a.value)
    }, [
      A(l.$slots, "default")
    ], 2));
  }
}), of = /* @__PURE__ */ z({
  __name: "BTr",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, a = i(() => ({
      [`table-${t.variant}`]: t.variant !== null
    }));
    return (l, o) => (g(), V("tr", {
      class: H(a.value)
    }, [
      A(l.$slots, "default")
    ], 2));
  }
}), nf = /* @__PURE__ */ z({
  __name: "BTab",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    active: { type: [String, Boolean], default: !1 },
    buttonId: { default: void 0 },
    disabled: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: void 0 },
    lazyOnce: { type: [String, Boolean], default: void 0 },
    noBody: { type: [Boolean, String], default: !1 },
    tag: { default: "div" },
    titleItemClass: { default: void 0 },
    titleLinkAttributes: { default: void 0 },
    titleLinkClass: { default: void 0 }
  },
  setup(e) {
    const t = e, a = Ee(ho, null), l = c(u(t, "active")), o = c(u(t, "disabled")), n = c(u(t, t.lazyOnce !== void 0 ? "lazyOnce" : "lazy")), r = x(!1), s = i(() => !!(a != null && a.lazy.value || n.value)), d = i(() => t.lazyOnce !== void 0), f = i(() => l.value && !o.value), p = i(() => {
      const b = s.value && d.value && r.value;
      return f.value || !s.value || b;
    }), m = x(l.value);
    ue(l, (b) => {
      setTimeout(() => {
        m.value = b;
      }, 0);
    });
    const v = i(() => ({
      active: l.value,
      show: m.value,
      "card-body": (a == null ? void 0 : a.card.value) && t.noBody === !1
    }));
    return ue(p, (b) => {
      b && !r.value && (r.value = !0);
    }), (b, B) => (g(), M(ne(b.tag), {
      id: b.id,
      class: H(["tab-pane", v.value]),
      role: "tabpanel",
      "aria-labelledby": "profile-tab"
    }, {
      default: D(() => [
        p.value ? A(b.$slots, "default", { key: 0 }) : Q("", !0)
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), sf = ["id", "data-bs-target", "aria-controls", "aria-selected", "onClick"], rf = /* @__PURE__ */ z({
  __name: "BTabs",
  props: {
    activeNavItemClass: { default: void 0 },
    activeTabClass: { default: void 0 },
    align: { default: void 0 },
    contentClass: { default: void 0 },
    card: { type: [String, Boolean], default: !1 },
    end: { type: [String, Boolean], default: !1 },
    fill: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    justified: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    navClass: { default: void 0 },
    navWrapperClass: { default: void 0 },
    noFade: { type: [String, Boolean], default: !1 },
    noNavStyle: { type: [String, Boolean], default: !1 },
    pills: { type: [String, Boolean], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    tag: { default: "div" },
    vertical: { type: [String, Boolean], default: !1 },
    modelValue: { default: -1 }
  },
  emits: ["update:modelValue", "activate-tab", "click"],
  setup(e, { emit: t }) {
    const a = e, l = Ve(a, "modelValue", t), o = Le(), n = c(u(a, "card")), r = c(u(a, "end")), s = c(u(a, "fill")), d = c(u(a, "justified")), f = c(u(a, "lazy")), p = c(u(a, "noFade")), m = c(u(a, "noNavStyle")), v = c(u(a, "pills")), b = c(u(a, "small")), B = c(u(a, "vertical")), w = x(l.value), $ = x(""), h = i({
      get: () => w.value,
      set: (_) => {
        w.value = _, y.value.length > 0 && _ >= 0 && _ < y.value.length ? $.value = y.value[_].buttonId : $.value = "", l.value = _;
      }
    }), S = x([]);
    ue(
      () => {
        var _;
        return (_ = o.default) == null ? void 0 : _.call(o);
      },
      () => {
        S.value = o.default === void 0 ? [] : Sa(o.default, "BTab").map((_, E) => {
          _.props || (_.props = {});
          const N = _.props["button-id"] || ot("tab"), R = _.props.id || ot(), oe = _.props["title-item-class"], U = _.props["title-link-attributes"];
          return {
            buttonId: N,
            contentId: R,
            disabled: _.props.disabled === "" || _.props.disabled === !0,
            target: `#${R}`,
            title: _.props.title,
            titleItemClass: oe,
            titleLinkAttributes: U,
            onClick: _.props.onClick,
            tab: _,
            tabComponent: () => Sa(o.default, "BTab")[E]
          };
        });
      },
      { immediate: !0 }
    );
    const y = i(
      () => S.value.map((_, E) => {
        const { tab: N } = _;
        N.props || (N.props = {});
        const R = h.value > -1 ? E === h.value : N.props.active === "";
        return {
          ..._,
          active: R,
          navItemClasses: [
            {
              active: R,
              disabled: N.props.disabled === "" || N.props.disabled === !0
            },
            R && a.activeNavItemClass ? a.activeNavItemClass : null,
            N.props["title-link-class"]
          ],
          tabClasses: [
            {
              fade: !p.value
            },
            R && a.activeTabClass ? a.activeTabClass : null
          ]
        };
      })
    ), C = i(() => !(y != null && y.value && y.value.length > 0)), O = i(() => ({
      "d-flex": B.value,
      "align-items-start": B.value
    })), k = Ht(u(a, "align")), I = i(() => ({
      "nav-pills": v.value,
      "flex-column me-3": B.value,
      [k.value]: a.align !== void 0,
      "nav-fill": s.value,
      "card-header-tabs": n.value,
      "nav-justified": d.value,
      "nav-tabs": !m.value && !v.value,
      small: b.value
    })), F = (_) => {
      let E = !1;
      if (_ !== void 0 && _ > -1 && _ < y.value.length && !y.value[_].disabled && (h.value < 0 || y.value[_].buttonId !== $.value)) {
        const N = new Qe("activate-tab", { cancelable: !0 });
        t("activate-tab", _, h.value, N), N.defaultPrevented || (h.value = _, E = !0);
      }
      return !E && l.value !== h.value && (l.value = h.value), E;
    }, L = (_, E) => {
      var N;
      F(E), E >= 0 && !y.value[E].disabled && ((N = y.value[E]) != null && N.onClick) && typeof y.value[E].onClick == "function" && y.value[E].onClick(_);
    };
    return F(w.value), ue(l, (_, E) => {
      if (_ === E)
        return;
      if (_ = Math.max(_, -1), E = Math.max(E, -1), y.value.length <= 0) {
        h.value = -1;
        return;
      }
      const N = _ > E;
      let R = _;
      const oe = y.value.length - 1;
      for (; R >= 0 && R <= oe && y.value[R].disabled; )
        R += N ? 1 : -1;
      if (R < 0) {
        F(0);
        return;
      }
      if (R >= y.value.length) {
        F(y.value.length - 1);
        return;
      }
      F(R);
    }), ue(y, () => {
      let _ = y.value.map((E) => E.active && !E.disabled).lastIndexOf(!0);
      _ < 0 && (h.value >= y.value.length ? _ = y.value.map((E) => !E.disabled).lastIndexOf(!0) : y.value[h.value] && !y.value[h.value].disabled && (_ = h.value)), _ < 0 && (_ = y.value.map((E) => !E.disabled).indexOf(!0)), y.value.forEach((E, N) => E.active = N === _), F(_);
    }), Xe(() => {
      if (h.value < 0 && y.value.length > 0 && !y.value.some((_) => _.active)) {
        const _ = y.value.map((E) => !E.disabled).indexOf(!0);
        F(_ >= 0 ? _ : -1);
      }
    }), Je(ho, {
      lazy: f,
      card: n
    }), (_, E) => (g(), M(ne(_.tag), {
      id: _.id,
      class: H(["tabs", O.value])
    }, {
      default: D(() => [
        T(r) ? (g(), V("div", {
          key: 0,
          class: H(["tab-content", _.contentClass])
        }, [
          (g(!0), V(pe, null, $e(y.value, ({ tabComponent: N, contentId: R, tabClasses: oe, active: U }, G) => (g(), M(ne(N()), {
            id: R,
            key: G,
            class: H(oe),
            active: U
          }, null, 8, ["id", "class", "active"]))), 128)),
          C.value ? (g(), V("div", {
            key: "bv-empty-tab",
            class: H(["tab-pane active", { "card-body": T(n) }])
          }, [
            A(_.$slots, "empty")
          ], 2)) : Q("", !0)
        ], 2)) : Q("", !0),
        Z("div", {
          class: H([_.navWrapperClass, { "card-header": T(n), "ms-auto": _.vertical && T(r) }])
        }, [
          Z("ul", {
            class: H(["nav", [I.value, _.navClass]]),
            role: "tablist"
          }, [
            A(_.$slots, "tabs-start"),
            (g(!0), V(pe, null, $e(y.value, ({ tab: N, buttonId: R, contentId: oe, navItemClasses: U, active: G, target: te }, ve) => {
              var ye, Be, ge;
              return g(), V("li", {
                key: ve,
                class: H(["nav-item", (ye = N == null ? void 0 : N.props) == null ? void 0 : ye["title-item-class"]]),
                role: "presentation"
              }, [
                Z("button", ae({
                  id: R,
                  class: ["nav-link", U],
                  "data-bs-toggle": "tab",
                  "data-bs-target": te,
                  role: "tab",
                  "aria-controls": oe,
                  "aria-selected": G
                }, (Be = N == null ? void 0 : N.props) == null ? void 0 : Be["title-link-attributes"], {
                  onClick: ct((be) => L(be, ve), ["stop", "prevent"])
                }), [
                  N.children && N.children.title ? (g(), M(ne(N.children.title), { key: 0 })) : (g(), V(pe, { key: 1 }, [
                    de(ee((ge = N == null ? void 0 : N.props) == null ? void 0 : ge.title), 1)
                  ], 64))
                ], 16, sf)
              ], 2);
            }), 128)),
            A(_.$slots, "tabs-end")
          ], 2)
        ], 2),
        T(r) ? Q("", !0) : (g(), V("div", {
          key: 1,
          class: H(["tab-content", _.contentClass])
        }, [
          (g(!0), V(pe, null, $e(y.value, ({ tabComponent: N, contentId: R, tabClasses: oe, active: U }, G) => (g(), M(ne(N()), {
            id: R,
            key: G,
            class: H(oe),
            active: U
          }, null, 8, ["id", "class", "active"]))), 128)),
          C.value ? (g(), V("div", {
            key: "bv-empty-tab",
            class: H(["tab-pane active", { "card-body": T(n) }])
          }, [
            A(_.$slots, "empty")
          ], 2)) : Q("", !0)
        ], 2))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), uf = /* @__PURE__ */ z({
  __name: "BTooltip",
  setup(e) {
    return (t, a) => (g(), M(Ya, { tooltip: "" }, so({ _: 2 }, [
      $e(t.$slots, (l, o) => ({
        name: o,
        fn: D((n) => [
          A(t.$slots, o, _e(Oe(n)))
        ])
      }))
    ]), 1024));
  }
}), df = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BAccordion: ti,
  BAccordionItem: ni,
  BAlert: vi,
  BAvatar: bi,
  BAvatarGroup: yi,
  BBadge: Si,
  BBreadcrumb: Ci,
  BBreadcrumbItem: dn,
  BButton: $t,
  BButtonGroup: Ti,
  BButtonToolbar: Vi,
  BCard: bn,
  BCardBody: mn,
  BCardFooter: gn,
  BCardGroup: Ei,
  BCardHeader: fn,
  BCardImg: sa,
  BCardSubtitle: pn,
  BCardText: Ii,
  BCardTitle: vn,
  BCarousel: Mi,
  BCarouselSlide: Wi,
  BCloseButton: Tt,
  BCol: At,
  BCollapse: un,
  BContainer: eu,
  BDropdown: Sn,
  BDropdownDivider: ou,
  BDropdownForm: uu,
  BDropdownGroup: fu,
  BDropdownHeader: gu,
  BDropdownItem: bu,
  BDropdownItemButton: hu,
  BDropdownText: wu,
  BForm: wn,
  BFormCheckbox: $n,
  BFormCheckboxGroup: Eu,
  BFormFloatingLabel: Cu,
  BFormGroup: Hu,
  BFormInput: qu,
  BFormInvalidFeedback: Pa,
  BFormRadio: kn,
  BFormRadioGroup: Ju,
  BFormRow: Xt,
  BFormSelect: ed,
  BFormSelectOption: Qa,
  BFormSelectOptionGroup: Cn,
  BFormSpinButton: Ac,
  BFormTag: Tn,
  BFormTags: md,
  BFormText: Oa,
  BFormTextarea: hd,
  BFormValidFeedback: Ea,
  BImg: Za,
  BInputGroup: Cd,
  BInputGroupAddon: el,
  BInputGroupAppend: Td,
  BInputGroupPrepend: Ad,
  BInputGroupText: An,
  BLink: ze,
  BListGroup: Vd,
  BListGroupItem: Pd,
  BModal: Fd,
  BNav: Ld,
  BNavForm: xd,
  BNavItem: Hd,
  BNavItemDropdown: Dd,
  BNavText: qd,
  BNavbar: Gd,
  BNavbarBrand: Kd,
  BNavbarNav: Xd,
  BNavbarToggle: tc,
  BOffcanvas: sc,
  BOverlay: Pn,
  BPagination: mc,
  BPlaceholder: Me,
  BPlaceholderButton: In,
  BPlaceholderCard: gc,
  BPlaceholderTable: bc,
  BPlaceholderWrapper: yc,
  BPopover: Ya,
  BProgress: Bc,
  BProgressBar: Fn,
  BRow: $c,
  BSpinner: va,
  BTab: nf,
  BTable: Kc,
  BTableSimple: al,
  BTabs: rf,
  BTbody: Xc,
  BTd: Zc,
  BTfoot: Qc,
  BTh: af,
  BThead: lf,
  BToast: Bn,
  BToastContainer: Va,
  BToastPlugin: Zi,
  BToaster: Va,
  BTooltip: uf,
  BTr: of,
  BTransition: Ct
}, Symbol.toStringTag, { value: "Module" })), cf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  vBColorMode: Jd,
  vBModal: Ia,
  vBPopover: Zd,
  vBToggle: Ia,
  vBTooltip: Qd
}, Symbol.toStringTag, { value: "Module" })), pf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createBreadcrumb: Yo,
  useBreadcrumb: Zo,
  useColorMode: Gr
}, Symbol.toStringTag, { value: "Module" })), mf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BvCarouselEvent: io,
  BvEvent: Qe,
  BvTriggerableEvent: zt
}, Symbol.toStringTag, { value: "Module" })), gf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), bf = {
  // TODO: use options in the future
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  install(e, t = {}) {
    Object.entries(df).forEach(([a, l]) => {
      e.component(a, l);
    }), Object.entries(cf).forEach(([a, l]) => {
      a.toLowerCase().startsWith("v") ? e.directive(a.slice(1), l) : e.directive(a, l);
    }), Yo(e);
  }
};
export {
  ti as BAccordion,
  ni as BAccordionItem,
  vi as BAlert,
  bi as BAvatar,
  yi as BAvatarGroup,
  Si as BBadge,
  Ci as BBreadcrumb,
  dn as BBreadcrumbItem,
  $t as BButton,
  Ti as BButtonGroup,
  Vi as BButtonToolbar,
  bn as BCard,
  mn as BCardBody,
  gn as BCardFooter,
  Ei as BCardGroup,
  fn as BCardHeader,
  sa as BCardImg,
  pn as BCardSubtitle,
  Ii as BCardText,
  vn as BCardTitle,
  Mi as BCarousel,
  Wi as BCarouselSlide,
  Tt as BCloseButton,
  At as BCol,
  un as BCollapse,
  eu as BContainer,
  Sn as BDropdown,
  ou as BDropdownDivider,
  uu as BDropdownForm,
  fu as BDropdownGroup,
  gu as BDropdownHeader,
  bu as BDropdownItem,
  hu as BDropdownItemButton,
  wu as BDropdownText,
  wn as BForm,
  $n as BFormCheckbox,
  Eu as BFormCheckboxGroup,
  Cu as BFormFloatingLabel,
  Hu as BFormGroup,
  qu as BFormInput,
  Pa as BFormInvalidFeedback,
  kn as BFormRadio,
  Ju as BFormRadioGroup,
  Xt as BFormRow,
  ed as BFormSelect,
  Qa as BFormSelectOption,
  Cn as BFormSelectOptionGroup,
  Ac as BFormSpinButton,
  Tn as BFormTag,
  md as BFormTags,
  Oa as BFormText,
  hd as BFormTextarea,
  Ea as BFormValidFeedback,
  Za as BImg,
  Cd as BInputGroup,
  el as BInputGroupAddon,
  Td as BInputGroupAppend,
  Ad as BInputGroupPrepend,
  An as BInputGroupText,
  ze as BLink,
  Vd as BListGroup,
  Pd as BListGroupItem,
  Fd as BModal,
  Ld as BNav,
  xd as BNavForm,
  Hd as BNavItem,
  Dd as BNavItemDropdown,
  qd as BNavText,
  Gd as BNavbar,
  Kd as BNavbarBrand,
  Xd as BNavbarNav,
  tc as BNavbarToggle,
  sc as BOffcanvas,
  Pn as BOverlay,
  mc as BPagination,
  Me as BPlaceholder,
  In as BPlaceholderButton,
  gc as BPlaceholderCard,
  bc as BPlaceholderTable,
  yc as BPlaceholderWrapper,
  Ya as BPopover,
  Bc as BProgress,
  Fn as BProgressBar,
  $c as BRow,
  va as BSpinner,
  nf as BTab,
  Kc as BTable,
  al as BTableSimple,
  rf as BTabs,
  Xc as BTbody,
  Zc as BTd,
  Qc as BTfoot,
  af as BTh,
  lf as BThead,
  Bn as BToast,
  Va as BToastContainer,
  Zi as BToastPlugin,
  Va as BToaster,
  uf as BTooltip,
  of as BTr,
  Ct as BTransition,
  bf as BootstrapVueNext,
  io as BvCarouselEvent,
  Qe as BvEvent,
  zt as BvTriggerableEvent,
  df as Components,
  pf as Composables,
  cf as Directives,
  gf as Types,
  mf as Utils,
  Yo as createBreadcrumb,
  bf as default,
  Zo as useBreadcrumb,
  Gr as useColorMode,
  hn as useToast,
  Jd as vBColorMode,
  Ia as vBModal,
  Zd as vBPopover,
  Ia as vBToggle,
  Qd as vBTooltip
};
//# sourceMappingURL=bootstrap-vue-next.mjs.map
