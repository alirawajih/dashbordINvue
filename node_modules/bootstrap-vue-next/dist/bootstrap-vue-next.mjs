var Fn = Object.defineProperty;
var Ln = (e, t, a) => t in e ? Fn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a;
var Te = (e, t, a) => (Ln(e, typeof t != "symbol" ? t + "" : t, a), a);
import { unref as s, computed as d, ref as M, shallowRef as Ia, watch as ce, getCurrentScope as Jl, onScopeDispose as Yl, shallowReadonly as mt, watchEffect as Oe, readonly as Ae, isRef as kt, getCurrentInstance as Fa, onMounted as Je, nextTick as Ce, reactive as dt, inject as We, toRef as u, onActivated as Nn, defineComponent as R, onBeforeUnmount as Zl, openBlock as g, createElementBlock as _, Fragment as ue, createElementVNode as X, renderSlot as x, normalizeProps as $e, guardReactiveProps as Ve, createBlock as D, Teleport as La, mergeProps as Q, normalizeClass as N, normalizeStyle as Le, createTextVNode as ne, toDisplayString as J, createCommentVNode as Y, createApp as zn, h as ie, provide as ot, resolveDynamicComponent as le, withCtx as j, createVNode as ye, Transition as Ql, useSlots as Ee, resolveComponent as eo, withModifiers as ct, renderList as Be, withKeys as Ot, withDirectives as nt, vShow as oa, isReactive as Rn, onUnmounted as Hn, useAttrs as to, vModelCheckbox as Mn, vModelRadio as Dn, vModelSelect as jn, createSlots as ao } from "vue";
const qn = (e) => typeof e == "boolean" || e === "" || e === "true" || e === "false", lo = (e) => typeof e == "boolean" ? e : e === "" ? !0 : e === "true";
class Ke {
  constructor(t, a = {}) {
    Te(this, "cancelable", !0);
    Te(this, "componentId", null);
    Te(this, "_defaultPrevented", !1);
    Te(this, "eventType", "");
    Te(this, "nativeEvent", null);
    Te(this, "_preventDefault");
    Te(this, "relatedTarget", null);
    Te(this, "target", null);
    if (!t)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    Object.assign(this, Ke.Defaults, a, { eventType: t }), this._preventDefault = function() {
      this.cancelable && (this.defaultPrevented = !0);
    };
  }
  // Readable by everyone,
  // But only overwritten by inherrited constructors
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  set defaultPrevented(t) {
    this._defaultPrevented = t;
  }
  // I think this is right
  // We want to be able to have it callable to everyone,
  // But only overwritten by inherrited constructors
  get preventDefault() {
    return this._preventDefault;
  }
  // This may not be correct, because it doesn't get correct type inferences in children
  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue
  set preventDefault(t) {
    this._preventDefault = t;
  }
  static get Defaults() {
    return {
      cancelable: !0,
      componentId: null,
      eventType: "",
      nativeEvent: null,
      relatedTarget: null,
      target: null
    };
  }
}
class It extends Ke {
  constructor(a, l = {}) {
    super(a, l);
    Te(this, "trigger", null);
    Object.assign(this, Ke.Defaults, l, { eventType: a });
  }
  static get Defaults() {
    return {
      ...super.Defaults,
      trigger: null
    };
  }
}
class oo extends Ke {
  constructor(a, l) {
    super(a, l);
    Te(this, "from");
    Te(this, "to");
    Te(this, "direction");
    Object.assign(this, Ke.Defaults, l, { eventType: a });
    const { from: o, direction: n, to: r } = l;
    this.from = o, this.to = r, this.direction = n;
  }
  static get Defaults() {
    return {
      ...super.Defaults
    };
  }
}
const ga = (e) => e !== null && typeof e == "object", no = (e) => /^[0-9]*\.?[0-9]+$/.test(String(e)), Gn = (e) => Object.prototype.toString.call(e) === "[object Object]", so = /_/g, io = /([a-z])([A-Z])/g, Wn = /(\s|^)(\w)/g, Un = /(\s|^)(\w)/, Dt = /\s+/, Xn = /^#/, Kn = /^#[A-Za-z]+[\w\-:.]*$/, Jn = /-u-.+/, qt = (e, t = 2) => typeof e == "string" ? e : e == null ? "" : Array.isArray(e) || Gn(e) && e.toString === Object.prototype.toString ? JSON.stringify(e, null, t) : String(e), Za = (e) => e.replace(so, " ").replace(io, (t, a, l) => `${a} ${l}`).replace(Un, (t, a, l) => a + l.toUpperCase()), Qa = (e) => e.replace(so, " ").replace(io, (t, a, l) => `${a} ${l}`).replace(Wn, (t, a, l) => a + l.toUpperCase()), Yn = (e) => {
  const t = e.trim();
  return t.charAt(0).toUpperCase() + t.slice(1);
}, va = (e) => `\\${e}`, Zn = (e) => {
  const t = qt(e), { length: a } = t, l = t.charCodeAt(0);
  return t.split("").reduce((o, n, r) => {
    const i = t.charCodeAt(r);
    return i === 0 ? `${o}ï¿½` : (
      // ... is U+007F OR
      i === 127 || // ... is in the range [\1-\1F] (U+0001 to U+001F) OR ...
      i >= 1 && i <= 31 || // ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...
      r === 0 && i >= 48 && i <= 57 || // ... is the second character and is in the range [0-9] (U+0030 to U+0039)
      // and the first character is a `-` (U+002D) ...
      r === 1 && i >= 48 && i <= 57 && l === 45 ? o + va(`${i.toString(16)} `) : (
        // ... is the first character AND ...
        r === 0 && // ... is a `-` (U+002D) AND ...
        i === 45 && // ... there is no second character ...
        a === 1 ? o + va(n) : (
          // ... is greater than or equal to U+0080 OR ...
          i >= 128 || // ... is `-` (U+002D) OR ...
          i === 45 || // ... is `_` (U+005F) OR ...
          i === 95 || // ... is in the range [0-9] (U+0030 to U+0039) OR ...
          i >= 48 && i <= 57 || // ... is in the range [A-Z] (U+0041 to U+005A) OR ...
          i >= 65 && i <= 90 || // ... is in the range [a-z] (U+0061 to U+007A) ...
          i >= 97 && i <= 122 ? o + n : o + va(n)
        )
      )
    );
  }, "");
}, ro = typeof window < "u", uo = typeof document < "u", Qn = typeof Element < "u", co = typeof navigator < "u", na = ro && uo && co, ut = ro ? window : {}, sa = uo ? document : {}, fo = co ? navigator : {}, es = (fo.userAgent || "").toLowerCase();
es.indexOf("jsdom") > 0;
(() => {
  let e = !1;
  if (na)
    try {
      const t = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          return e = !0, e;
        }
      };
      ut.addEventListener("test", t, t), ut.removeEventListener("test", t, t);
    } catch {
      e = !1;
    }
  return e;
})();
na && ("ontouchstart" in sa.documentElement || fo.maxTouchPoints > 0);
na && (ut.PointerEvent || ut.MSPointerEvent);
na && "IntersectionObserver" in ut && "IntersectionObserverEntry" in ut && // Edge 15 and UC Browser lack support for `isIntersecting`
// but we an use `intersectionRatio > 0` instead
// 'isIntersecting' in window.IntersectionObserverEntry.prototype &&
"intersectionRatio" in ut.IntersectionObserverEntry.prototype;
const Na = typeof window < "u", ts = typeof document < "u", as = typeof navigator < "u", za = Na && ts && as, el = Na ? window : {}, ls = (() => {
  let e = !1;
  if (za)
    try {
      const t = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          e = !0;
        }
      };
      el.addEventListener("test", t, t), el.removeEventListener("test", t, t);
    } catch {
      e = !1;
    }
  return e;
})(), Re = Qn ? Element.prototype : void 0, os = (Re == null ? void 0 : Re.matches) || (Re == null ? void 0 : Re.msMatchesSelector) || (Re == null ? void 0 : Re.webkitMatchesSelector), Ye = (e) => !!(e && e.nodeType === Node.ELEMENT_NODE), ns = (e) => Ye(e) ? e.getBoundingClientRect() : null, ss = (e = []) => {
  const { activeElement: t } = document;
  return t && !e.some((a) => a === t) ? t : null;
}, is = (e) => Ye(e) && e === ss(), rs = (e, t = {}) => {
  try {
    e.focus(t);
  } catch (a) {
    console.error(a);
  }
  return is(e);
}, us = (e, t) => t && Ye(e) && e.getAttribute(t) || null, ds = (e) => {
  if (us(e, "display") === "none")
    return !1;
  const t = ns(e);
  return !!(t && t.height > 0 && t.width > 0);
}, Pe = (e) => ((e == null ? void 0 : e()) ?? []).length === 0, vo = (e, t) => (Ye(t) ? t : sa).querySelector(e) || null, cs = (e, t) => Array.from([(Ye(t) ? t : sa).querySelectorAll(e)]), Ra = (e, t) => t && Ye(e) ? e.getAttribute(t) : null, fs = (e) => sa.getElementById(/^#/.test(e) ? e.slice(1) : e) || null, vs = (e, t, a) => {
  t && Ye(e) && e.setAttribute(t, a);
}, ms = (e, t) => {
  t && Ye(e) && e.removeAttribute(t);
}, ps = (e, t) => qt(e).toLowerCase() === qt(t).toLowerCase(), zt = Na ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || // Fallback, but not a true polyfill
// Only needed for Opera Mini
((e) => setTimeout(e, 16)) : (e) => setTimeout(e, 0), mo = (e, t) => Ye(e) ? os.call(e, t) : !1, gs = (Re == null ? void 0 : Re.closest) || function(e) {
  let t = this;
  if (!t)
    return null;
  do {
    if (mo(t, e))
      return t;
    t = t.parentElement || t.parentNode;
  } while (t !== null && t.nodeType === Node.ELEMENT_NODE);
  return null;
}, tl = (e, t, a = !1) => {
  if (!Ye(t))
    return null;
  const l = gs.call(t, e);
  return a ? l : l === t ? null : l;
}, ia = (e, t, a) => t.concat(["sm", "md", "lg", "xl", "xxl"]).reduce((l, o) => (l[e ? `${e}${o.charAt(0).toUpperCase() + o.slice(1)}` : o] = a, l), /* @__PURE__ */ Object.create(null)), po = (e, t, a, l = a) => Object.keys(t).reduce((o, n) => (e[n] && o.push(
  [l, n.replace(a, ""), e[n]].filter((r) => r && typeof r != "boolean").join("-").toLowerCase()
), o), []), et = (e = "") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`, Pt = (e) => !!(e.href || e.to), Me = (e, t = {}, a = {}) => {
  const l = [e];
  let o;
  for (let n = 0; n < l.length && !o; n++) {
    const r = l[n];
    o = a[r];
  }
  return o && typeof o == "function" ? o(t) : o;
}, tt = (e, t = NaN) => Number.isInteger(e) ? e : t, bs = (e, t = NaN) => {
  const a = Number.parseInt(e, 10);
  return Number.isNaN(a) ? t : a;
}, xt = (e, t = NaN) => {
  const a = Number.parseFloat(e.toString());
  return Number.isNaN(a) ? t : a;
}, Ft = (e, t) => Object.keys(e).filter((a) => !t.includes(a)).reduce((a, l) => ({ ...a, [l]: e[l] }), {}), Gt = (e) => Array.isArray(e) ? e.map((t) => Gt(t)) : e instanceof Date ? new Date(e.getTime()) : e && typeof e == "object" ? Object.getOwnPropertyNames(e).reduce((t, a) => (Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(e, a) ?? {}), t[a] = Gt(e[a]), t), Object.create(Object.getPrototypeOf(e))) : e, ba = (e) => new Promise((t) => t(Gt(e))), al = (e, t) => t + (e ? Yn(e) : ""), Ha = (e, t) => (Array.isArray(t) ? t.slice() : Object.keys(t)).reduce(
  (a, l) => (a[l] = e[l], a),
  {}
), ra = (e, t) => e === !0 || e === "true" || e === "" ? "true" : e === "grammar" || e === "spelling" ? e : t === !1 ? "true" : e === !1 || e === "false" ? "false" : void 0, go = Symbol("carousel"), bo = Symbol("tabs"), ho = Symbol("breadcrumb"), yo = Symbol("progress"), Bo = Symbol("listGroup"), $o = Symbol("avatarGroup"), wo = Symbol("accordion"), ko = Symbol("checkboxGroup"), So = Symbol("radioGroup"), ha = (e, t) => ((e == null ? void 0 : e()) ?? []).reduce((a, l) => (typeof l.type == "symbol" ? a = a.concat(l.children) : a.push(l), a), []).filter((a) => {
  var l;
  return ((l = a.type) == null ? void 0 : l.__name) === t;
});
function Lt(e) {
  return e.split("-")[1];
}
function Ma(e) {
  return e === "y" ? "height" : "width";
}
function Ze(e) {
  return e.split("-")[0];
}
function St(e) {
  return ["top", "bottom"].includes(Ze(e)) ? "x" : "y";
}
function ll(e, t, a) {
  let { reference: l, floating: o } = e;
  const n = l.x + l.width / 2 - o.width / 2, r = l.y + l.height / 2 - o.height / 2, i = St(t), f = Ma(i), p = l[f] / 2 - o[f] / 2, y = i === "x";
  let b;
  switch (Ze(t)) {
    case "top":
      b = { x: n, y: l.y - o.height };
      break;
    case "bottom":
      b = { x: n, y: l.y + l.height };
      break;
    case "right":
      b = { x: l.x + l.width, y: r };
      break;
    case "left":
      b = { x: l.x - o.width, y: r };
      break;
    default:
      b = { x: l.x, y: l.y };
  }
  switch (Lt(t)) {
    case "start":
      b[i] -= p * (a && y ? -1 : 1);
      break;
    case "end":
      b[i] += p * (a && y ? -1 : 1);
  }
  return b;
}
const hs = async (e, t, a) => {
  const { placement: l = "bottom", strategy: o = "absolute", middleware: n = [], platform: r } = a, i = n.filter(Boolean), f = await (r.isRTL == null ? void 0 : r.isRTL(t));
  let p = await r.getElementRects({ reference: e, floating: t, strategy: o }), { x: y, y: b } = ll(p, l, f), m = l, h = {}, $ = 0;
  for (let v = 0; v < i.length; v++) {
    const { name: k, fn: w } = i[v], { x: B, y: T, data: O, reset: A } = await w({ x: y, y: b, initialPlacement: l, placement: m, strategy: o, middlewareData: h, rects: p, platform: r, elements: { reference: e, floating: t } });
    y = B ?? y, b = T ?? b, h = { ...h, [k]: { ...h[k], ...O } }, A && $ <= 50 && ($++, typeof A == "object" && (A.placement && (m = A.placement), A.rects && (p = A.rects === !0 ? await r.getElementRects({ reference: e, floating: t, strategy: o }) : A.rects), { x: y, y: b } = ll(p, m, f)), v = -1);
  }
  return { x: y, y: b, placement: m, strategy: o, middlewareData: h };
};
function Da(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function $t(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function Wt(e, t) {
  var a;
  t === void 0 && (t = {});
  const { x: l, y: o, platform: n, rects: r, elements: i, strategy: f } = e, { boundary: p = "clippingAncestors", rootBoundary: y = "viewport", elementContext: b = "floating", altBoundary: m = !1, padding: h = 0 } = t, $ = Da(h), v = i[m ? b === "floating" ? "reference" : "floating" : b], k = $t(await n.getClippingRect({ element: (a = await (n.isElement == null ? void 0 : n.isElement(v))) == null || a ? v : v.contextElement || await (n.getDocumentElement == null ? void 0 : n.getDocumentElement(i.floating)), boundary: p, rootBoundary: y, strategy: f })), w = b === "floating" ? { ...r.floating, x: l, y: o } : r.reference, B = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(i.floating)), T = await (n.isElement == null ? void 0 : n.isElement(B)) && await (n.getScale == null ? void 0 : n.getScale(B)) || { x: 1, y: 1 }, O = $t(n.convertOffsetParentRelativeRectToViewportRelativeRect ? await n.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: w, offsetParent: B, strategy: f }) : w);
  return { top: (k.top - O.top + $.top) / T.y, bottom: (O.bottom - k.bottom + $.bottom) / T.y, left: (k.left - O.left + $.left) / T.x, right: (O.right - k.right + $.right) / T.x };
}
const Ut = Math.min, Xt = Math.max;
function ya(e, t, a) {
  return Xt(e, Ut(t, a));
}
const ys = (e) => ({ name: "arrow", options: e, async fn(t) {
  const { element: a, padding: l = 0 } = e || {}, { x: o, y: n, placement: r, rects: i, platform: f, elements: p } = t;
  if (a == null)
    return {};
  const y = Da(l), b = { x: o, y: n }, m = St(r), h = Ma(m), $ = await f.getDimensions(a), v = m === "y", k = v ? "top" : "left", w = v ? "bottom" : "right", B = v ? "clientHeight" : "clientWidth", T = i.reference[h] + i.reference[m] - b[m] - i.floating[h], O = b[m] - i.reference[m], A = await (f.getOffsetParent == null ? void 0 : f.getOffsetParent(a));
  let S = A ? A[B] : 0;
  S && await (f.isElement == null ? void 0 : f.isElement(A)) || (S = p.floating[B] || i.floating[h]);
  const V = T / 2 - O / 2, I = y[k], C = S - $[h] - y[w], F = S / 2 - $[h] / 2 + V, E = ya(I, F, C), U = Lt(r) != null && F != E && i.reference[h] / 2 - (F < I ? y[k] : y[w]) - $[h] / 2 < 0;
  return { [m]: b[m] - (U ? F < I ? I - F : C - F : 0), data: { [m]: E, centerOffset: F - E } };
} }), Co = ["top", "right", "bottom", "left"];
Co.reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
const Bs = { left: "right", right: "left", bottom: "top", top: "bottom" };
function Kt(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Bs[t]);
}
function $s(e, t, a) {
  a === void 0 && (a = !1);
  const l = Lt(e), o = St(e), n = Ma(o);
  let r = o === "x" ? l === (a ? "end" : "start") ? "right" : "left" : l === "start" ? "bottom" : "top";
  return t.reference[n] > t.floating[n] && (r = Kt(r)), { main: r, cross: Kt(r) };
}
const ws = { start: "end", end: "start" };
function ma(e) {
  return e.replace(/start|end/g, (t) => ws[t]);
}
const To = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var a;
    const { placement: l, middlewareData: o, rects: n, initialPlacement: r, platform: i, elements: f } = t, { mainAxis: p = !0, crossAxis: y = !0, fallbackPlacements: b, fallbackStrategy: m = "bestFit", fallbackAxisSideDirection: h = "none", flipAlignment: $ = !0, ...v } = e, k = Ze(l), w = Ze(r) === r, B = await (i.isRTL == null ? void 0 : i.isRTL(f.floating)), T = b || (w || !$ ? [Kt(r)] : function(E) {
      const U = Kt(E);
      return [ma(E), U, ma(U)];
    }(r));
    b || h === "none" || T.push(...function(E, U, q, ae) {
      const Z = Lt(E);
      let G = function(te, fe, pe) {
        const be = ["left", "right"], oe = ["right", "left"], de = ["top", "bottom"], L = ["bottom", "top"];
        switch (te) {
          case "top":
          case "bottom":
            return pe ? fe ? oe : be : fe ? be : oe;
          case "left":
          case "right":
            return fe ? de : L;
          default:
            return [];
        }
      }(Ze(E), q === "start", ae);
      return Z && (G = G.map((te) => te + "-" + Z), U && (G = G.concat(G.map(ma)))), G;
    }(r, $, h, B));
    const O = [r, ...T], A = await Wt(t, v), S = [];
    let V = ((a = o.flip) == null ? void 0 : a.overflows) || [];
    if (p && S.push(A[k]), y) {
      const { main: E, cross: U } = $s(l, n, B);
      S.push(A[E], A[U]);
    }
    if (V = [...V, { placement: l, overflows: S }], !S.every((E) => E <= 0)) {
      var I, C;
      const E = (((I = o.flip) == null ? void 0 : I.index) || 0) + 1, U = O[E];
      if (U)
        return { data: { index: E, overflows: V }, reset: { placement: U } };
      let q = (C = V.filter((ae) => ae.overflows[0] <= 0).sort((ae, Z) => ae.overflows[1] - Z.overflows[1])[0]) == null ? void 0 : C.placement;
      if (!q)
        switch (m) {
          case "bestFit": {
            var F;
            const ae = (F = V.map((Z) => [Z.placement, Z.overflows.filter((G) => G > 0).reduce((G, te) => G + te, 0)]).sort((Z, G) => Z[1] - G[1])[0]) == null ? void 0 : F[0];
            ae && (q = ae);
            break;
          }
          case "initialPlacement":
            q = r;
        }
      if (l !== q)
        return { reset: { placement: q } };
    }
    return {};
  } };
};
function ol(e, t) {
  return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width };
}
function nl(e) {
  return Co.some((t) => e[t] >= 0);
}
const ks = function(e) {
  return e === void 0 && (e = {}), { name: "hide", options: e, async fn(t) {
    const { strategy: a = "referenceHidden", ...l } = e, { rects: o } = t;
    switch (a) {
      case "referenceHidden": {
        const n = ol(await Wt(t, { ...l, elementContext: "reference" }), o.reference);
        return { data: { referenceHiddenOffsets: n, referenceHidden: nl(n) } };
      }
      case "escaped": {
        const n = ol(await Wt(t, { ...l, altBoundary: !0 }), o.floating);
        return { data: { escapedOffsets: n, escaped: nl(n) } };
      }
      default:
        return {};
    }
  } };
};
function sl(e) {
  const t = Ut(...e.map((l) => l.left)), a = Ut(...e.map((l) => l.top));
  return { x: t, y: a, width: Xt(...e.map((l) => l.right)) - t, height: Xt(...e.map((l) => l.bottom)) - a };
}
const Ss = function(e) {
  return e === void 0 && (e = {}), { name: "inline", options: e, async fn(t) {
    const { placement: a, elements: l, rects: o, platform: n, strategy: r } = t, { padding: i = 2, x: f, y: p } = e, y = Array.from(await (n.getClientRects == null ? void 0 : n.getClientRects(l.reference)) || []), b = function(v) {
      const k = v.slice().sort((T, O) => T.y - O.y), w = [];
      let B = null;
      for (let T = 0; T < k.length; T++) {
        const O = k[T];
        !B || O.y - B.y > B.height / 2 ? w.push([O]) : w[w.length - 1].push(O), B = O;
      }
      return w.map((T) => $t(sl(T)));
    }(y), m = $t(sl(y)), h = Da(i), $ = await n.getElementRects({ reference: { getBoundingClientRect: function() {
      if (b.length === 2 && b[0].left > b[1].right && f != null && p != null)
        return b.find((v) => f > v.left - h.left && f < v.right + h.right && p > v.top - h.top && p < v.bottom + h.bottom) || m;
      if (b.length >= 2) {
        if (St(a) === "x") {
          const A = b[0], S = b[b.length - 1], V = Ze(a) === "top", I = A.top, C = S.bottom, F = V ? A.left : S.left, E = V ? A.right : S.right;
          return { top: I, bottom: C, left: F, right: E, width: E - F, height: C - I, x: F, y: I };
        }
        const v = Ze(a) === "left", k = Xt(...b.map((A) => A.right)), w = Ut(...b.map((A) => A.left)), B = b.filter((A) => v ? A.left === w : A.right === k), T = B[0].top, O = B[B.length - 1].bottom;
        return { top: T, bottom: O, left: w, right: k, width: k - w, height: O - T, x: w, y: T };
      }
      return m;
    } }, floating: l.floating, strategy: r });
    return o.reference.x !== $.reference.x || o.reference.y !== $.reference.y || o.reference.width !== $.reference.width || o.reference.height !== $.reference.height ? { reset: { rects: $ } } : {};
  } };
}, _o = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: a, y: l } = t, o = await async function(n, r) {
      const { placement: i, platform: f, elements: p } = n, y = await (f.isRTL == null ? void 0 : f.isRTL(p.floating)), b = Ze(i), m = Lt(i), h = St(i) === "x", $ = ["left", "top"].includes(b) ? -1 : 1, v = y && h ? -1 : 1, k = typeof r == "function" ? r(n) : r;
      let { mainAxis: w, crossAxis: B, alignmentAxis: T } = typeof k == "number" ? { mainAxis: k, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...k };
      return m && typeof T == "number" && (B = m === "end" ? -1 * T : T), h ? { x: B * v, y: w * $ } : { x: w * $, y: B * v };
    }(t, e);
    return { x: a + o.x, y: l + o.y, data: o };
  } };
};
function Cs(e) {
  return e === "x" ? "y" : "x";
}
const xo = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: a, y: l, placement: o } = t, { mainAxis: n = !0, crossAxis: r = !1, limiter: i = { fn: (k) => {
      let { x: w, y: B } = k;
      return { x: w, y: B };
    } }, ...f } = e, p = { x: a, y: l }, y = await Wt(t, f), b = St(Ze(o)), m = Cs(b);
    let h = p[b], $ = p[m];
    if (n) {
      const k = b === "y" ? "bottom" : "right";
      h = ya(h + y[b === "y" ? "top" : "left"], h, h - y[k]);
    }
    if (r) {
      const k = m === "y" ? "bottom" : "right";
      $ = ya($ + y[m === "y" ? "top" : "left"], $, $ - y[k]);
    }
    const v = i.fn({ ...t, [b]: h, [m]: $ });
    return { ...v, data: { x: v.x - a, y: v.y - l } };
  } };
};
function Fe(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Xe(e) {
  return Fe(e).getComputedStyle(e);
}
function Ao(e) {
  return e instanceof Fe(e).Node;
}
function lt(e) {
  return Ao(e) ? (e.nodeName || "").toLowerCase() : "";
}
let Rt;
function Vo() {
  if (Rt)
    return Rt;
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? (Rt = e.brands.map((t) => t.brand + "/" + t.version).join(" "), Rt) : navigator.userAgent;
}
function Ge(e) {
  return e instanceof Fe(e).HTMLElement;
}
function qe(e) {
  return e instanceof Fe(e).Element;
}
function il(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof Fe(e).ShadowRoot || e instanceof ShadowRoot;
}
function ua(e) {
  const { overflow: t, overflowX: a, overflowY: l, display: o } = Xe(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + l + a) && !["inline", "contents"].includes(o);
}
function Ts(e) {
  return ["table", "td", "th"].includes(lt(e));
}
function Ba(e) {
  const t = /firefox/i.test(Vo()), a = Xe(e), l = a.backdropFilter || a.WebkitBackdropFilter;
  return a.transform !== "none" || a.perspective !== "none" || !!l && l !== "none" || t && a.willChange === "filter" || t && !!a.filter && a.filter !== "none" || ["transform", "perspective"].some((o) => a.willChange.includes(o)) || ["paint", "layout", "strict", "content"].some((o) => {
    const n = a.contain;
    return n != null && n.includes(o);
  });
}
function $a() {
  return /^((?!chrome|android).)*safari/i.test(Vo());
}
function ja(e) {
  return ["html", "body", "#document"].includes(lt(e));
}
const rl = Math.min, At = Math.max, Jt = Math.round;
function Oo(e) {
  const t = Xe(e);
  let a = parseFloat(t.width), l = parseFloat(t.height);
  const o = Ge(e), n = o ? e.offsetWidth : a, r = o ? e.offsetHeight : l, i = Jt(a) !== n || Jt(l) !== r;
  return i && (a = n, l = r), { width: a, height: l, fallback: i };
}
function Po(e) {
  return qe(e) ? e : e.contextElement;
}
const Eo = { x: 1, y: 1 };
function Bt(e) {
  const t = Po(e);
  if (!Ge(t))
    return Eo;
  const a = t.getBoundingClientRect(), { width: l, height: o, fallback: n } = Oo(t);
  let r = (n ? Jt(a.width) : a.width) / l, i = (n ? Jt(a.height) : a.height) / o;
  return r && Number.isFinite(r) || (r = 1), i && Number.isFinite(i) || (i = 1), { x: r, y: i };
}
function ft(e, t, a, l) {
  var o, n;
  t === void 0 && (t = !1), a === void 0 && (a = !1);
  const r = e.getBoundingClientRect(), i = Po(e);
  let f = Eo;
  t && (l ? qe(l) && (f = Bt(l)) : f = Bt(e));
  const p = i ? Fe(i) : window, y = $a() && a;
  let b = (r.left + (y && ((o = p.visualViewport) == null ? void 0 : o.offsetLeft) || 0)) / f.x, m = (r.top + (y && ((n = p.visualViewport) == null ? void 0 : n.offsetTop) || 0)) / f.y, h = r.width / f.x, $ = r.height / f.y;
  if (i) {
    const v = Fe(i), k = l && qe(l) ? Fe(l) : l;
    let w = v.frameElement;
    for (; w && l && k !== v; ) {
      const B = Bt(w), T = w.getBoundingClientRect(), O = getComputedStyle(w);
      T.x += (w.clientLeft + parseFloat(O.paddingLeft)) * B.x, T.y += (w.clientTop + parseFloat(O.paddingTop)) * B.y, b *= B.x, m *= B.y, h *= B.x, $ *= B.y, b += T.x, m += T.y, w = Fe(w).frameElement;
    }
  }
  return $t({ width: h, height: $, x: b, y: m });
}
function at(e) {
  return ((Ao(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function da(e) {
  return qe(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function Io(e) {
  return ft(at(e)).left + da(e).scrollLeft;
}
function Et(e) {
  if (lt(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || il(e) && e.host || at(e);
  return il(t) ? t.host : t;
}
function Fo(e) {
  const t = Et(e);
  return ja(t) ? t.ownerDocument.body : Ge(t) && ua(t) ? t : Fo(t);
}
function Vt(e, t) {
  var a;
  t === void 0 && (t = []);
  const l = Fo(e), o = l === ((a = e.ownerDocument) == null ? void 0 : a.body), n = Fe(l);
  return o ? t.concat(n, n.visualViewport || [], ua(l) ? l : []) : t.concat(l, Vt(l));
}
function ul(e, t, a) {
  let l;
  if (t === "viewport")
    l = function(r, i) {
      const f = Fe(r), p = at(r), y = f.visualViewport;
      let b = p.clientWidth, m = p.clientHeight, h = 0, $ = 0;
      if (y) {
        b = y.width, m = y.height;
        const v = $a();
        (!v || v && i === "fixed") && (h = y.offsetLeft, $ = y.offsetTop);
      }
      return { width: b, height: m, x: h, y: $ };
    }(e, a);
  else if (t === "document")
    l = function(r) {
      const i = at(r), f = da(r), p = r.ownerDocument.body, y = At(i.scrollWidth, i.clientWidth, p.scrollWidth, p.clientWidth), b = At(i.scrollHeight, i.clientHeight, p.scrollHeight, p.clientHeight);
      let m = -f.scrollLeft + Io(r);
      const h = -f.scrollTop;
      return Xe(p).direction === "rtl" && (m += At(i.clientWidth, p.clientWidth) - y), { width: y, height: b, x: m, y: h };
    }(at(e));
  else if (qe(t))
    l = function(r, i) {
      const f = ft(r, !0, i === "fixed"), p = f.top + r.clientTop, y = f.left + r.clientLeft, b = Ge(r) ? Bt(r) : { x: 1, y: 1 };
      return { width: r.clientWidth * b.x, height: r.clientHeight * b.y, x: y * b.x, y: p * b.y };
    }(t, a);
  else {
    const r = { ...t };
    if ($a()) {
      var o, n;
      const i = Fe(e);
      r.x -= ((o = i.visualViewport) == null ? void 0 : o.offsetLeft) || 0, r.y -= ((n = i.visualViewport) == null ? void 0 : n.offsetTop) || 0;
    }
    l = r;
  }
  return $t(l);
}
function dl(e, t) {
  return Ge(e) && Xe(e).position !== "fixed" ? t ? t(e) : e.offsetParent : null;
}
function cl(e, t) {
  const a = Fe(e);
  if (!Ge(e))
    return a;
  let l = dl(e, t);
  for (; l && Ts(l) && Xe(l).position === "static"; )
    l = dl(l, t);
  return l && (lt(l) === "html" || lt(l) === "body" && Xe(l).position === "static" && !Ba(l)) ? a : l || function(o) {
    let n = Et(o);
    for (; Ge(n) && !ja(n); ) {
      if (Ba(n))
        return n;
      n = Et(n);
    }
    return null;
  }(e) || a;
}
function _s(e, t, a) {
  const l = Ge(t), o = at(t), n = ft(e, !0, a === "fixed", t);
  let r = { scrollLeft: 0, scrollTop: 0 };
  const i = { x: 0, y: 0 };
  if (l || !l && a !== "fixed")
    if ((lt(t) !== "body" || ua(o)) && (r = da(t)), Ge(t)) {
      const f = ft(t, !0);
      i.x = f.x + t.clientLeft, i.y = f.y + t.clientTop;
    } else
      o && (i.x = Io(o));
  return { x: n.left + r.scrollLeft - i.x, y: n.top + r.scrollTop - i.y, width: n.width, height: n.height };
}
const xs = { getClippingRect: function(e) {
  let { element: t, boundary: a, rootBoundary: l, strategy: o } = e;
  const n = a === "clippingAncestors" ? function(p, y) {
    const b = y.get(p);
    if (b)
      return b;
    let m = Vt(p).filter((k) => qe(k) && lt(k) !== "body"), h = null;
    const $ = Xe(p).position === "fixed";
    let v = $ ? Et(p) : p;
    for (; qe(v) && !ja(v); ) {
      const k = Xe(v), w = Ba(v);
      k.position === "fixed" && (h = null), ($ ? w || h : w || k.position !== "static" || !h || !["absolute", "fixed"].includes(h.position)) ? h = k : m = m.filter((B) => B !== v), v = Et(v);
    }
    return y.set(p, m), m;
  }(t, this._c) : [].concat(a), r = [...n, l], i = r[0], f = r.reduce((p, y) => {
    const b = ul(t, y, o);
    return p.top = At(b.top, p.top), p.right = rl(b.right, p.right), p.bottom = rl(b.bottom, p.bottom), p.left = At(b.left, p.left), p;
  }, ul(t, i, o));
  return { width: f.right - f.left, height: f.bottom - f.top, x: f.left, y: f.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: a, strategy: l } = e;
  const o = Ge(a), n = at(a);
  if (a === n)
    return t;
  let r = { scrollLeft: 0, scrollTop: 0 }, i = { x: 1, y: 1 };
  const f = { x: 0, y: 0 };
  if ((o || !o && l !== "fixed") && ((lt(a) !== "body" || ua(n)) && (r = da(a)), Ge(a))) {
    const p = ft(a);
    i = Bt(a), f.x = p.x + a.clientLeft, f.y = p.y + a.clientTop;
  }
  return { width: t.width * i.x, height: t.height * i.y, x: t.x * i.x - r.scrollLeft * i.x + f.x, y: t.y * i.y - r.scrollTop * i.y + f.y };
}, isElement: qe, getDimensions: function(e) {
  return Oo(e);
}, getOffsetParent: cl, getDocumentElement: at, getScale: Bt, async getElementRects(e) {
  let { reference: t, floating: a, strategy: l } = e;
  const o = this.getOffsetParent || cl, n = this.getDimensions;
  return { reference: _s(t, await o(a), l), floating: { x: 0, y: 0, ...await n(a) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => Xe(e).direction === "rtl" };
function As(e, t, a, l) {
  l === void 0 && (l = {});
  const { ancestorScroll: o = !0, ancestorResize: n = !0, elementResize: r = !0, animationFrame: i = !1 } = l, f = o && !i, p = f || n ? [...qe(e) ? Vt(e) : e.contextElement ? Vt(e.contextElement) : [], ...Vt(t)] : [];
  p.forEach((h) => {
    f && h.addEventListener("scroll", a, { passive: !0 }), n && h.addEventListener("resize", a);
  });
  let y, b = null;
  r && (b = new ResizeObserver(() => {
    a();
  }), qe(e) && !i && b.observe(e), qe(e) || !e.contextElement || i || b.observe(e.contextElement), b.observe(t));
  let m = i ? ft(e) : null;
  return i && function h() {
    const $ = ft(e);
    !m || $.x === m.x && $.y === m.y && $.width === m.width && $.height === m.height || a(), m = $, y = requestAnimationFrame(h);
  }(), a(), () => {
    var h;
    p.forEach(($) => {
      f && $.removeEventListener("scroll", a), n && $.removeEventListener("resize", a);
    }), (h = b) == null || h.disconnect(), b = null, i && cancelAnimationFrame(y);
  };
}
const Vs = (e, t, a) => {
  const l = /* @__PURE__ */ new Map(), o = { platform: xs, ...a }, n = { ...o.platform, _c: l };
  return hs(e, t, { ...o, platform: n });
};
function wa(e) {
  var t;
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
function Os(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const a = wa(s(e.element));
      return a == null ? {} : ys({
        element: a,
        padding: e.padding
      }).fn(t);
    }
  };
}
function Lo(e, t, a) {
  a === void 0 && (a = {});
  const l = a.whileElementsMounted, o = d(() => {
    var A;
    return (A = s(a.open)) != null ? A : !0;
  }), n = d(() => s(a.middleware)), r = d(() => {
    var A;
    return (A = s(a.placement)) != null ? A : "bottom";
  }), i = d(() => {
    var A;
    return (A = s(a.strategy)) != null ? A : "absolute";
  }), f = d(() => wa(e.value)), p = d(() => wa(t.value)), y = M(null), b = M(null), m = M(i.value), h = M(r.value), $ = Ia({}), v = M(!1);
  let k;
  function w() {
    f.value == null || p.value == null || Vs(f.value, p.value, {
      middleware: n.value,
      placement: r.value,
      strategy: i.value
    }).then((A) => {
      y.value = A.x, b.value = A.y, m.value = A.strategy, h.value = A.placement, $.value = A.middlewareData, v.value = !0;
    });
  }
  function B() {
    typeof k == "function" && (k(), k = void 0);
  }
  function T() {
    if (B(), l === void 0) {
      w();
      return;
    }
    if (f.value != null && p.value != null) {
      k = l(f.value, p.value, w);
      return;
    }
  }
  function O() {
    o.value || (v.value = !1);
  }
  return ce([n, r, i], w, {
    flush: "sync"
  }), ce([f, p], T, {
    flush: "sync"
  }), ce(o, O, {
    flush: "sync"
  }), Jl() && Yl(B), {
    x: mt(y),
    y: mt(b),
    strategy: mt(m),
    placement: mt(h),
    middlewareData: mt($),
    isPositioned: mt(v),
    update: w
  };
}
const Ps = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), Es = /^aria-[\w-]*$/i, Is = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Fs = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, Ls = (e, t) => {
  const a = e.nodeName.toLowerCase();
  return t.includes(a) ? Ps.has(a) ? !!(Is.test(e.nodeValue || "") || Fs.test(e.nodeValue || "")) : !0 : t.filter((l) => l instanceof RegExp).some((l) => l.test(a));
}, bt = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", Es],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
}, ht = (e, t, a) => {
  if (!e.length)
    return e;
  if (a && typeof a == "function")
    return a(e);
  const o = new window.DOMParser().parseFromString(e, "text/html"), n = o.body.querySelectorAll("*");
  for (const r of n) {
    const i = r.nodeName.toLowerCase();
    if (!Object.keys(t).includes(i)) {
      r.remove();
      continue;
    }
    const f = r.attributes, p = [...t["*"] || [], ...t[i] || []];
    for (const y of f)
      Ls(y, p) || r.removeAttribute(y.nodeName);
  }
  return o.body.innerHTML;
};
var Ns = Object.defineProperty, zs = Object.defineProperties, Rs = Object.getOwnPropertyDescriptors, fl = Object.getOwnPropertySymbols, Hs = Object.prototype.hasOwnProperty, Ms = Object.prototype.propertyIsEnumerable, vl = (e, t, a) => t in e ? Ns(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, Ds = (e, t) => {
  for (var a in t || (t = {}))
    Hs.call(t, a) && vl(e, a, t[a]);
  if (fl)
    for (var a of fl(t))
      Ms.call(t, a) && vl(e, a, t[a]);
  return e;
}, js = (e, t) => zs(e, Rs(t));
function No(e, t) {
  var a;
  const l = Ia();
  return Oe(() => {
    l.value = e();
  }, js(Ds({}, t), {
    flush: (a = t == null ? void 0 : t.flush) != null ? a : "sync"
  })), Ae(l);
}
var ml;
const Yt = typeof window < "u", qs = (e) => typeof e < "u", qa = (e) => typeof e == "function", Gs = (e) => typeof e == "string", Zt = () => {
}, Ws = Yt && ((ml = window == null ? void 0 : window.navigator) == null ? void 0 : ml.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function Se(e) {
  return typeof e == "function" ? e() : s(e);
}
function Us(e, t) {
  function a(...l) {
    return new Promise((o, n) => {
      Promise.resolve(e(() => t.apply(this, l), { fn: t, thisArg: this, args: l })).then(o).catch(n);
    });
  }
  return a;
}
const zo = (e) => e();
function Xs(e = zo) {
  const t = M(!0);
  function a() {
    t.value = !1;
  }
  function l() {
    t.value = !0;
  }
  const o = (...n) => {
    t.value && e(...n);
  };
  return { isActive: Ae(t), pause: a, resume: l, eventFilter: o };
}
function Ks(e) {
  return e;
}
function Qt(e) {
  return Jl() ? (Yl(e), !0) : !1;
}
function Js(e) {
  return typeof e == "function" ? d(e) : M(e);
}
function Ro(e, t = !0) {
  Fa() ? Je(e) : t ? e() : Ce(e);
}
function Ho(e, t = 1e3, a = {}) {
  const {
    immediate: l = !0,
    immediateCallback: o = !1
  } = a;
  let n = null;
  const r = M(!1);
  function i() {
    n && (clearInterval(n), n = null);
  }
  function f() {
    r.value = !1, i();
  }
  function p() {
    const y = Se(t);
    y <= 0 || (r.value = !0, o && e(), i(), n = setInterval(e, y));
  }
  if (l && Yt && p(), kt(t) || qa(t)) {
    const y = ce(t, () => {
      r.value && Yt && p();
    });
    Qt(y);
  }
  return Qt(f), {
    isActive: r,
    pause: f,
    resume: p
  };
}
function yt(e, t = {}) {
  const {
    method: a = "parseFloat",
    radix: l,
    nanToZero: o
  } = t;
  return d(() => {
    let n = Se(e);
    return typeof n == "string" && (n = Number[a](n, l)), o && isNaN(n) && (n = 0), n;
  });
}
var pl = Object.getOwnPropertySymbols, Ys = Object.prototype.hasOwnProperty, Zs = Object.prototype.propertyIsEnumerable, Qs = (e, t) => {
  var a = {};
  for (var l in e)
    Ys.call(e, l) && t.indexOf(l) < 0 && (a[l] = e[l]);
  if (e != null && pl)
    for (var l of pl(e))
      t.indexOf(l) < 0 && Zs.call(e, l) && (a[l] = e[l]);
  return a;
};
function ei(e, t, a = {}) {
  const l = a, {
    eventFilter: o = zo
  } = l, n = Qs(l, [
    "eventFilter"
  ]);
  return ce(e, Us(o, t), n);
}
var ti = Object.defineProperty, ai = Object.defineProperties, li = Object.getOwnPropertyDescriptors, ea = Object.getOwnPropertySymbols, Mo = Object.prototype.hasOwnProperty, Do = Object.prototype.propertyIsEnumerable, gl = (e, t, a) => t in e ? ti(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, oi = (e, t) => {
  for (var a in t || (t = {}))
    Mo.call(t, a) && gl(e, a, t[a]);
  if (ea)
    for (var a of ea(t))
      Do.call(t, a) && gl(e, a, t[a]);
  return e;
}, ni = (e, t) => ai(e, li(t)), si = (e, t) => {
  var a = {};
  for (var l in e)
    Mo.call(e, l) && t.indexOf(l) < 0 && (a[l] = e[l]);
  if (e != null && ea)
    for (var l of ea(e))
      t.indexOf(l) < 0 && Do.call(e, l) && (a[l] = e[l]);
  return a;
};
function ii(e, t, a = {}) {
  const l = a, {
    eventFilter: o
  } = l, n = si(l, [
    "eventFilter"
  ]), { eventFilter: r, pause: i, resume: f, isActive: p } = Xs(o);
  return { stop: ei(e, t, ni(oi({}, n), {
    eventFilter: r
  })), pause: i, resume: f, isActive: p };
}
function rt(e) {
  var t;
  const a = Se(e);
  return (t = a == null ? void 0 : a.$el) != null ? t : a;
}
const Qe = Yt ? window : void 0;
function we(...e) {
  let t, a, l, o;
  if (Gs(e[0]) || Array.isArray(e[0]) ? ([a, l, o] = e, t = Qe) : [t, a, l, o] = e, !t)
    return Zt;
  Array.isArray(a) || (a = [a]), Array.isArray(l) || (l = [l]);
  const n = [], r = () => {
    n.forEach((y) => y()), n.length = 0;
  }, i = (y, b, m, h) => (y.addEventListener(b, m, h), () => y.removeEventListener(b, m, h)), f = ce(() => [rt(t), Se(o)], ([y, b]) => {
    r(), y && n.push(...a.flatMap((m) => l.map((h) => i(y, m, h, b))));
  }, { immediate: !0, flush: "post" }), p = () => {
    f(), r();
  };
  return Qt(p), p;
}
let bl = !1;
function jo(e, t, a = {}) {
  const { window: l = Qe, ignore: o = [], capture: n = !0, detectIframe: r = !1 } = a;
  if (!l)
    return;
  Ws && !bl && (bl = !0, Array.from(l.document.body.children).forEach((m) => m.addEventListener("click", Zt)));
  let i = !0;
  const f = (m) => o.some((h) => {
    if (typeof h == "string")
      return Array.from(l.document.querySelectorAll(h)).some(($) => $ === m.target || m.composedPath().includes($));
    {
      const $ = rt(h);
      return $ && (m.target === $ || m.composedPath().includes($));
    }
  }), y = [
    we(l, "click", (m) => {
      const h = rt(e);
      if (!(!h || h === m.target || m.composedPath().includes(h))) {
        if (m.detail === 0 && (i = !f(m)), !i) {
          i = !0;
          return;
        }
        t(m);
      }
    }, { passive: !0, capture: n }),
    we(l, "pointerdown", (m) => {
      const h = rt(e);
      h && (i = !m.composedPath().includes(h) && !f(m));
    }, { passive: !0 }),
    r && we(l, "blur", (m) => {
      var h;
      const $ = rt(e);
      ((h = l.document.activeElement) == null ? void 0 : h.tagName) === "IFRAME" && !($ != null && $.contains(l.document.activeElement)) && t(m);
    })
  ].filter(Boolean);
  return () => y.forEach((m) => m());
}
function ri(e, t = !1) {
  const a = M(), l = () => a.value = !!e();
  return l(), Ro(l, t), a;
}
function ui(e, t = {}) {
  const { window: a = Qe } = t, l = ri(() => a && "matchMedia" in a && typeof a.matchMedia == "function");
  let o;
  const n = M(!1), r = () => {
    o && ("removeEventListener" in o ? o.removeEventListener("change", i) : o.removeListener(i));
  }, i = () => {
    l.value && (r(), o = a.matchMedia(Js(e).value), n.value = o.matches, "addEventListener" in o ? o.addEventListener("change", i) : o.addListener(i));
  };
  return Oe(i), Qt(() => r()), n;
}
function di(e) {
  return JSON.parse(JSON.stringify(e));
}
const ka = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Sa = "__vueuse_ssr_handlers__";
ka[Sa] = ka[Sa] || {};
const ci = ka[Sa];
function qo(e, t) {
  return ci[e] || t;
}
function fi(e) {
  return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number";
}
var vi = Object.defineProperty, hl = Object.getOwnPropertySymbols, mi = Object.prototype.hasOwnProperty, pi = Object.prototype.propertyIsEnumerable, yl = (e, t, a) => t in e ? vi(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, Bl = (e, t) => {
  for (var a in t || (t = {}))
    mi.call(t, a) && yl(e, a, t[a]);
  if (hl)
    for (var a of hl(t))
      pi.call(t, a) && yl(e, a, t[a]);
  return e;
};
const gi = {
  boolean: {
    read: (e) => e === "true",
    write: (e) => String(e)
  },
  object: {
    read: (e) => JSON.parse(e),
    write: (e) => JSON.stringify(e)
  },
  number: {
    read: (e) => Number.parseFloat(e),
    write: (e) => String(e)
  },
  any: {
    read: (e) => e,
    write: (e) => String(e)
  },
  string: {
    read: (e) => e,
    write: (e) => String(e)
  },
  map: {
    read: (e) => new Map(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e.entries()))
  },
  set: {
    read: (e) => new Set(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e))
  },
  date: {
    read: (e) => new Date(e),
    write: (e) => e.toISOString()
  }
}, $l = "vueuse-storage";
function bi(e, t, a, l = {}) {
  var o;
  const {
    flush: n = "pre",
    deep: r = !0,
    listenToStorageChanges: i = !0,
    writeDefaults: f = !0,
    mergeDefaults: p = !1,
    shallow: y,
    window: b = Qe,
    eventFilter: m,
    onError: h = (I) => {
      console.error(I);
    }
  } = l, $ = (y ? Ia : M)(t);
  if (!a)
    try {
      a = qo("getDefaultStorage", () => {
        var I;
        return (I = Qe) == null ? void 0 : I.localStorage;
      })();
    } catch (I) {
      h(I);
    }
  if (!a)
    return $;
  const v = Se(t), k = fi(v), w = (o = l.serializer) != null ? o : gi[k], { pause: B, resume: T } = ii($, () => O($.value), { flush: n, deep: r, eventFilter: m });
  return b && i && (we(b, "storage", V), we(b, $l, S)), V(), $;
  function O(I) {
    try {
      if (I == null)
        a.removeItem(e);
      else {
        const C = w.write(I), F = a.getItem(e);
        F !== C && (a.setItem(e, C), b && b.dispatchEvent(new CustomEvent($l, {
          detail: {
            key: e,
            oldValue: F,
            newValue: C,
            storageArea: a
          }
        })));
      }
    } catch (C) {
      h(C);
    }
  }
  function A(I) {
    const C = I ? I.newValue : a.getItem(e);
    if (C == null)
      return f && v !== null && a.setItem(e, w.write(v)), v;
    if (!I && p) {
      const F = w.read(C);
      return qa(p) ? p(F, v) : k === "object" && !Array.isArray(F) ? Bl(Bl({}, v), F) : F;
    } else
      return typeof C != "string" ? C : w.read(C);
  }
  function S(I) {
    V(I.detail);
  }
  function V(I) {
    if (!(I && I.storageArea !== a)) {
      if (I && I.key == null) {
        $.value = v;
        return;
      }
      if (!(I && I.key !== e)) {
        B();
        try {
          $.value = A(I);
        } catch (C) {
          h(C);
        } finally {
          I ? Ce(T) : T();
        }
      }
    }
  }
}
function hi(e) {
  return ui("(prefers-color-scheme: dark)", e);
}
var yi = Object.defineProperty, wl = Object.getOwnPropertySymbols, Bi = Object.prototype.hasOwnProperty, $i = Object.prototype.propertyIsEnumerable, kl = (e, t, a) => t in e ? yi(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, wi = (e, t) => {
  for (var a in t || (t = {}))
    Bi.call(t, a) && kl(e, a, t[a]);
  if (wl)
    for (var a of wl(t))
      $i.call(t, a) && kl(e, a, t[a]);
  return e;
};
function ki(e = {}) {
  const {
    selector: t = "html",
    attribute: a = "class",
    initialValue: l = "auto",
    window: o = Qe,
    storage: n,
    storageKey: r = "vueuse-color-scheme",
    listenToStorageChanges: i = !0,
    storageRef: f,
    emitAuto: p
  } = e, y = wi({
    auto: "",
    light: "light",
    dark: "dark"
  }, e.modes || {}), b = hi({ window: o }), m = d(() => b.value ? "dark" : "light"), h = f || (r == null ? M(l) : bi(r, l, n, { window: o, listenToStorageChanges: i })), $ = d({
    get() {
      return h.value === "auto" && !p ? m.value : h.value;
    },
    set(B) {
      h.value = B;
    }
  }), v = qo("updateHTMLAttrs", (B, T, O) => {
    const A = o == null ? void 0 : o.document.querySelector(B);
    if (A)
      if (T === "class") {
        const S = O.split(/\s/g);
        Object.values(y).flatMap((V) => (V || "").split(/\s/g)).filter(Boolean).forEach((V) => {
          S.includes(V) ? A.classList.add(V) : A.classList.remove(V);
        });
      } else
        A.setAttribute(T, O);
  });
  function k(B) {
    var T;
    const O = B === "auto" ? m.value : B;
    v(t, a, (T = y[O]) != null ? T : O);
  }
  function w(B) {
    e.onChanged ? e.onChanged(B, k) : k(B);
  }
  return ce($, w, { flush: "post", immediate: !0 }), p && ce(m, () => w($.value), { flush: "post" }), Ro(() => w($.value)), $;
}
function je(e, t = {}) {
  const { initialValue: a = !1 } = t, l = M(!1), o = d(() => rt(e));
  we(o, "focus", () => l.value = !0), we(o, "blur", () => l.value = !1);
  const n = d({
    get: () => l.value,
    set(r) {
      var i, f;
      !r && l.value ? (i = o.value) == null || i.blur() : r && !l.value && ((f = o.value) == null || f.focus());
    }
  });
  return ce(o, () => {
    n.value = a;
  }, { immediate: !0, flush: "post" }), { focused: n };
}
function Si(e = {}) {
  const {
    type: t = "page",
    touch: a = !0,
    resetOnTouchEnds: l = !1,
    initialValue: o = { x: 0, y: 0 },
    window: n = Qe,
    eventFilter: r
  } = e, i = M(o.x), f = M(o.y), p = M(null), y = (v) => {
    t === "page" ? (i.value = v.pageX, f.value = v.pageY) : t === "client" ? (i.value = v.clientX, f.value = v.clientY) : t === "movement" && (i.value = v.movementX, f.value = v.movementY), p.value = "mouse";
  }, b = () => {
    i.value = o.x, f.value = o.y;
  }, m = (v) => {
    if (v.touches.length > 0) {
      const k = v.touches[0];
      t === "page" ? (i.value = k.pageX, f.value = k.pageY) : t === "client" && (i.value = k.clientX, f.value = k.clientY), p.value = "touch";
    }
  }, h = (v) => r === void 0 ? y(v) : r(() => y(v), {}), $ = (v) => r === void 0 ? m(v) : r(() => m(v), {});
  return n && (we(n, "mousemove", h, { passive: !0 }), we(n, "dragover", h, { passive: !0 }), a && t !== "movement" && (we(n, "touchstart", $, { passive: !0 }), we(n, "touchmove", $, { passive: !0 }), l && we(n, "touchend", b, { passive: !0 }))), {
    x: i,
    y: f,
    sourceType: p
  };
}
function Sl(e, t = {}) {
  const {
    handleOutside: a = !0,
    window: l = Qe
  } = t, { x: o, y: n, sourceType: r } = Si(t), i = M(e ?? (l == null ? void 0 : l.document.body)), f = M(0), p = M(0), y = M(0), b = M(0), m = M(0), h = M(0), $ = M(!0);
  let v = () => {
  };
  return l && (v = ce([i, o, n], () => {
    const k = rt(i);
    if (!k)
      return;
    const {
      left: w,
      top: B,
      width: T,
      height: O
    } = k.getBoundingClientRect();
    y.value = w + l.pageXOffset, b.value = B + l.pageYOffset, m.value = O, h.value = T;
    const A = o.value - y.value, S = n.value - b.value;
    $.value = T === 0 || O === 0 || A < 0 || S < 0 || A > T || S > O, (a || !$.value) && (f.value = A, p.value = S);
  }, { immediate: !0 }), we(document, "mouseleave", () => {
    $.value = !0;
  })), {
    x: o,
    y: n,
    sourceType: r,
    elementX: f,
    elementY: p,
    elementPositionX: y,
    elementPositionY: b,
    elementHeight: m,
    elementWidth: h,
    isOutside: $,
    stop: v
  };
}
var it;
(function(e) {
  e.UP = "UP", e.RIGHT = "RIGHT", e.DOWN = "DOWN", e.LEFT = "LEFT", e.NONE = "NONE";
})(it || (it = {}));
function Ci(e, t = {}) {
  const {
    threshold: a = 50,
    onSwipe: l,
    onSwipeEnd: o,
    onSwipeStart: n,
    passive: r = !0,
    window: i = Qe
  } = t, f = dt({ x: 0, y: 0 }), p = dt({ x: 0, y: 0 }), y = d(() => f.x - p.x), b = d(() => f.y - p.y), { max: m, abs: h } = Math, $ = d(() => m(h(y.value), h(b.value)) >= a), v = M(!1), k = d(() => $.value ? h(y.value) > h(b.value) ? y.value > 0 ? it.LEFT : it.RIGHT : b.value > 0 ? it.UP : it.DOWN : it.NONE), w = (C) => [C.touches[0].clientX, C.touches[0].clientY], B = (C, F) => {
    f.x = C, f.y = F;
  }, T = (C, F) => {
    p.x = C, p.y = F;
  };
  let O;
  const A = Ti(i == null ? void 0 : i.document);
  r ? O = A ? { passive: !0 } : { capture: !1 } : O = A ? { passive: !1, capture: !0 } : { capture: !0 };
  const S = (C) => {
    v.value && (o == null || o(C, k.value)), v.value = !1;
  }, V = [
    we(e, "touchstart", (C) => {
      O.capture && !O.passive && C.preventDefault();
      const [F, E] = w(C);
      B(F, E), T(F, E), n == null || n(C);
    }, O),
    we(e, "touchmove", (C) => {
      const [F, E] = w(C);
      T(F, E), !v.value && $.value && (v.value = !0), v.value && (l == null || l(C));
    }, O),
    we(e, "touchend", S, O),
    we(e, "touchcancel", S, O)
  ];
  return {
    isPassiveEventSupported: A,
    isSwiping: v,
    direction: k,
    coordsStart: f,
    coordsEnd: p,
    lengthX: y,
    lengthY: b,
    stop: () => V.forEach((C) => C())
  };
}
function Ti(e) {
  if (!e)
    return !1;
  let t = !1;
  const a = {
    get passive() {
      return t = !0, !1;
    }
  };
  return e.addEventListener("x", Zt, a), e.removeEventListener("x", Zt), t;
}
var _i = Object.defineProperty, Cl = Object.getOwnPropertySymbols, xi = Object.prototype.hasOwnProperty, Ai = Object.prototype.propertyIsEnumerable, Tl = (e, t, a) => t in e ? _i(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a, Vi = (e, t) => {
  for (var a in t || (t = {}))
    xi.call(t, a) && Tl(e, a, t[a]);
  if (Cl)
    for (var a of Cl(t))
      Ai.call(t, a) && Tl(e, a, t[a]);
  return e;
};
const Oi = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
Vi({
  linear: Ks
}, Oi);
function _e(e, t, a, l = {}) {
  var o, n, r;
  const {
    clone: i = !1,
    passive: f = !1,
    eventName: p,
    deep: y = !1,
    defaultValue: b
  } = l, m = Fa(), h = a || (m == null ? void 0 : m.emit) || ((o = m == null ? void 0 : m.$emit) == null ? void 0 : o.bind(m)) || ((r = (n = m == null ? void 0 : m.proxy) == null ? void 0 : n.$emit) == null ? void 0 : r.bind(m == null ? void 0 : m.proxy));
  let $ = p;
  t || (t = "modelValue"), $ = p || $ || `update:${t.toString()}`;
  const v = (w) => i ? qa(i) ? i(w) : di(w) : w, k = () => qs(e[t]) ? v(e[t]) : b;
  if (f) {
    const w = k(), B = M(w);
    return ce(() => e[t], (T) => B.value = v(T)), ce(B, (T) => {
      (T !== e[t] || y) && h($, T);
    }, { deep: y }), B;
  } else
    return d({
      get() {
        return k();
      },
      set(w) {
        h($, w);
      }
    });
}
const Nt = (e) => No(() => e.value ? `justify-content-${e.value}` : "");
function c(e) {
  return No(
    () => e.value === void 0 || e.value === null ? e.value : lo(e.value)
  );
}
const Go = {
  items: dt([]),
  reset() {
    this.items = dt([]);
  }
}, Wo = (e) => {
  e.provide(ho, Go);
}, Uo = () => We(ho, null) ?? Go, Pi = (e = {}) => {
  const t = "data-bs-theme", a = "body";
  return ki({
    attribute: t,
    selector: a,
    storageKey: e.persist === !0 ? `${e.attribute ?? t}-${e.selector ?? a}` : null,
    ...e
  });
}, Ei = (e, t = M(1e3), a = {}) => {
  const l = M(!1), o = M(0), n = M(Se(e)), r = M(Se(t)), i = d(() => Math.ceil(n.value / r.value)), f = d(
    () => b.value || l.value ? Math.round(n.value - o.value * r.value) : 0
  ), { pause: p, resume: y, isActive: b } = Ho(
    () => o.value = o.value + 1,
    t,
    a
  ), m = () => {
    l.value = !1, o.value = 0, y();
  }, h = () => {
    l.value = !1, o.value = i.value;
  };
  Oe(() => {
    const k = Se(e), w = n.value;
    k !== w && (n.value = k, h(), m());
  }), Oe(() => {
    const k = Se(t), w = r.value;
    k !== w && (r.value = k, h(), m());
  }), Oe(() => {
    o.value > i.value && (o.value = i.value), o.value === i.value && p();
  });
  const $ = () => {
    b.value !== !1 && (l.value = !0, p());
  }, v = () => {
    o.value !== i.value && (l.value = !1, y());
  };
  return {
    isActive: Ae(b),
    isPaused: Ae(l),
    restart: m,
    stop: h,
    pause: $,
    resume: v,
    value: f
  };
}, Xo = (e) => {
  const t = M(Se(e));
  return Oe(() => t.value = Se(e)), d(() => ({
    "form-check": t.value.plain === !1 && t.value.button === !1,
    "form-check-inline": t.value.inline === !0,
    "form-switch": t.value.switch === !0,
    [`form-control-${t.value.size}`]: t.value.size !== void 0 && t.value.size !== "md" && t.value.button === !1
  }));
}, Ko = (e) => {
  const t = M(Se(e));
  return Oe(() => t.value = Se(e)), d(() => ({
    "form-check-input": t.value.plain === !1 && t.value.button === !1,
    "is-valid": t.value.state === !0,
    "is-invalid": t.value.state === !1,
    "btn-check": t.value.button === !0
  }));
}, Jo = (e) => {
  const t = M(Se(e));
  return Oe(() => t.value = Se(e)), d(() => ({
    "form-check-label": t.value.plain === !1 && t.value.button === !1,
    btn: t.value.button === !0,
    [`btn-${t.value.buttonVariant}`]: t.value.button === !0 && t.value.buttonVariant !== void 0,
    [`btn-${t.value.size}`]: t.value.button && t.value.size && t.value.size !== "md"
  }));
}, Yo = (e) => {
  const t = M(Se(e));
  return Oe(() => t.value = Se(e)), d(() => ({
    "aria-invalid": ra(t.value.ariaInvalid, t.value.state),
    "aria-required": t.value.required === !0 ? !0 : void 0
  }));
}, Zo = (e) => {
  const t = M(Se(e));
  return Oe(() => t.value = Se(e)), d(() => ({
    "was-validated": t.value.validated === !0,
    "btn-group": t.value.buttons === !0 && t.value.stacked === !1,
    "btn-group-vertical": t.value.stacked === !0 && t.value.buttons === !0,
    [`btn-group-${t.value.size}`]: t.value.size !== void 0
  }));
}, ke = (e, t) => d(() => (e == null ? void 0 : e.value) || et(t)), Qo = {
  ariaInvalid: {
    type: [Boolean, String],
    default: void 0
  },
  autocomplete: { type: String, required: !1 },
  autofocus: { type: Boolean, default: !1 },
  disabled: { type: Boolean, default: !1 },
  form: { type: String, required: !1 },
  formatter: { type: Function, required: !1 },
  id: { type: String, required: !1 },
  lazy: { type: Boolean, default: !1 },
  lazyFormatter: { type: Boolean, default: !1 },
  list: { type: String, required: !1 },
  modelValue: { type: [String, Number], default: "" },
  name: { type: String, required: !1 },
  number: { type: Boolean, default: !1 },
  placeholder: { type: String, required: !1 },
  plaintext: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  required: { type: Boolean, default: !1 },
  size: { type: String, required: !1 },
  state: { type: Boolean, default: null },
  trim: { type: Boolean, default: !1 }
}, en = (e, t) => {
  const a = M();
  let l = null, o = !0;
  const n = ke(u(e, "id"), "input"), r = (v, k, w = !1) => (v = String(v), typeof e.formatter == "function" && (!e.lazyFormatter || w) ? (o = !1, e.formatter(v, k)) : v), i = (v) => e.trim ? v.trim() : e.number ? Number.parseFloat(v) : v, f = () => {
    var v;
    e.autofocus && ((v = a.value) == null || v.focus());
  };
  Je(() => {
    a.value && (a.value.value = e.modelValue), Ce(() => {
      f();
    });
  }), Nn(() => {
    Ce(() => {
    });
  });
  const p = d(
    () => ra(e.ariaInvalid, e.state ?? void 0)
  ), y = (v) => {
    const { value: k } = v.target, w = r(k, v);
    if (w === !1 || v.defaultPrevented) {
      v.preventDefault();
      return;
    }
    if (e.lazy)
      return;
    const B = i(w);
    e.modelValue !== B && (l = k, t("update:modelValue", B)), t("input", w);
  }, b = (v) => {
    const { value: k } = v.target, w = r(k, v);
    if (w === !1 || v.defaultPrevented) {
      v.preventDefault();
      return;
    }
    if (!e.lazy)
      return;
    l = k, t("update:modelValue", w);
    const B = i(w);
    e.modelValue !== B && t("change", w);
  }, m = (v) => {
    if (t("blur", v), !e.lazy && !e.lazyFormatter)
      return;
    const { value: k } = v.target, w = r(k, v, !0);
    l = k, t("update:modelValue", w);
  }, h = () => {
    var v;
    e.disabled || (v = a.value) == null || v.focus();
  }, $ = () => {
    var v;
    e.disabled || (v = a.value) == null || v.blur();
  };
  return ce(
    () => e.modelValue,
    (v) => {
      a.value && (a.value.value = l && o ? l : v, l = null, o = !0);
    }
  ), {
    input: a,
    computedId: n,
    computedAriaInvalid: p,
    onInput: y,
    onChange: b,
    onBlur: m,
    focus: h,
    blur: $
  };
}, gt = (e, t) => {
  if (!e)
    return e;
  if (t in e)
    return e[t];
  const a = t.split(".");
  return gt(e[a[0]], a.splice(1).join("."));
}, pa = (e, t = null, a, l) => {
  if (Object.prototype.toString.call(e) === "[object Object]") {
    const o = gt(e, l.valueField), n = gt(e, l.textField), r = gt(e, l.htmlField), i = gt(e, l.disabledField), f = e[l.optionsField] || null;
    return f !== null ? {
      label: String(gt(e, l.labelField) || n),
      options: Ga(f, a, l)
    } : {
      value: typeof o > "u" ? t || n : o,
      text: String(typeof n > "u" ? t : n),
      html: r,
      disabled: !!i
    };
  }
  return {
    value: t || e,
    text: String(e),
    disabled: !1
  };
}, Ga = (e, t, a) => Array.isArray(e) ? e.map((l) => pa(l, null, t, a)) : Object.prototype.toString.call(e) === "[object Object]" ? (console.warn(
  `[BootstrapVue warn]: ${t} - Setting prop "options" to an object is deprecated. Use the array format instead.`
), Object.keys(e).map((l) => {
  const o = e[l];
  switch (typeof o) {
    case "object":
      return pa(o.text, String(o.value), t, a);
    default:
      return pa(o, String(l), t, a);
  }
})) : [], Ii = ["id"], Fi = ["innerHTML"], Li = ["innerHTML"], Ni = ["id"], zi = ["innerHTML"], Ri = ["innerHTML"], Hi = {
  inheritAttrs: !1
}, Wa = /* @__PURE__ */ R({
  ...Hi,
  __name: "BPopover",
  props: {
    modelValue: { default: !1 },
    container: { default: null },
    target: { type: [Function, String, null], default: null },
    reference: { type: [Function, String, null], default: null },
    content: { default: void 0 },
    id: { default: void 0 },
    title: { default: void 0 },
    delay: { default: () => ({ show: 100, hide: 300 }) },
    click: { default: !1 },
    manual: { default: !1 },
    variant: { default: void 0 },
    offset: { default: null },
    customClass: { default: "" },
    placement: { default: "top" },
    strategy: { default: "absolute" },
    floatingMiddleware: { default: void 0 },
    noFlip: { default: !1 },
    noShift: { default: !1 },
    noFade: { default: !1 },
    noAutoClose: { default: !1 },
    hide: { default: !0 },
    realtime: { default: !1 },
    inline: { default: !1 },
    tooltip: { default: !1 },
    html: { default: !1 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = c(u(a, "modelValue")), o = M(l.value);
    Oe(() => {
      t("update:modelValue", o.value);
    }), ce(l, () => {
      l.value !== o.value && (l.value ? ee() : se(new Event("update:modelValue")));
    });
    const n = ke(u(a, "id"), "popover"), r = c(u(a, "click")), i = c(u(a, "manual")), f = c(u(a, "noShift")), p = c(u(a, "noFlip")), y = c(u(a, "noFade")), b = c(u(a, "noAutoClose")), m = c(u(a, "hide")), h = c(u(a, "realtime")), $ = c(u(a, "inline")), v = c(u(a, "tooltip")), k = c(u(a, "html")), w = M(!1), B = M(null), T = M(null), O = M(null), A = M(null), S = M(null), V = (W) => {
      if (typeof W == "string" || W instanceof HTMLElement)
        return W;
      if (typeof W == "function")
        return W().$el ? W().$el : W();
      if (typeof W < "u")
        return W.$el;
    }, I = (W) => {
      if (W) {
        if (typeof W == "string") {
          const re = document.getElementById(W);
          return re || void 0;
        }
        return W;
      }
    }, C = d(
      () => a.title ? ht(a.title, bt) : ""
    ), F = d(
      () => a.content ? ht(a.content, bt) : ""
    ), E = d(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const W = a.offset ? a.offset : v.value ? 0 : 10, re = [_o(W)];
      return p.value === !1 && re.push(To()), f.value === !1 && re.push(xo()), m.value === !0 && re.push(ks({ padding: 10 })), $.value === !0 && re.push(Ss()), re.push(Os({ element: O, padding: 10 })), re;
    }), U = d(() => a.placement), { x: q, y: ae, strategy: Z, middlewareData: G, placement: te, update: fe } = Lo(T, B, {
      placement: U,
      middleware: E,
      strategy: a.strategy,
      whileElementsMounted: (...W) => As(...W, { animationFrame: h.value })
    }), pe = M({ position: "absolute" });
    ce(G, () => {
      var W;
      if (m.value === !0 && ((W = G.value.hide) != null && W.referenceHidden ? w.value = !0 : w.value = !1), G.value.arrow) {
        const { x: re, y: De } = G.value.arrow;
        pe.value = {
          position: "absolute",
          top: De ? `${De}px` : "",
          left: re ? `${re}px` : ""
        };
      }
    });
    const be = d(() => {
      const W = v.value ? "tooltip" : "popover";
      return [
        W,
        `b-${W}`,
        {
          [`b-${W}-${a.variant}`]: a.variant !== void 0,
          show: o.value && !w.value,
          ["pe-none"]: !o.value,
          fade: !y.value,
          ["d-none"]: !o.value && y.value,
          [`${a.customClass}`]: a.customClass !== void 0,
          [`bs-${W}-${Di(te.value)}`]: te.value !== void 0
        }
      ];
    }), { isOutside: oe } = Sl(B), { isOutside: de } = Sl(A), L = (W) => {
      const re = W ?? new Event("click");
      o.value ? se(re) : ee();
    }, z = (W, re = {}) => new It(W, {
      cancelable: !1,
      target: B.value || null,
      relatedTarget: null,
      trigger: null,
      ...re,
      componentId: n.value
    }), ee = () => {
      var re;
      const W = z("show", { cancelable: !0 });
      if (t("show", W), W.defaultPrevented) {
        t("show-prevented");
        return;
      }
      setTimeout(
        () => {
          fe(), o.value = !0, Ce(() => {
            t("shown", z("shown"));
          });
        },
        typeof a.delay == "number" ? a.delay : ((re = a.delay) == null ? void 0 : re.show) || 0
      );
    }, se = (W) => {
      var Ie;
      const re = z("hide", { cancelable: !0 });
      if (t("hide", re), re.defaultPrevented) {
        t("hide-prevented");
        return;
      }
      const De = typeof a.delay == "number" ? a.delay : ((Ie = a.delay) == null ? void 0 : Ie.hide) || 100;
      setTimeout(() => {
        var P;
        (W == null ? void 0 : W.type) === "click" || oe.value && de.value && !((P = B.value) != null && P.contains(document == null ? void 0 : document.activeElement)) ? (o.value = !1, Ce(() => {
          t("hidden", z("hidden"));
        })) : setTimeout(() => {
          se(W);
        }, De);
      }, De);
    }, he = () => {
      var W;
      if (a.target) {
        const re = I(V(a.target));
        re ? A.value = re : console.warn("Target element not found", a.target);
      } else
        A.value = (W = S.value) == null ? void 0 : W.nextElementSibling;
      if (a.reference) {
        const re = I(V(a.reference));
        re ? T.value = re : console.warn("Reference element not found", a.reference);
      } else
        T.value = A.value;
      !A.value || i.value || za && (r.value && A.value.addEventListener("click", L), !r.value && A.value.addEventListener("pointerenter", ee), !r.value && A.value.addEventListener("pointerleave", se), !r.value && A.value.addEventListener("focus", ee), !r.value && A.value.addEventListener("blur", se));
    }, xe = () => {
      A.value && (A.value.removeEventListener("click", L), A.value.removeEventListener("pointerenter", ee), A.value.removeEventListener("pointerleave", se), A.value.removeEventListener("focus", ee), A.value.removeEventListener("blur", se));
    };
    return jo(
      B,
      () => {
        o.value && r.value && !b.value && !i.value && se(new Event("clickOutside"));
      },
      { ignore: [A] }
    ), ce(
      () => [a.click, a.target, a.reference],
      () => {
        xe(), he();
      }
    ), Je(he), Zl(xe), (W, re) => (g(), _(ue, null, [
      X("span", {
        ref_key: "placeholder",
        ref: S
      }, null, 512),
      x(W.$slots, "target", $e(Ve({ show: ee, hide: se, toggle: L, showState: o.value }))),
      e.container ? (g(), D(La, {
        key: 0,
        to: e.container
      }, [
        X("div", Q({ id: e.id }, W.$attrs, {
          ref_key: "element",
          ref: B,
          class: s(be),
          role: "tooltip",
          tabindex: "-1",
          style: {
            position: s(Z),
            top: `${s(ae) ?? 0}px`,
            left: `${s(q) ?? 0}px`,
            width: "max-content"
          }
        }), [
          X("div", {
            ref_key: "arrow",
            ref: O,
            class: N(`${s(v) ? "tooltip" : "popover"}-arrow`),
            style: Le(pe.value),
            "data-popper-arrow": ""
          }, null, 6),
          e.title || W.$slots.title ? (g(), _(ue, { key: 0 }, [
            s(k) ? (g(), _("div", {
              key: 1,
              class: N(s(v) ? "tooltip-inner" : "popover-header"),
              innerHTML: s(C)
            }, null, 10, Fi)) : (g(), _("div", {
              key: 0,
              class: N(s(v) ? "tooltip-inner" : "popover-header")
            }, [
              x(W.$slots, "title", {}, () => [
                ne(J(e.title), 1)
              ])
            ], 2))
          ], 64)) : Y("", !0),
          s(v) && !W.$slots.title && !e.title || !s(v) ? (g(), _(ue, { key: 1 }, [
            s(k) ? (g(), _("div", {
              key: 1,
              class: N(s(v) ? "tooltip-inner" : "popover-body"),
              innerHTML: s(F)
            }, null, 10, Li)) : (g(), _("div", {
              key: 0,
              class: N(s(v) ? "tooltip-inner" : "popover-body")
            }, [
              x(W.$slots, "default", {}, () => [
                ne(J(e.content), 1)
              ])
            ], 2))
          ], 64)) : Y("", !0)
        ], 16, Ii)
      ], 8, ["to"])) : (g(), _("div", Q({
        key: 1,
        id: e.id
      }, W.$attrs, {
        ref_key: "element",
        ref: B,
        class: s(be),
        role: "tooltip",
        tabindex: "-1",
        style: {
          position: s(Z),
          top: `${s(ae) ?? 0}px`,
          left: `${s(q) ?? 0}px`,
          width: "max-content"
        }
      }), [
        X("div", {
          ref_key: "arrow",
          ref: O,
          class: N(`${s(v) ? "tooltip" : "popover"}-arrow`),
          style: Le(pe.value),
          "data-popper-arrow": ""
        }, null, 6),
        e.title || W.$slots.title ? (g(), _(ue, { key: 0 }, [
          s(k) ? (g(), _("div", {
            key: 1,
            class: N(s(v) ? "tooltip-inner" : "popover-header"),
            innerHTML: s(C)
          }, null, 10, zi)) : (g(), _("div", {
            key: 0,
            class: N(s(v) ? "tooltip-inner" : "popover-header")
          }, [
            x(W.$slots, "title", {}, () => [
              ne(J(e.title), 1)
            ])
          ], 2))
        ], 64)) : Y("", !0),
        s(v) && !W.$slots.title && !e.title || !s(v) ? (g(), _(ue, { key: 1 }, [
          s(k) ? (g(), _("div", {
            key: 1,
            class: N(s(v) ? "tooltip-inner" : "popover-body"),
            innerHTML: s(F)
          }, null, 10, Ri)) : (g(), _("div", {
            key: 0,
            class: N(s(v) ? "tooltip-inner" : "popover-body")
          }, [
            x(W.$slots, "default", {}, () => [
              ne(J(e.content), 1)
            ])
          ], 2))
        ], 64)) : Y("", !0)
      ], 16, Ni))
    ], 64));
  }
}), Mi = ({
  top: e,
  end: t,
  start: a,
  alignCenter: l,
  alignEnd: o
}) => {
  const n = e ? "top" : a ? "left" : t ? "right" : "bottom", r = o ? "end" : l ? null : "start";
  return `${n}${r ? `-${r}` : ""}`;
}, Di = (e) => {
  const [t] = e.split("-");
  switch (t) {
    case "left":
      return "start";
    case "right":
      return "end";
    default:
      return t;
  }
}, ta = (e, t) => {
  if ((typeof e > "u" || typeof e == "object" && !(e != null && e.title) && !(e != null && e.content)) && !t.getAttribute("title"))
    return console.warn(
      "Review tooltip directive usage. Some uses are not defining a title in root component or a value like `v-b-tooltip='{title: \"my title\"}'` nor `v-b-tooltip=\"'my title'\"` to define a title"
    ), {};
  if ((typeof e > "u" || typeof e == "object" && !(e != null && e.title) && !(e != null && e.content)) && (t.getAttribute("title") || t.getAttribute("data-original-title"))) {
    const a = t.getAttribute("title") ?? t.getAttribute("data-original-title");
    if (a && a !== "")
      return t.removeAttribute("title"), t.setAttribute("data-original-title", a), {
        content: ht(a, bt)
      };
  }
  return typeof e == "string" ? {
    content: ht(e, bt)
  } : {
    title: e != null && e.title ? ht(e == null ? void 0 : e.title, bt) : void 0,
    content: e != null && e.content ? ht(e == null ? void 0 : e.content, bt) : void 0
  };
}, aa = (e, t) => ({
  target: () => t,
  modelValue: e.modifiers.show,
  inline: e.modifiers.inline,
  click: e.modifiers.click,
  realtime: e.modifiers.realtime,
  placement: e.modifiers.left ? "left" : e.modifiers.right ? "right" : e.modifiers.bottom ? "bottom" : e.modifiers.top ? "top" : void 0,
  html: !0,
  ...typeof e.value == "object" ? e.value : {},
  title: null,
  content: null
}), tn = (e, t) => {
  var l;
  const a = document.createElement("span");
  t.modifiers.body ? document.body.appendChild(a) : t.modifiers.child ? e.appendChild(a) : (l = e.parentNode) == null || l.insertBefore(a, e.nextSibling), e.$__app = zn({ render: () => {
    var o;
    return ie(Wa, { ...(o = e.$__state) == null ? void 0 : o.value });
  } }), e.$__app.mount(a), e.$__element = a;
}, an = (e) => {
  var t, a;
  (t = e.$__app) == null || t.unmount(), delete e.$__app, delete e.$__state, (a = e.$__element) == null || a.remove(), delete e.$__element;
}, ji = ["id"], qi = /* @__PURE__ */ R({
  __name: "BAccordion",
  props: {
    flush: { default: !1 },
    free: { default: !1 },
    id: { default: void 0 }
  },
  setup(e) {
    const t = e, a = ke(u(t, "id"), "accordion"), l = c(u(t, "flush")), o = c(u(t, "free")), n = d(() => ({
      "accordion-flush": l.value
    }));
    return o.value || ot(wo, {
      id: a
    }), (r, i) => (g(), _("div", {
      id: s(a),
      class: N(["accordion", s(n)])
    }, [
      x(r.$slots, "default")
    ], 10, ji));
  }
}), Gi = {
  inheritAttrs: !1
}, ln = /* @__PURE__ */ R({
  ...Gi,
  __name: "BCollapse",
  props: {
    accordion: { default: void 0 },
    id: { default: void 0 },
    modelValue: { default: !1 },
    tag: { default: "div" },
    toggle: { default: !1 },
    horizontal: { default: !1 },
    visible: { default: !1 },
    isNav: { default: !1 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = (S, V = {}) => new It(S, {
      cancelable: !1,
      target: m.value || null,
      relatedTarget: null,
      trigger: null,
      ...V,
      componentId: b.value
    }), n = _e(l, "modelValue", a, { passive: !0 }), r = c(n), i = c(u(l, "toggle")), f = c(u(l, "horizontal")), p = c(u(l, "isNav")), y = c(u(l, "visible")), b = ke(u(l, "id"), "collapse"), m = M(null), h = M(!1), $ = M(r.value), v = d(() => ({
      show: $.value,
      "navbar-collapse": p.value,
      collapsing: h.value,
      closing: $.value && !r.value,
      "collapse-horizontal": f.value
    })), k = () => n.value = !1, w = () => n.value = !0, B = () => n.value = !r.value, T = () => {
      $.value = !0, h.value = !0;
      const S = o("show", { cancelable: !0 });
      if (a("show", S), S.defaultPrevented) {
        a("show-prevented");
        return;
      }
      Ce(() => {
        m.value !== null && (f.value ? m.value.style.width = `${m.value.scrollWidth}px` : m.value.style.height = `${m.value.scrollHeight}px`, setTimeout(() => {
          h.value = !1, a("shown", o("shown")), m.value !== null && (m.value.style.height = "", m.value.style.width = "");
        }, A(m.value)));
      });
    }, O = () => {
      const S = o("hide", { cancelable: !0 });
      if (a("hide", S), S.defaultPrevented) {
        a("hide-prevented");
        return;
      }
      m.value !== null && (f.value ? m.value.style.width = `${m.value.scrollWidth}px` : m.value.style.height = `${m.value.scrollHeight}px`, m.value.offsetHeight, h.value = !0, Ce(() => {
        m.value !== null && (m.value.style.height = "", m.value.style.width = "", setTimeout(() => {
          $.value = !1, h.value = !1, a("hidden", o("hidden"));
        }, A(m.value)));
      }));
    };
    Oe(() => {
      if (r.value === !0) {
        if ($.value)
          return;
        T();
        return;
      }
      O();
    });
    const A = (S) => {
      const V = window.getComputedStyle(S), I = V.transitionDelay.split(",")[0] || "", C = V.transitionDuration.split(",")[0] || "", F = Number(I.slice(0, -1)) * 1e3, E = Number(C.slice(0, -1)) * 1e3;
      return F + E;
    };
    return Je(() => {
      m.value !== null && !r.value && i.value && Ce(() => {
        n.value = !0;
      });
    }), y.value && (n.value = !0, $.value = !0), Oe(() => {
      y.value ? w() : k();
    }), we(m, "bv-toggle", () => {
      n.value = !r.value;
    }), t({
      close: k,
      open: w,
      toggle: B,
      visible: $.value
    }), (S, V) => (g(), _(ue, null, [
      x(S.$slots, "header", $e(Ve({ visible: s(r), toggle: B, open: w, close: k, id: s(b) }))),
      (g(), D(le(e.tag), Q({
        id: s(b),
        ref_key: "element",
        ref: m,
        class: ["collapse", s(v)],
        "is-nav": s(p)
      }, S.$attrs), {
        default: j(() => [
          x(S.$slots, "default", $e(Ve({ visible: s(r), toggle: B, open: w, close: k })))
        ]),
        _: 3
      }, 16, ["id", "class", "is-nav"])),
      x(S.$slots, "footer", $e(Ve({ visible: s(r), toggle: B, open: w, close: k, id: s(b) })))
    ], 64));
  }
}), Wi = { class: "accordion-item" }, Ui = ["aria-expanded", "aria-controls", "onClick"], Xi = { class: "accordion-body" }, Ki = /* @__PURE__ */ R({
  __name: "BAccordionItem",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    modelValue: { default: !1 },
    visible: { default: !1 },
    headerTag: { default: "h2" }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = _e(a, "modelValue", t, { passive: !0 }), o = c(u(a, "visible"));
    Je(() => {
      o.value && (l.value = !0);
    }), Oe(() => l.value = o.value);
    const n = We(wo, null), r = ke(u(a, "id"), "accordion_item");
    return (i, f) => {
      var p;
      return g(), _("div", Wi, [
        ye(ln, {
          id: s(r),
          modelValue: s(l),
          "onUpdate:modelValue": f[0] || (f[0] = (y) => kt(l) ? l.value = y : null),
          class: "accordion-collapse",
          visible: e.visible,
          accordion: ((p = s(n)) == null ? void 0 : p.id.value) ?? void 0,
          "aria-labelledby": `heading${s(r)}`
        }, {
          header: j(({ visible: y, toggle: b }) => [
            (g(), D(le(e.headerTag), {
              id: `heading${s(r)}`,
              class: "accordion-header"
            }, {
              default: j(() => [
                X("button", {
                  class: N(["accordion-button", { collapsed: !y }]),
                  type: "button",
                  "aria-expanded": y ? "true" : "false",
                  "aria-controls": s(r),
                  onClick: b
                }, [
                  x(i.$slots, "title", {}, () => [
                    ne(J(e.title), 1)
                  ])
                ], 10, Ui)
              ]),
              _: 2
            }, 1032, ["id"]))
          ]),
          default: j(() => [
            X("div", Xi, [
              x(i.$slots, "default")
            ])
          ]),
          _: 3
        }, 8, ["id", "modelValue", "visible", "accordion", "aria-labelledby"])
      ]);
    };
  }
}), Ct = /* @__PURE__ */ R({
  __name: "BTransition",
  props: {
    appear: { default: !1 },
    mode: { default: void 0 },
    noFade: { default: !1 },
    transProps: { default: void 0 }
  },
  setup(e) {
    const t = e, a = c(u(t, "appear")), l = c(u(t, "noFade")), o = d(() => {
      const i = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: ""
      }, f = {
        ...i,
        enterActiveClass: "fade showing",
        leaveActiveClass: "fade showing"
      };
      return l.value ? i : f;
    }), n = d(() => ({ mode: t.mode, css: !0, ...o.value })), r = d(
      () => t.transProps !== void 0 ? {
        // Order matters here since the props.transProps would get overwritten if it came first
        // But the goal of props.transProps is to overwrite base properties
        ...n.value,
        ...t.transProps
      } : a.value ? {
        ...n.value,
        appear: !0,
        appearActiveClass: o.value.enterActiveClass,
        appearToClass: o.value.enterToClass
      } : n.value
    );
    return (i, f) => (g(), D(Ql, $e(Ve(s(r))), {
      default: j(() => [
        x(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Ji = ["type", "disabled", "aria-label"], Tt = /* @__PURE__ */ R({
  __name: "BCloseButton",
  props: {
    ariaLabel: { default: "Close" },
    disabled: { default: !1 },
    white: { default: !1 },
    type: { default: "button" }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(u(a, "disabled")), o = c(u(a, "white")), n = d(() => ({
      "btn-close-white": o.value
    }));
    return (r, i) => (g(), _("button", {
      type: e.type,
      class: N(["btn-close", s(n)]),
      disabled: s(l),
      "aria-label": e.ariaLabel,
      onClick: i[0] || (i[0] = (f) => t("click", f))
    }, null, 10, Ji));
  }
}), Yi = {
  key: 0,
  class: "visually-hidden"
}, ca = /* @__PURE__ */ R({
  __name: "BSpinner",
  props: {
    label: { default: void 0 },
    role: { default: "status" },
    small: { default: !1 },
    tag: { default: "span" },
    type: { default: "border" },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = Ee(), l = c(u(t, "small")), o = d(() => ({
      "spinner-border": t.type === "border",
      "spinner-border-sm": t.type === "border" && l.value,
      "spinner-grow": t.type === "grow",
      "spinner-grow-sm": t.type === "grow" && l.value,
      [`text-${t.variant}`]: t.variant !== void 0
    })), n = d(() => !Pe(a.label));
    return (r, i) => (g(), D(le(e.tag), {
      class: N(s(o)),
      role: e.label || s(n) ? e.role : null,
      "aria-hidden": e.label || s(n) ? null : !0
    }, {
      default: j(() => [
        e.label || s(n) ? (g(), _("span", Yi, [
          x(r.$slots, "label", {}, () => [
            ne(J(e.label), 1)
          ])
        ])) : Y("", !0)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
}), vt = {
  active: { type: [Boolean, String, void 0], default: void 0 },
  activeClass: { type: String, default: "router-link-active" },
  append: { type: [Boolean, String], default: !1 },
  disabled: { type: [Boolean, String], default: !1 },
  event: { type: [String, Array], default: "click" },
  href: { type: String },
  // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},
  // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},
  rel: { type: String, default: null },
  replace: { type: [Boolean, String], default: !1 },
  routerComponentName: { type: String, default: "router-link" },
  routerTag: { type: String, default: "a" },
  target: { type: String, default: "_self" },
  to: { type: [String, Object], default: null }
}, Zi = R({
  // TODO this component will likely have an issue with inheritAttrs
  props: vt,
  emits: ["click"],
  setup(e, { emit: t, attrs: a }) {
    const l = c(u(e, "active")), o = c(u(e, "append")), n = c(u(e, "disabled")), r = c(u(e, "replace")), i = Fa(), f = M(null), p = d(() => {
      const $ = e.routerComponentName.split("-").map((k) => k.charAt(0).toUpperCase() + k.slice(1)).join("");
      return !((i == null ? void 0 : i.appContext.app.component($)) !== void 0) || n.value || !e.to ? "a" : e.routerComponentName;
    }), y = d(() => {
      const $ = "#";
      if (e.href)
        return e.href;
      if (typeof e.to == "string")
        return e.to || $;
      const v = e.to;
      if (Object.prototype.toString.call(v) === "[object Object]" && (v.path || v.query || v.hash)) {
        const k = v.path || "", w = v.query ? `?${Object.keys(v.query).map((T) => `${T}=${v.query[T]}`).join("=")}` : "", B = !v.hash || v.hash.charAt(0) === "#" ? v.hash || "" : `#${v.hash}`;
        return `${k}${w}${B}` || $;
      }
      return $;
    }), b = d(() => ({
      to: e.to,
      href: y.value,
      target: e.target,
      rel: e.target === "_blank" && e.rel === null ? "noopener" : e.rel || null,
      tabindex: n.value ? "-1" : typeof a.tabindex > "u" ? null : a.tabindex,
      "aria-disabled": n.value ? !0 : null
    }));
    return {
      computedLinkClasses: d(() => ({
        active: l.value,
        disabled: n.value
      })),
      tag: p,
      routerAttr: b,
      link: f,
      clicked: ($) => {
        if (n.value) {
          $.preventDefault(), $.stopImmediatePropagation();
          return;
        }
        t("click", $);
      },
      activeBoolean: l,
      appendBoolean: o,
      disabledBoolean: n,
      replaceBoolean: r
    };
  }
}), ze = (e, t) => {
  const a = e.__vccOpts || e;
  for (const [l, o] of t)
    a[l] = o;
  return a;
};
function Qi(e, t, a, l, o, n) {
  return e.tag === "router-link" ? (g(), D(le(e.tag), Q({ key: 0 }, e.routerAttr, { custom: "" }), {
    default: j(({ href: r, navigate: i, isActive: f }) => [
      (g(), D(le(e.routerTag), Q({
        ref: "link",
        href: r,
        class: [(e.activeBoolean ?? f) && e.activeClass]
      }, e.$attrs, { onClick: i }), {
        default: j(() => [
          x(e.$slots, "default")
        ]),
        _: 2
      }, 1040, ["href", "class", "onClick"]))
    ]),
    _: 3
  }, 16)) : (g(), D(le(e.tag), Q({
    key: 1,
    ref: "link",
    class: e.computedLinkClasses
  }, e.routerAttr, { onClick: e.clicked }), {
    default: j(() => [
      x(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "onClick"]));
}
const Ne = /* @__PURE__ */ ze(Zi, [["render", Qi]]), er = R({
  components: { BLink: Ne, BSpinner: ca },
  props: {
    ...vt,
    active: { type: [Boolean, String], default: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    href: { type: String, default: void 0 },
    pill: { type: [Boolean, String], default: !1 },
    pressed: { type: [Boolean, String], default: null },
    rel: { type: String, default: void 0 },
    size: { type: String, default: "md" },
    squared: { type: [Boolean, String], default: !1 },
    tag: { type: String, default: "button" },
    target: { type: String, default: "_self" },
    type: { type: String, default: "button" },
    variant: { type: String, default: "secondary" },
    loading: { type: [Boolean, String], default: !1 },
    loadingMode: { type: String, default: "inline" }
  },
  emits: ["click", "update:pressed"],
  setup(e, { emit: t }) {
    const a = _e(e, "pressed", t), l = c(u(e, "active")), o = c(u(e, "disabled")), n = c(u(e, "pill")), r = c(u(e, "pressed")), i = c(u(e, "squared")), f = c(u(e, "loading")), p = d(() => typeof r.value == "boolean"), y = d(
      () => e.tag === "button" && e.href === void 0 && e.to === null
    ), b = d(() => Pt(e)), m = d(() => e.to !== null), h = d(
      () => e.href !== void 0 ? !1 : !y.value
    ), $ = d(() => [
      [`btn-${e.variant}`],
      [`btn-${e.size}`],
      {
        active: l.value || r.value,
        "rounded-pill": n.value,
        "rounded-0": i.value,
        disabled: o.value
      }
    ]), v = d(() => ({
      "aria-disabled": h.value ? o.value : null,
      "aria-pressed": p.value ? r.value : null,
      autocomplete: p.value ? "off" : null,
      disabled: y.value ? o.value : null,
      href: e.href,
      rel: b.value ? e.rel : null,
      role: h.value || b.value ? "button" : null,
      target: b.value ? e.target : null,
      type: y.value ? e.type : null,
      to: y.value ? null : e.to,
      append: b.value ? e.append : null,
      activeClass: m.value ? e.activeClass : null,
      event: m.value ? e.event : null,
      replace: m.value ? e.replace : null,
      routerComponentName: m.value ? e.routerComponentName : null,
      routerTag: m.value ? e.routerTag : null
    })), k = d(
      () => m.value ? Ne : e.href ? "a" : e.tag
    );
    return {
      computedClasses: $,
      computedAttrs: v,
      computedTag: k,
      clicked: (B) => {
        if (o.value) {
          B.preventDefault(), B.stopPropagation();
          return;
        }
        t("click", B), p.value && (a.value = !r.value);
      },
      loadingBoolean: f
    };
  }
});
function tr(e, t, a, l, o, n) {
  const r = eo("b-spinner");
  return g(), D(le(e.computedTag), Q({
    class: ["btn", e.computedClasses]
  }, e.computedAttrs, { onClick: e.clicked }), {
    default: j(() => [
      e.loadingBoolean ? (g(), _("div", {
        key: 0,
        class: N(["btn-loading", { "mode-fill": e.loadingMode === "fill", "mode-inline": e.loadingMode === "inline" }])
      }, [
        x(e.$slots, "loading", {}, () => [
          ye(r, {
            class: "btn-spinner",
            small: e.size !== "lg"
          }, null, 8, ["small"])
        ])
      ], 2)) : Y("", !0),
      X("div", {
        class: N(["btn-content", { "btn-loading-fill": e.loadingBoolean && e.loadingMode === "fill" }])
      }, [
        x(e.$slots, "default")
      ], 2)
    ]),
    _: 3
  }, 16, ["class", "onClick"]);
}
const wt = /* @__PURE__ */ ze(er, [["render", tr]]), ar = ["onMouseenter"], lr = /* @__PURE__ */ R({
  __name: "BAlert",
  props: {
    noHoverPause: { default: !1 },
    dismissLabel: { default: "Close" },
    dismissible: { default: !1 },
    fade: { default: !1 },
    closeVariant: { default: "secondary" },
    modelValue: { type: [Boolean, Number], default: !1 },
    variant: { default: "info" },
    closeContent: { default: void 0 },
    immediate: { default: !0 },
    interval: { default: 1e3 },
    showOnPause: { default: !0 }
  },
  emits: ["closed", "close-countdown", "update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = Ee(), n = _e(l, "modelValue", a), r = c(u(l, "dismissible")), i = c(u(l, "fade")), f = c(u(l, "immediate")), p = c(u(l, "showOnPause")), y = c(u(l, "noHoverPause")), b = d(() => !Pe(o.close)), m = d(
      () => typeof n.value == "boolean" ? 0 : n.value
    ), h = d(() => [
      [`alert-${l.variant}`],
      {
        "alert-dismissible": r.value
      }
    ]), {
      isActive: $,
      pause: v,
      restart: k,
      resume: w,
      stop: B,
      isPaused: T,
      value: O
    } = Ei(m, u(l, "interval"), {
      immediate: typeof n.value == "number" && f.value
    }), A = d(
      () => typeof n.value == "boolean" ? n.value : $.value || p.value && T.value
    ), S = d(() => ({
      variant: l.closeVariant,
      type: "button"
    }));
    Oe(() => a("close-countdown", O.value));
    const V = () => {
      typeof n.value == "boolean" ? n.value = !1 : (n.value = 0, B()), a("closed");
    }, I = () => {
      y.value || v();
    };
    return Zl(B), t({ pause: v, resume: w, restart: k, stop: B }), (C, F) => (g(), D(Ct, {
      "no-fade": !s(i),
      "trans-props": { enterToClass: "show" }
    }, {
      default: j(() => [
        s(A) ? (g(), _("div", {
          key: 0,
          class: N(["alert", s(h)]),
          role: "alert",
          "aria-live": "polite",
          "aria-atomic": "true",
          onMouseenter: ct(I, ["stop"]),
          onMouseleave: F[0] || (F[0] = ct(
            //@ts-ignore
            (...E) => s(w) && s(w)(...E),
            ["stop"]
          ))
        }, [
          x(C.$slots, "default"),
          s(r) ? (g(), _(ue, { key: 0 }, [
            s(b) || e.closeContent ? (g(), D(wt, Q({ key: 0 }, s(S), { onClick: V }), {
              default: j(() => [
                x(C.$slots, "close", {}, () => [
                  ne(J(e.closeContent), 1)
                ])
              ]),
              _: 3
            }, 16)) : (g(), D(Tt, Q({
              key: 1,
              "aria-label": e.dismissLabel
            }, s(S), { onClick: V }), null, 16, ["aria-label"]))
          ], 64)) : Y("", !0)
        ], 42, ar)) : Y("", !0)
      ]),
      _: 3
    }, 8, ["no-fade"]));
  }
}), or = {
  key: 0,
  class: "b-avatar-custom"
}, nr = {
  key: 1,
  class: "b-avatar-img"
}, sr = ["src", "alt"], Ca = (e) => {
  const t = typeof e == "string" && no(e) ? xt(e, 0) : e;
  return typeof t == "number" ? `${t}px` : t || null;
}, ir = /* @__PURE__ */ R({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    ariaLabel: { default: void 0 },
    badge: { type: [Boolean, String], default: !1 },
    badgeLeft: { default: !1 },
    badgeOffset: { default: void 0 },
    badgeTop: { default: !1 },
    badgeVariant: { default: "primary" },
    button: { default: !1 },
    buttonType: { default: "button" },
    disabled: { default: !1 },
    icon: { default: void 0 },
    rounded: { type: [Boolean, String], default: "circle" },
    size: { default: void 0 },
    square: { default: !1 },
    src: { default: void 0 },
    text: { default: void 0 },
    textVariant: { default: void 0 },
    variant: { default: "secondary" }
  },
  emits: ["click", "img-error"],
  setup(e, { emit: t }) {
    const a = e, l = Ee(), o = We($o, null), n = ["sm", null, "lg"], r = 0.4, i = r * 0.7, f = c(u(a, "badgeLeft")), p = c(u(a, "badgeTop")), y = c(u(a, "button")), b = c(u(a, "disabled")), m = c(u(a, "square")), h = d(() => !Pe(l.default)), $ = d(() => !Pe(l.badge)), v = d(() => !!a.badge || a.badge === "" || $.value), k = d(
      () => (o == null ? void 0 : o.size.value) ?? Ca(a.size)
    ), w = d(() => (o == null ? void 0 : o.variant.value) ?? a.variant), B = d(() => (o == null ? void 0 : o.rounded.value) ?? a.rounded), T = d(() => ({
      type: y.value ? a.buttonType : void 0,
      "aria-label": a.ariaLabel || null,
      disabled: b.value || null
    })), O = d(() => [`bg-${a.badgeVariant}`]), A = d(() => a.badge === !0 ? "" : a.badge), S = d(() => [[`text-${ae(a.badgeVariant)}`]]), V = d(() => ({
      [`b-avatar-${a.size}`]: !!a.size && n.indexOf(Ca(a.size)) !== -1,
      [`bg-${w.value}`]: !!w.value,
      badge: !y.value && w.value && h.value,
      rounded: B.value === "" || B.value === !0,
      ["rounded-circle"]: !m.value && B.value === "circle",
      ["rounded-0"]: m.value || B.value === "0",
      ["rounded-1"]: !m.value && B.value === "sm",
      ["rounded-3"]: !m.value && B.value === "lg",
      ["rounded-top"]: !m.value && B.value === "top",
      ["rounded-bottom"]: !m.value && B.value === "bottom",
      ["rounded-start"]: !m.value && B.value === "left",
      ["rounded-end"]: !m.value && B.value === "right",
      btn: y.value,
      [`btn-${w.value}`]: y.value ? !!w.value : !1
    })), I = d(() => [
      [`text-${a.textVariant || ae(w.value)}`]
    ]), C = d(() => {
      const te = a.badgeOffset || "0px";
      return {
        fontSize: (n.indexOf(k.value || null) === -1 ? `calc(${k.value} * ${i})` : "") || "",
        top: p.value ? te : "",
        bottom: p.value ? "" : te,
        left: f.value ? te : "",
        right: f.value ? "" : te
      };
    }), F = d(() => {
      const te = n.indexOf(k.value || null) === -1 ? `calc(${k.value} * ${r})` : null;
      return te ? { fontSize: te } : {};
    }), E = d(() => {
      var pe;
      const te = ((pe = o == null ? void 0 : o.overlapScale) == null ? void 0 : pe.value) || 0, fe = k.value && te ? `calc(${k.value} * -${te})` : null;
      return fe ? { marginLeft: fe, marginRight: fe } : {};
    }), U = d(() => y.value ? "button" : "span"), q = d(() => ({
      ...E.value,
      width: k.value ?? void 0,
      height: k.value ?? void 0
    })), ae = (te) => te === "light" || te === "warning" ? "dark" : "light", Z = (te) => {
      !b.value && y.value && t("click", te);
    }, G = (te) => t("img-error", te);
    return (te, fe) => (g(), D(le(s(U)), Q({
      class: ["b-avatar", s(V)],
      style: s(q)
    }, s(T), { onClick: Z }), {
      default: j(() => [
        s(h) ? (g(), _("span", or, [
          x(te.$slots, "default")
        ])) : e.src ? (g(), _("span", nr, [
          X("img", {
            src: e.src,
            alt: e.alt,
            onError: G
          }, null, 40, sr)
        ])) : e.text ? (g(), _("span", {
          key: 2,
          class: N(["b-avatar-text", s(I)]),
          style: Le(s(F))
        }, J(e.text), 7)) : Y("", !0),
        s(v) ? (g(), _("span", {
          key: 3,
          class: N(["b-avatar-badge", s(O)]),
          style: Le(s(C))
        }, [
          s($) ? x(te.$slots, "badge", { key: 0 }) : (g(), _("span", {
            key: 1,
            class: N(s(S))
          }, J(s(A)), 3))
        ], 6)) : Y("", !0)
      ]),
      _: 3
    }, 16, ["class", "style"]));
  }
}), rr = /* @__PURE__ */ R({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    rounded: { type: [Boolean, String], default: !1 },
    size: { default: void 0 },
    square: { default: !1 },
    tag: { default: "div" },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = c(u(t, "square")), l = d(() => Ca(t.size)), o = d(
      () => Math.min(Math.max(r(t.overlap), 0), 1) / 2
    ), n = d(() => {
      const i = l.value ? `calc(${l.value} * ${o.value})` : null;
      return i ? { paddingLeft: i, paddingRight: i } : {};
    }), r = (i) => typeof i == "string" && no(i) ? xt(i, 0) : i || 0;
    return ot($o, {
      overlapScale: o,
      size: Ae(u(t, "size")),
      square: a,
      rounded: Ae(u(t, "rounded")),
      variant: Ae(u(t, "variant"))
    }), (i, f) => (g(), D(le(e.tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: j(() => [
        X("div", {
          class: "b-avatar-group-inner",
          style: Le(s(n))
        }, [
          x(i.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
}), _l = Ft(vt, ["event", "routerTag"]), ur = R({
  components: { BLink: Ne },
  props: {
    pill: { type: [Boolean, String], default: !1 },
    tag: { type: String, default: "span" },
    variant: { type: String, default: "secondary" },
    textIndicator: { type: [Boolean, String], default: !1 },
    dotIndicator: { type: [Boolean, String], default: !1 },
    ..._l
  },
  setup(e) {
    const t = c(u(e, "pill")), a = c(u(e, "textIndicator")), l = c(u(e, "dotIndicator")), o = c(u(e, "active")), n = c(u(e, "disabled")), r = d(() => Pt(e)), i = d(
      () => r.value ? Ne : e.tag
    ), f = d(() => [
      [`bg-${e.variant}`],
      {
        active: o.value,
        disabled: n.value,
        "text-dark": ["warning", "info", "light"].includes(e.variant),
        "rounded-pill": t.value,
        "position-absolute top-0 start-100 translate-middle": a.value || l.value,
        "p-2 border border-light rounded-circle": l.value,
        "text-decoration-none": r.value
      }
    ]), p = d(
      () => r.value ? Ha(e, _l) : {}
    );
    return {
      computedClasses: f,
      computedLinkProps: p,
      computedTag: i
    };
  }
});
function dr(e, t, a, l, o, n) {
  return g(), D(le(e.computedTag), Q({
    class: ["badge", e.computedClasses]
  }, e.computedLinkProps), {
    default: j(() => [
      x(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class"]);
}
const cr = /* @__PURE__ */ ze(ur, [["render", dr]]), xl = Ft(vt, ["event", "routerTag"]), fr = R({
  components: { BLink: Ne },
  props: {
    ...xl,
    active: { type: [Boolean, String], default: !1 },
    ariaCurrent: { type: String, default: "location" },
    disabled: { type: [Boolean, String], default: !1 },
    text: { type: String, default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = c(u(e, "active")), l = c(u(e, "disabled")), o = d(() => ({
      active: a.value
    })), n = d(
      () => a.value ? "span" : Ne
    ), r = d(
      () => a.value ? e.ariaCurrent : void 0
    );
    return {
      computedLinkProps: d(
        () => n.value !== "span" ? Ha(e, xl) : {}
      ),
      computedClasses: o,
      computedTag: n,
      computedAriaCurrent: r,
      clicked: (p) => {
        if (l.value || a.value) {
          p.preventDefault(), p.stopImmediatePropagation();
          return;
        }
        l.value || t("click", p);
      }
    };
  }
});
function vr(e, t, a, l, o, n) {
  return g(), _("li", {
    class: N(["breadcrumb-item", e.computedClasses])
  }, [
    (g(), D(le(e.computedTag), Q({ "aria-current": e.computedAriaCurrent }, e.computedLinkProps, { onClick: e.clicked }), {
      default: j(() => [
        x(e.$slots, "default", {}, () => [
          ne(J(e.text), 1)
        ])
      ]),
      _: 3
    }, 16, ["aria-current", "onClick"]))
  ], 2);
}
const on = /* @__PURE__ */ ze(fr, [["render", vr]]), mr = { "aria-label": "breadcrumb" }, pr = { class: "breadcrumb" }, gr = /* @__PURE__ */ R({
  __name: "BBreadcrumb",
  props: {
    items: { default: void 0 }
  },
  setup(e) {
    const t = e, a = Uo(), l = d(() => {
      const o = t.items || (a == null ? void 0 : a.items) || [];
      let n = !1;
      return o.map((i, f) => (typeof i == "string" && (i = { text: i }, f < o.length - 1 && (i.href = "#")), i.active && (n = !0), !i.active && !n && (i.active = f + 1 === o.length), i));
    });
    return (o, n) => (g(), _("nav", mr, [
      X("ol", pr, [
        x(o.$slots, "prepend"),
        (g(!0), _(ue, null, Be(s(l), (r, i) => (g(), D(on, Q({ key: i }, r), {
          default: j(() => [
            ne(J(r.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        x(o.$slots, "default"),
        x(o.$slots, "append")
      ])
    ]));
  }
}), br = /* @__PURE__ */ R({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: { default: void 0 },
    tag: { default: "div" },
    vertical: { default: !1 }
  },
  setup(e) {
    const t = e, a = c(u(t, "vertical")), l = d(() => ({
      "btn-group": !a.value,
      [`btn-group-${t.size}`]: t.size !== void 0,
      "btn-group-vertical": a.value
    }));
    return (o, n) => (g(), D(le(e.tag), {
      class: N(s(l)),
      role: "group",
      "aria-label": e.ariaLabel
    }, {
      default: j(() => [
        x(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-label"]));
  }
}), hr = ["role", "aria-label"], yr = /* @__PURE__ */ R({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    justify: { default: !1 },
    role: { default: "toolbar" }
  },
  setup(e) {
    const a = c(u(e, "justify")), l = d(() => ({
      "justify-content-between": a.value
    }));
    return (o, n) => (g(), _("div", {
      class: N([s(l), "btn-toolbar"]),
      role: e.role,
      "aria-label": e.ariaLabel
    }, [
      x(o.$slots, "default")
    ], 10, hr));
  }
}), Ua = /* @__PURE__ */ R({
  __name: "BImg",
  props: {
    alt: { default: void 0 },
    blank: { default: !1 },
    blankColor: { default: "transparent" },
    block: { default: !1 },
    center: { default: !1 },
    fluid: { default: !1 },
    lazy: { default: !1 },
    fluidGrow: { default: !1 },
    height: { default: void 0 },
    start: { default: !1 },
    end: { default: !1 },
    rounded: { type: [Boolean, String], default: !1 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    thumbnail: { default: !1 },
    width: { default: void 0 }
  },
  emits: ["load"],
  setup(e, { emit: t }) {
    const a = e, l = '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>', o = c(u(a, "lazy")), n = c(u(a, "blank")), r = c(u(a, "block")), i = c(u(a, "center")), f = c(u(a, "fluid")), p = c(u(a, "fluidGrow")), y = c(u(a, "start")), b = c(u(a, "end")), m = c(u(a, "thumbnail")), h = d(
      () => typeof a.srcset == "string" ? a.srcset.split(",").filter((A) => A).join(",") : Array.isArray(a.srcset) ? a.srcset.filter((A) => A).join(",") : void 0
    ), $ = d(
      () => typeof a.sizes == "string" ? a.sizes.split(",").filter((A) => A).join(",") : Array.isArray(a.sizes) ? a.sizes.filter((A) => A).join(",") : void 0
    ), v = d(() => {
      const A = (I) => I === void 0 ? void 0 : typeof I == "number" ? I : Number.parseInt(I, 10) || void 0, S = A(a.width), V = A(a.height);
      if (n.value) {
        if (S !== void 0 && V === void 0)
          return { height: S, width: S };
        if (S === void 0 && V !== void 0)
          return { height: V, width: V };
        if (S === void 0 && V === void 0)
          return { height: 1, width: 1 };
      }
      return {
        width: S,
        height: V
      };
    }), k = d(
      () => O(v.value.width, v.value.height, a.blankColor)
    ), w = d(() => ({
      src: n.value ? k.value : a.src,
      alt: a.alt,
      width: v.value.width || void 0,
      height: v.value.height || void 0,
      srcset: n.value ? void 0 : h.value,
      sizes: n.value ? void 0 : $.value,
      loading: o.value ? "lazy" : "eager"
    })), B = d(
      () => y.value ? "float-start" : b.value ? "float-end" : i.value ? "mx-auto" : void 0
    ), T = d(() => ({
      "img-thumbnail": m.value,
      "img-fluid": f.value || p.value,
      "w-100": p.value,
      rounded: a.rounded === "" || a.rounded === !0,
      [`rounded-${a.rounded}`]: typeof a.rounded == "string" && a.rounded !== "",
      [`${B.value}`]: B.value !== void 0,
      "d-block": r.value || i.value
    })), O = (A, S, V) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(
      l.replace("%{w}", String(A)).replace("%{h}", String(S)).replace("%{f}", V)
    )}`;
    return (A, S) => (g(), _("img", Q({ class: s(T) }, s(w), {
      onLoad: S[0] || (S[0] = (V) => t("load", V))
    }), null, 16));
  }
}), la = /* @__PURE__ */ R({
  __name: "BCardImg",
  props: {
    alt: { default: void 0 },
    blank: { default: !1 },
    blankColor: { default: void 0 },
    bottom: { default: !1 },
    lazy: { default: !1 },
    height: { default: void 0 },
    start: { default: !1 },
    end: { default: !1 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    top: { default: !1 },
    width: { default: void 0 }
  },
  emits: ["load"],
  setup(e, { emit: t }) {
    const a = e, l = c(u(a, "bottom")), o = c(u(a, "end")), n = c(u(a, "start")), r = c(u(a, "top")), i = d(
      () => r.value ? "card-img-top" : o.value ? "card-img-right" : l.value ? "card-img-bottom" : n.value ? "card-img-left" : "card-img"
    ), f = d(() => ({
      alt: a.alt,
      height: a.height,
      src: a.src,
      lazy: a.lazy,
      width: a.width,
      blank: a.blank,
      blankColor: a.blankColor,
      sizes: a.sizes,
      srcset: a.srcset
    }));
    return (p, y) => (g(), D(Ua, Q({ class: s(i) }, s(f), {
      onLoad: y[0] || (y[0] = (b) => t("load", b))
    }), null, 16, ["class"]));
  }
}), Br = ["innerHTML"], nn = /* @__PURE__ */ R({
  __name: "BCardHeadFoot",
  props: {
    text: { default: void 0 },
    bgVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = d(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== void 0,
      [`bg-${t.bgVariant}`]: t.bgVariant !== void 0,
      [`border-${t.borderVariant}`]: t.borderVariant !== void 0
    }));
    return (l, o) => (g(), D(le(e.tag), {
      class: N(s(a))
    }, {
      default: j(() => [
        e.html ? (g(), _("div", {
          key: 0,
          innerHTML: e.html
        }, null, 8, Br)) : x(l.$slots, "default", { key: 1 }, () => [
          ne(J(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), sn = /* @__PURE__ */ R({
  __name: "BCardHeader",
  props: {
    text: { default: void 0 },
    bgVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (a, l) => (g(), D(nn, Q({ class: "card-header" }, t), {
      default: j(() => [
        x(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), rn = /* @__PURE__ */ R({
  __name: "BCardTitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h4" }
  },
  setup(e) {
    return (t, a) => (g(), D(le(e.tag), { class: "card-title" }, {
      default: j(() => [
        x(t.$slots, "default", {}, () => [
          ne(J(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), un = /* @__PURE__ */ R({
  __name: "BCardSubtitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h6" },
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, a = d(() => [`text-${t.textVariant}`]);
    return (l, o) => (g(), D(le(e.tag), {
      class: N(["card-subtitle mb-2", s(a)])
    }, {
      default: j(() => [
        x(l.$slots, "default", {}, () => [
          ne(J(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), dn = /* @__PURE__ */ R({
  __name: "BCardBody",
  props: {
    bodyBgVariant: { default: void 0 },
    bodyTag: { default: "div" },
    bodyTextVariant: { default: void 0 },
    overlay: { default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h4" },
    subtitleTextVariant: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    text: { default: void 0 }
  },
  setup(e) {
    const t = e, a = Ee(), l = c(u(t, "overlay")), o = d(() => !Pe(a.title)), n = d(() => !Pe(a.subtitle)), r = d(() => ({
      "card-img-overlay": l.value,
      [`text-${t.bodyTextVariant}`]: t.bodyTextVariant !== void 0,
      [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant !== void 0
    }));
    return (i, f) => (g(), D(le(e.bodyTag), {
      class: N(["card-body", s(r)])
    }, {
      default: j(() => [
        e.title || s(o) ? (g(), D(rn, {
          key: 0,
          tag: e.titleTag
        }, {
          default: j(() => [
            x(i.$slots, "title", {}, () => [
              ne(J(e.title), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag"])) : Y("", !0),
        e.subtitle || s(n) ? (g(), D(un, {
          key: 1,
          tag: e.subtitleTag,
          "text-variant": e.subtitleTextVariant
        }, {
          default: j(() => [
            x(i.$slots, "subtitle", {}, () => [
              ne(J(e.subtitle), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag", "text-variant"])) : Y("", !0),
        x(i.$slots, "default", {}, () => [
          ne(J(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), cn = /* @__PURE__ */ R({
  __name: "BCardFooter",
  props: {
    text: { default: void 0 },
    bgVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (a, l) => (g(), D(nn, Q({ class: "card-footer" }, t), {
      default: j(() => [
        x(a.$slots, "default", {}, () => [
          ne(J(e.text), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), fn = /* @__PURE__ */ R({
  __name: "BCard",
  props: {
    align: { default: void 0 },
    bgVariant: { default: void 0 },
    bodyBgVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTag: { default: "div" },
    bodyTextVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    footer: { default: void 0 },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: { default: void 0 },
    header: { default: void 0 },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerTextVariant: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBottom: { default: !1 },
    imgEnd: { default: !1 },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgStart: { default: !1 },
    imgTop: { default: !1 },
    imgWidth: { default: void 0 },
    noBody: { default: !1 },
    overlay: { default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h6" },
    subtitleTextVariant: { default: "muted" },
    tag: { default: "div" },
    textVariant: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    bodyText: { default: "" }
  },
  setup(e) {
    const t = e, a = Ee(), l = c(u(t, "imgBottom")), o = c(u(t, "imgEnd")), n = c(u(t, "imgStart")), r = c(u(t, "noBody")), i = d(() => !Pe(a.header)), f = d(() => !Pe(a.footer)), p = d(() => ({
      [`text-${t.align}`]: t.align !== void 0,
      [`text-${t.textVariant}`]: t.textVariant !== void 0,
      [`bg-${t.bgVariant}`]: t.bgVariant !== void 0,
      [`border-${t.borderVariant}`]: t.borderVariant !== void 0,
      "flex-row": n.value,
      "flex-row-reverse": o.value
    })), y = d(() => ({
      bgVariant: t.headerBgVariant,
      borderVariant: t.headerBorderVariant,
      html: t.headerHtml,
      tag: t.headerTag,
      textVariant: t.headerTextVariant
    })), b = d(() => ({
      overlay: t.overlay,
      bodyBgVariant: t.bodyBgVariant,
      bodyTag: t.bodyTag,
      bodyTextVariant: t.bodyTextVariant,
      subtitle: t.subtitle,
      subtitleTag: t.subtitleTag,
      subtitleTextVariant: t.subtitleTextVariant,
      title: t.title,
      titleTag: t.titleTag
    })), m = d(() => ({
      bgVariant: t.footerBgVariant,
      borderVariant: t.footerBorderVariant,
      html: t.footerHtml,
      tag: t.footerTag,
      textVariant: t.footerTextVariant
    })), h = d(() => ({
      src: t.imgSrc,
      alt: t.imgAlt,
      height: t.imgHeight,
      width: t.imgWidth,
      bottom: t.imgBottom,
      end: t.imgEnd,
      start: t.imgStart,
      top: t.imgTop
    }));
    return ($, v) => (g(), D(le(e.tag), {
      class: N(["card", s(p)])
    }, {
      default: j(() => [
        s(l) ? Y("", !0) : x($.$slots, "img", { key: 0 }, () => [
          e.imgSrc ? (g(), D(la, $e(Q({ key: 0 }, s(h))), null, 16)) : Y("", !0)
        ]),
        e.header || s(i) || e.headerHtml ? (g(), D(sn, Q({ key: 1 }, s(y), { class: e.headerClass }), {
          default: j(() => [
            x($.$slots, "header", {}, () => [
              ne(J(e.header), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : Y("", !0),
        s(r) ? x($.$slots, "default", { key: 3 }, () => [
          ne(J(e.bodyText), 1)
        ]) : (g(), D(dn, Q({ key: 2 }, s(b), { class: e.bodyClass }), {
          default: j(() => [
            x($.$slots, "default", {}, () => [
              ne(J(e.bodyText), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])),
        e.footer || s(f) || e.footerHtml ? (g(), D(cn, Q({ key: 4 }, s(m), { class: e.footerClass }), {
          default: j(() => [
            x($.$slots, "footer", {}, () => [
              ne(J(e.footer), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : Y("", !0),
        s(l) ? x($.$slots, "img", { key: 5 }, () => [
          e.imgSrc ? (g(), D(la, $e(Q({ key: 0 }, s(h))), null, 16)) : Y("", !0)
        ]) : Y("", !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), $r = /* @__PURE__ */ R({
  __name: "BCardGroup",
  props: {
    columns: { default: !1 },
    deck: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = c(u(t, "columns")), l = c(u(t, "deck")), o = d(
      () => l.value ? "card-deck" : a.value ? "card-columns" : "card-group"
    ), n = d(() => [o.value]);
    return (r, i) => (g(), D(le(e.tag), {
      class: N(s(n))
    }, {
      default: j(() => [
        x(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), wr = /* @__PURE__ */ R({
  __name: "BCardText",
  props: {
    text: { default: void 0 },
    tag: { default: "p" }
  },
  setup(e) {
    return (t, a) => (g(), D(le(e.tag), { class: "card-text" }, {
      default: j(() => [
        x(t.$slots, "default", {}, () => [
          ne(J(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), kr = ["id", "onMouseenter", "onMouseleave"], Sr = {
  key: 0,
  class: "carousel-indicators"
}, Cr = ["aria-current", "aria-label", "onClick"], Tr = { class: "carousel-inner" }, _r = /* @__PURE__ */ X("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1), xr = { class: "visually-hidden" }, Ar = /* @__PURE__ */ X("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1), Vr = { class: "visually-hidden" }, Or = /* @__PURE__ */ R({
  __name: "BCarousel",
  props: {
    ride: { type: [Boolean, String], default: !1 },
    noHoverPause: { default: !1 },
    rideReverse: { default: !1 },
    fade: { default: !1 },
    id: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    background: { default: void 0 },
    modelValue: { default: 0 },
    controls: { default: !1 },
    indicators: { default: !1 },
    interval: { default: 5e3 },
    noTouch: { default: !1 },
    noWrap: { default: !1 },
    controlsPrevText: { default: "Previous" },
    controlsNextText: { default: "Next" },
    indicatorsButtonLabel: { default: "Slide" },
    keyboard: { default: !0 },
    touchThreshold: { default: 50 }
  },
  emits: ["slid", "slide", "update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = Ee(), n = ke(u(l, "id"), "carousel"), r = _e(l, "modelValue", a, { passive: !0 }), i = c(u(l, "keyboard")), f = c(u(l, "rideReverse")), p = c(u(l, "noHoverPause")), y = c(u(l, "fade")), b = c(u(l, "controls")), m = c(u(l, "indicators")), h = c(u(l, "noTouch")), $ = c(u(l, "noWrap")), v = yt(u(l, "touchThreshold"), {
      nanToZero: !0,
      method: "parseInt"
    }), k = M(!1), w = M(!1), B = M(!0), T = M(null), O = M(null), A = d(
      () => qn(l.ride) ? lo(l.ride) : l.ride
    ), { pause: S, resume: V } = Ho(
      () => {
        f.value ? q() : ae();
      },
      u(l, "interval"),
      { immediate: A.value === "carousel" }
    ), I = d(
      () => A.value === !0 && w.value === !0 || A.value === "carousel"
    ), C = d(() => ha(o.default, "BCarouselSlide")), F = d(() => [
      "carousel",
      "slide",
      "pointer-event",
      { "carousel-fade": y.value }
    ]), E = (oe, de) => {
      var L;
      return new oo(oe, {
        componentId: n.value,
        cancelable: !1,
        target: O.value,
        direction: B.value ? "right" : "left",
        from: de,
        to: r.value,
        relatedTarget: ((L = T.value) == null ? void 0 : L.children[r.value]) ?? null
      });
    }, U = (oe) => {
      if (k.value !== !0) {
        if (A.value === !0 && (w.value = !0), I.value === !0 && V(), B.value = !(oe < r.value), oe >= C.value.length) {
          if ($.value)
            return;
          r.value = 0;
          return;
        }
        if (oe < 0) {
          if ($.value)
            return;
          r.value = C.value.length - 1;
          return;
        }
        r.value = oe;
      }
    }, q = () => U(r.value - 1), ae = () => U(r.value + 1), Z = (oe) => {
      i.value !== !1 && oe();
    }, G = () => {
      p.value || S();
    }, te = () => {
      I.value && V();
    }, { lengthX: fe } = Ci(O, {
      passive: !0,
      onSwipeStart() {
        h.value !== !0 && S();
      },
      onSwipeEnd() {
        if (h.value === !0)
          return;
        const oe = () => {
          I.value !== !1 && V();
        };
        if (fe.value >= v.value) {
          ae(), oe();
          return;
        }
        fe.value <= -v.value && (q(), oe());
      }
    }), pe = (oe) => {
      a("slide", E("slide", oe)), k.value = !0;
    }, be = (oe) => {
      a("slid", E("slid", oe)), k.value = !1;
    };
    return ce(
      () => l.ride,
      () => w.value = !1
    ), t({ pause: S, resume: V, prev: q, next: ae }), ot(go, {
      background: Ae(u(l, "background")),
      width: Ae(u(l, "imgWidth")),
      height: Ae(u(l, "imgHeight"))
    }), (oe, de) => (g(), _("div", {
      id: s(n),
      ref_key: "target",
      ref: O,
      class: N(s(F)),
      onKeydown: [
        de[0] || (de[0] = Ot((L) => Z(q), ["left"])),
        de[1] || (de[1] = Ot((L) => Z(ae), ["right"]))
      ],
      onMouseenter: ct(G, ["stop"]),
      onMouseleave: ct(te, ["stop"])
    }, [
      s(m) ? (g(), _("div", Sr, [
        (g(!0), _(ue, null, Be(s(C).length, (L, z) => (g(), _("button", {
          key: z,
          type: "button",
          "data-bs-target": "",
          class: N(z === s(r) ? "active" : ""),
          "aria-current": z === s(r) ? !0 : void 0,
          "aria-label": `${e.indicatorsButtonLabel} ${z}`,
          onClick: (ee) => U(z)
        }, null, 10, Cr))), 128))
      ])) : Y("", !0),
      X("div", {
        ref_key: "relatedTarget",
        ref: T,
        class: "carousel-inner"
      }, [
        (g(!0), _(ue, null, Be(s(C), (L, z) => (g(), D(Ql, {
          key: z,
          "enter-from-class": `carousel-item-next carousel-item-${B.value ? "end" : "start"}`,
          "leave-active-class": "active",
          "leave-to-class": `carousel-item-prev carousel-item-${B.value ? "start" : "end"}`,
          onBeforeLeave: pe,
          onAfterLeave: be
        }, {
          default: j(() => [
            nt((g(), D(le(L), {
              class: N({ active: z === s(r) })
            }, null, 8, ["class"])), [
              [oa, z === s(r)]
            ])
          ]),
          _: 2
        }, 1032, ["enter-from-class", "leave-to-class"]))), 128))
      ], 512),
      X("div", Tr, [
        x(oe.$slots, "default")
      ]),
      s(b) ? (g(), _(ue, { key: 1 }, [
        X("button", {
          class: "carousel-control-prev",
          type: "button",
          onClick: q
        }, [
          _r,
          X("span", xr, J(e.controlsPrevText), 1)
        ]),
        X("button", {
          class: "carousel-control-next",
          type: "button",
          onClick: ae
        }, [
          Ar,
          X("span", Vr, J(e.controlsNextText), 1)
        ])
      ], 64)) : Y("", !0)
    ], 42, kr));
  }
}), Pr = ["innerHTML"], Er = { key: 1 }, Ir = ["innerHTML"], Fr = { key: 1 }, Lr = /* @__PURE__ */ R({
  __name: "BCarouselSlide",
  props: {
    imgSrc: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    interval: { default: void 0 },
    background: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: { default: void 0 },
    id: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBlank: { default: !1 },
    imgBlankColor: { default: "transparent" },
    text: { default: void 0 },
    textHtml: { default: void 0 },
    textTag: { default: "p" }
  },
  setup(e) {
    const t = e, a = Ee(), l = We(go, null), o = d(() => t.text || t.textHtml || !Pe(a.text)), n = d(() => t.caption || t.captionHtml || !Pe(a.caption)), r = d(() => o.value || n.value || !Pe(a.default)), i = d(() => ({
      background: `${t.background || (l == null ? void 0 : l.background.value) || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), f = d(() => ({
      "d-none": t.contentVisibleUp !== void 0,
      [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp !== void 0
    }));
    return (p, y) => (g(), _("div", {
      class: "carousel-item",
      style: Le(s(i))
    }, [
      x(p.$slots, "img", {}, () => {
        var b, m;
        return [
          ye(Ua, {
            class: "d-block w-100",
            alt: e.imgAlt,
            src: e.imgSrc,
            width: e.imgWidth || ((b = s(l)) == null ? void 0 : b.width.value),
            height: e.imgHeight || ((m = s(l)) == null ? void 0 : m.height.value),
            blank: e.imgBlank,
            "blank-color": e.imgBlankColor
          }, null, 8, ["alt", "src", "width", "height", "blank", "blank-color"])
        ];
      }),
      s(r) ? (g(), D(le(e.contentTag), {
        key: 0,
        class: N(["carousel-caption", s(f)])
      }, {
        default: j(() => [
          s(n) ? (g(), D(le(e.captionTag), { key: 0 }, {
            default: j(() => [
              x(p.$slots, "caption", {}, () => [
                e.captionHtml ? (g(), _("span", {
                  key: 0,
                  innerHTML: e.captionHtml
                }, null, 8, Pr)) : (g(), _("span", Er, J(e.caption), 1))
              ])
            ]),
            _: 3
          })) : Y("", !0),
          s(o) ? (g(), D(le(e.textTag), { key: 1 }, {
            default: j(() => [
              x(p.$slots, "text", {}, () => [
                e.textHtml ? (g(), _("span", {
                  key: 0,
                  innerHTML: e.textHtml
                }, null, 8, Ir)) : (g(), _("span", Fr, J(e.text), 1))
              ])
            ]),
            _: 3
          })) : Y("", !0),
          x(p.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : Y("", !0)
    ], 4));
  }
}), Al = ia("", [], { type: [Boolean, String, Number], default: !1 }), Vl = ia("offset", [""], { type: [String, Number], default: null }), Ol = ia("order", [""], { type: [String, Number], default: null }), Nr = R({
  name: "BCol",
  props: {
    col: { type: [Boolean, String], default: !1 },
    // Generic flexbox .col (xs)
    cols: { type: [String, Number], default: null },
    // .col-[1-12]|auto (xs)
    ...Al,
    offset: { type: [String, Number], default: null },
    ...Vl,
    order: { type: [String, Number], default: null },
    ...Ol,
    alignSelf: { type: String, default: null },
    tag: { type: String, default: "div" }
  },
  setup(e) {
    const t = [
      { content: Al, propPrefix: "cols", classPrefix: "col" },
      { content: Vl, propPrefix: "offset" },
      { content: Ol, propPrefix: "order" }
    ], a = c(u(e, "col")), l = d(
      () => t.flatMap((n) => po(e, n.content, n.propPrefix, n.classPrefix))
    );
    return {
      computedClasses: d(() => [
        l.value,
        {
          col: a.value || !l.value.some((n) => /^col-/.test(n)) && !e.cols,
          [`col-${e.cols}`]: !!e.cols,
          [`offset-${e.offset}`]: !!e.offset,
          [`order-${e.order}`]: !!e.order,
          [`align-self-${e.alignSelf}`]: !!e.alignSelf
        }
      ])
    };
  }
});
function zr(e, t, a, l, o, n) {
  return g(), D(le(e.tag), {
    class: N(e.computedClasses)
  }, {
    default: j(() => [
      x(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const _t = /* @__PURE__ */ ze(Nr, [["render", zr]]), pt = {
  autoHide: !0,
  delay: 5e3,
  noCloseButton: !1,
  pos: "top-right",
  value: !0
};
class Pl {
  constructor(t) {
    Te(this, "vm");
    Te(this, "containerPositions");
    Rn(t) ? this.vm = t : this.vm = dt(t), this.containerPositions = d(() => {
      const a = /* @__PURE__ */ new Set([]);
      return this.vm.toasts.map((l) => {
        l.options.pos && a.add(l.options.pos);
      }), a;
    });
  }
  toasts(t) {
    return t ? d(
      () => this.vm.toasts.filter((a) => {
        if (a.options.pos === t && a.options.value)
          return a;
      })
    ) : d(() => this.vm.toasts);
  }
  remove(...t) {
    this.vm.toasts = this.vm.toasts.filter((a) => {
      if (a.options.id && !t.includes(a.options.id))
        return a;
    });
  }
  isRoot() {
    return this.vm.root ?? !1;
  }
  show(t, a = pt) {
    const l = { id: et(), ...pt, ...a }, o = {
      options: dt(l),
      content: t
    };
    return this.vm.toasts.push(o), o;
  }
  info(t, a = pt) {
    return this.show(t, { variant: "info", ...a });
  }
  danger(t, a = pt) {
    return this.show(t, { variant: "danger", ...a });
  }
  warning(t, a = pt) {
    return this.show(t, { variant: "warning", ...a });
  }
  success(t, a = pt) {
    return this.show(t, { variant: "success", ...a });
  }
  hide() {
  }
}
class Rr {
  constructor() {
    Te(this, "vms");
    Te(this, "rootInstance");
    Te(this, "useToast", mn);
    this.vms = {};
  }
  getOrCreateViewModel(t) {
    if (!t) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      const a = { root: !0, toasts: [], container: void 0, id: Symbol("toast") };
      return this.rootInstance = a.id, this.vms[a.id] = a, a;
    }
    if (t.root) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      this.rootInstance = t.id;
    }
    return this.vms[t.id] = t, t;
  }
  getVM(t) {
    if (!t && this.rootInstance)
      return this.vms[this.rootInstance];
    if (t)
      return this.vms[t];
  }
}
const Ta = Symbol("toast"), vn = Symbol("toastFetch"), Hr = {
  container: void 0,
  toasts: [],
  root: !1
};
function Mr() {
  return We(vn);
}
function mn(e, t = Ta) {
  const a = We(Mr());
  if (!e)
    return new Pl(a.getOrCreateViewModel());
  const l = { id: Symbol("toastInstance") }, o = { ...Hr, ...l, ...e }, n = a.getOrCreateViewModel(o);
  return new Pl(n);
}
const Dr = {
  install: (e, t = {}) => {
    var a, l;
    e.provide(vn, ((a = t == null ? void 0 : t.BToast) == null ? void 0 : a.injectkey) ?? Ta), e.provide(((l = t == null ? void 0 : t.BToast) == null ? void 0 : l.injectkey) ?? Ta, new Rr());
  }
}, jr = "toast-title", El = 1e3, pn = R({
  components: { BLink: Ne },
  props: {
    ...vt,
    delay: { type: Number, default: 5e3 },
    bodyClass: { type: String, default: void 0 },
    body: { type: [Object, String], default: void 0 },
    headerClass: { type: String, default: void 0 },
    headerTag: { type: String, default: "div" },
    animation: { type: [Boolean, String], default: !0 },
    id: { type: String, default: void 0 },
    // Switches role to 'status' and aria-live to 'polite'
    isStatus: { type: [Boolean, String], default: !1 },
    autoHide: { type: [Boolean, String], default: !0 },
    noCloseButton: { type: [Boolean, String], default: !1 },
    noFade: { type: [Boolean, String], default: !1 },
    noHoverPause: { type: [Boolean, String], default: !1 },
    solid: { type: [Boolean, String], default: !1 },
    // Render the toast in place, rather than in a portal-target
    static: { type: [Boolean, String], default: !1 },
    title: { type: String, default: void 0 },
    modelValue: { type: [Boolean, String], default: !1 },
    toastClass: { type: Array, default: void 0 },
    variant: { type: String, default: void 0 }
  },
  emits: ["destroyed", "update:modelValue"],
  setup(e, { emit: t, slots: a }) {
    c(u(e, "animation"));
    const l = c(u(e, "isStatus")), o = c(u(e, "autoHide")), n = c(u(e, "noCloseButton")), r = c(u(e, "noFade")), i = c(u(e, "noHoverPause"));
    c(u(e, "solid")), c(u(e, "static"));
    const f = c(u(e, "modelValue")), p = M(!1), y = M(!1), b = M(!1), m = d(() => ({
      [`b-toast-${e.variant}`]: e.variant !== void 0,
      show: b.value || p.value
    }));
    let h, $, v;
    const k = () => {
      typeof h > "u" || (clearTimeout(h), h = void 0);
    }, w = d(
      () => (
        // Minimum supported duration is 1 second
        Math.max(tt(e.delay, 0), El)
      )
    ), B = () => {
      f.value && ($ = v = 0, k(), y.value = !0, zt(() => {
        b.value = !1;
      }));
    }, T = () => {
      k(), t("update:modelValue", !0), $ = v = 0, y.value = !1, Ce(() => {
        zt(() => {
          b.value = !0;
        });
      });
    }, O = () => {
      if (!o.value || i.value || !h || v)
        return;
      const U = Date.now() - $;
      U > 0 && (k(), v = Math.max(w.value - U, El));
    }, A = () => {
      (!o.value || i.value || !v) && (v = $ = 0), S();
    };
    ce(f, (U) => {
      U ? T() : B();
    });
    const S = () => {
      k(), o.value && (h = setTimeout(B, v || w.value), $ = Date.now(), v = 0);
    }, V = () => {
      p.value = !0, t("update:modelValue", !0);
    }, I = () => {
      p.value = !1, S();
    }, C = () => {
      p.value = !0;
    }, F = () => {
      p.value = !1, v = $ = 0, t("update:modelValue", !1);
    };
    Hn(() => {
      k(), o.value && t("destroyed", e.id);
    }), Je(() => {
      Ce(() => {
        f.value && zt(() => {
          T();
        });
      });
    });
    const E = () => {
      Ce(() => {
        zt(() => {
          B();
        });
      });
    };
    return () => {
      const U = () => {
        const q = [], ae = Me(jr, { hide: B }, a);
        ae ? q.push(ie(ae)) : e.title && q.push(ie("strong", { class: "me-auto" }, e.title)), !n.value && q.length !== 0 && q.push(
          ie(Tt, {
            class: ["btn-close"],
            onClick: () => {
              B();
            }
          })
        );
        const Z = [];
        if (q.length > 0 && Z.push(
          ie(
            e.headerTag,
            {
              class: "toast-header"
            },
            { default: () => q }
          )
        ), Me("default", { hide: B }, a) || e.body) {
          const G = ie(
            Pt(e) ? "b-link" : "div",
            {
              class: ["toast-body", e.bodyClass],
              onClick: Pt(e) ? { click: E } : {}
            },
            Me("default", { hide: B }, a) || e.body
          );
          Z.push(G);
        }
        return ie(
          "div",
          {
            class: ["toast", e.toastClass, m.value],
            tabindex: "0"
          },
          Z
        );
      };
      return ie(
        "div",
        {
          class: ["b-toast"],
          id: e.id,
          role: y.value ? null : l.value ? "status" : "alert",
          "aria-live": y.value ? null : l.value ? "polite" : "assertive",
          "aria-atomic": y.value ? null : !0,
          onmouseenter: O,
          onmouseleave: A
        },
        [
          ie(
            Ct,
            {
              noFade: r.value,
              onAfterEnter: I,
              onBeforeEnter: V,
              onAfterLeave: F,
              onBeforeLeave: C
            },
            () => [b.value ? U() : ""]
          )
        ]
      );
    };
  }
}), _a = /* @__PURE__ */ R({
  __name: "BToaster",
  props: {
    position: { default: "top-right" },
    instance: { default: void 0 }
  },
  setup(e) {
    const t = e, a = {
      "top-left": "top-0 start-0",
      "top-center": "top-0 start-50 translate-middle-x",
      "top-right": "top-0 end-0",
      "middle-left": "top-50 start-0 translate-middle-y",
      "middle-center": "top-50 start-50 translate-middle",
      "middle-right": "top-50 end-0 translate-middle-y",
      "bottom-left": "bottom-0 start-0",
      "bottom-center": "bottom-0 start-50 translate-middle-x",
      "bottom-right": "bottom-0 end-0"
    }, l = d(() => a[t.position]), o = (n) => {
      var r;
      (r = t.instance) == null || r.remove(n);
    };
    return (n, r) => {
      var i;
      return g(), _("div", {
        class: N([[s(l)], "b-toaster position-fixed p-3"]),
        style: { "z-index": "11" }
      }, [
        (g(!0), _(ue, null, Be((i = e.instance) == null ? void 0 : i.toasts(e.position).value, (f) => (g(), D(pn, {
          id: f.options.id,
          key: f.options.id,
          modelValue: f.options.value,
          "onUpdate:modelValue": (p) => f.options.value = p,
          "auto-hide": f.options.autoHide,
          delay: f.options.delay,
          "no-close-button": f.options.noCloseButton,
          title: f.content.title,
          body: f.content.body,
          component: f.content.body,
          variant: f.options.variant,
          onDestroyed: o
        }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "auto-hide", "delay", "no-close-button", "title", "body", "component", "variant"]))), 128))
      ], 2);
    };
  }
}), qr = R({
  props: {
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    fluid: { type: [Boolean, String], default: !1 },
    toast: { type: Object, default: void 0 },
    position: { type: String, default: void 0 }
  },
  setup(e, { slots: t, expose: a }) {
    const l = M();
    let o;
    const n = d(() => ({
      container: !e.fluid,
      ["container-fluid"]: typeof e.fluid == "boolean" && e.fluid,
      [`container-${e.fluid}`]: typeof e.fluid == "string",
      [`gx-${e.gutterX}`]: e.gutterX !== null,
      [`gy-${e.gutterY}`]: e.gutterY !== null
    }));
    return Je(() => {
      e.toast;
    }), e.toast && (o = mn({ container: l, root: e.toast.root }), a({
      // ...toastInstance?.useMethods,
    })), () => {
      var i;
      const r = [];
      return o == null || o.containerPositions.value.forEach((f) => {
        r.push(ie(_a, { key: f, instance: o, position: f }));
      }), ie("div", { class: [n.value, e.position], ref: l }, [
        ...r,
        (i = t.default) == null ? void 0 : i.call(t)
      ]);
    };
  },
  methods: {}
}), Gr = { class: "visually-hidden" }, Wr = ["aria-labelledby", "role"], gn = /* @__PURE__ */ R({
  __name: "BDropdown",
  props: {
    id: { default: void 0 },
    menuClass: { default: void 0 },
    size: { default: void 0 },
    splitClass: { default: void 0 },
    splitVariant: { default: void 0 },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    block: { default: !1 },
    dark: { default: !1 },
    disabled: { default: !1 },
    isNav: { default: !1 },
    dropup: { default: !1 },
    dropend: { default: !1 },
    dropstart: { default: !1 },
    center: { default: !1 },
    end: { default: !1 },
    noFlip: { default: !1 },
    noShift: { default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    split: { default: !1 },
    splitButtonType: { default: "button" },
    splitHref: { default: void 0 },
    splitDisabled: { default: void 0 },
    noCaret: { default: !1 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" },
    modelValue: { default: !1 },
    lazy: { default: !1 },
    strategy: { default: "absolute" },
    floatingMiddleware: { default: void 0 },
    splitTo: { default: void 0 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "click", "toggle", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = ke(u(a, "id"), "dropdown"), o = _e(a, "modelValue", t, { passive: !0 }), n = c(o), r = c(u(a, "block")), i = c(u(a, "dark")), f = c(u(a, "dropup")), p = c(u(a, "dropend")), y = c(u(a, "isNav")), b = c(u(a, "dropstart")), m = c(u(a, "center")), h = c(u(a, "end")), $ = c(u(a, "split")), v = c(u(a, "noCaret")), k = c(u(a, "noFlip")), w = c(u(a, "noShift")), B = c(u(a, "lazy")), T = c(u(a, "splitDisabled")), O = d(
      () => typeof a.offset == "string" || typeof a.offset == "number" ? a.offset : NaN
    ), A = yt(O, { method: "parseInt", nanToZero: !0 }), S = M(null), V = M(null), I = M(null), C = d(() => $.value ? V.value : I.value), F = d(
      () => Mi({
        top: f.value,
        start: b.value,
        end: p.value,
        alignCenter: m.value,
        alignEnd: h.value
      })
    ), E = d(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const L = typeof a.offset == "string" || typeof a.offset == "number" ? A.value : a.offset, z = [_o(L)];
      return k.value === !1 && z.push(To()), w.value === !1 && z.push(xo()), z;
    }), { x: U, y: q, strategy: ae, update: Z } = Lo(C, S, {
      placement: F,
      middleware: E,
      strategy: a.strategy
    }), G = d(() => ({
      "d-grid": r.value,
      dropup: f.value,
      dropend: p.value,
      dropstart: b.value,
      "d-flex": r.value && $.value
    })), te = d(() => [
      $.value ? a.splitClass : a.toggleClass,
      {
        "nav-link": y.value,
        "dropdown-toggle": !$.value,
        "dropdown-toggle-no-caret": v.value && !$.value,
        "w-100": $.value && r.value
      }
    ]), fe = d(() => [
      a.menuClass,
      {
        "dropdown-menu-dark": i.value
      }
    ]), pe = d(() => ({
      "aria-expanded": $.value ? void 0 : !1,
      href: $.value ? a.splitHref : void 0,
      to: $.value && a.splitTo ? a.splitTo : void 0
    })), be = () => {
      t("toggle");
      const L = n.value, z = new Ke(L ? "hide" : "show");
      if (t(L ? "hide" : "show", z), z.defaultPrevented) {
        t(L ? "hide-prevented" : "show-prevented");
        return;
      }
      o.value = !L, t(L ? "hidden" : "shown");
    }, oe = (L) => {
      $.value ? t("click", L) : be();
    };
    jo(
      S,
      () => {
        n.value && (a.autoClose === !0 || a.autoClose === "outside") && (o.value = !n.value);
      },
      { ignore: [V, I] }
    );
    const de = () => {
      n.value && (a.autoClose === !0 || a.autoClose === "inside") && (o.value = !n.value);
    };
    return ce(n, Z), (L, z) => (g(), _("div", {
      class: N([s(G), "btn-group"])
    }, [
      ye(wt, Q({
        id: s(l),
        ref_key: "splitButton",
        ref: I,
        variant: e.splitVariant || e.variant,
        size: e.size,
        class: s(te),
        disabled: s(T) || e.disabled,
        type: e.splitButtonType
      }, s(pe), {
        onClick: oe,
        onKeydown: z[0] || (z[0] = Ot((ee) => o.value = !s(n), ["esc"]))
      }), {
        default: j(() => [
          x(L.$slots, "button-content", {}, () => [
            ne(J(e.text), 1)
          ])
        ]),
        _: 3
      }, 16, ["id", "variant", "size", "class", "disabled", "type"]),
      s($) ? (g(), D(wt, {
        key: 0,
        ref_key: "button",
        ref: V,
        variant: e.variant,
        size: e.size,
        disabled: e.disabled,
        class: N([e.toggleClass, "dropdown-toggle-split dropdown-toggle"]),
        "aria-expanded": "false",
        onClick: be
      }, {
        default: j(() => [
          X("span", Gr, [
            x(L.$slots, "toggle-text", {}, () => [
              ne(J(e.toggleText), 1)
            ])
          ])
        ]),
        _: 3
      }, 8, ["variant", "size", "disabled", "class"])) : Y("", !0),
      !s(B) || s(n) ? nt((g(), _("ul", {
        key: 1,
        ref_key: "floating",
        ref: S,
        style: Le({
          position: s(ae),
          top: `${s(q) ?? 0}px`,
          left: `${s(U) ?? 0}px`,
          width: "max-content"
        }),
        class: N(["dropdown-menu show", s(fe)]),
        "aria-labelledby": s(l),
        role: e.role,
        onClick: de
      }, [
        x(L.$slots, "default")
      ], 14, Wr)), [
        [oa, s(B) || s(n)]
      ]) : Y("", !0)
    ], 2));
  }
}), Ur = { role: "presentation" }, Xr = /* @__PURE__ */ R({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(e) {
    return (t, a) => (g(), _("li", Ur, [
      (g(), D(le(e.tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
}), Kr = {}, Jr = { role: "presentation" }, Yr = { class: "px-4 py-3" };
function Zr(e, t) {
  return g(), _("li", Jr, [
    X("form", Yr, [
      x(e.$slots, "default")
    ])
  ]);
}
const Qr = /* @__PURE__ */ ze(Kr, [["render", Zr]]), eu = { role: "presentation" }, tu = ["id", "aria-describedby"], au = {
  inheritAttrs: !1
}, lu = /* @__PURE__ */ R({
  ...au,
  __name: "BDropdownGroup",
  props: {
    id: { default: void 0 },
    ariaDescribedby: { default: void 0 },
    header: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "header" },
    headerVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = d(
      () => t.id ? `${t.id}_group_dd_header` : void 0
    ), l = d(
      () => t.headerTag === "header" ? void 0 : "heading"
    ), o = d(() => [
      t.headerClass,
      {
        [`text-${t.headerVariant}`]: t.headerVariant !== void 0
      }
    ]);
    return (n, r) => (g(), _("li", eu, [
      (g(), D(le(e.headerTag), {
        id: s(a),
        class: N(["dropdown-header", s(o)]),
        role: s(l)
      }, {
        default: j(() => [
          x(n.$slots, "header", {}, () => [
            ne(J(e.header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      X("ul", Q({
        id: e.id,
        role: "group",
        class: "list-unstyled"
      }, n.$attrs, {
        "aria-describedby": e.ariaDescribedby || s(a)
      }), [
        x(n.$slots, "default")
      ], 16, tu)
    ]));
  }
}), ou = {}, nu = { class: "dropdown-header" };
function su(e, t) {
  return g(), _("li", null, [
    X("h6", nu, [
      x(e.$slots, "default")
    ])
  ]);
}
const iu = /* @__PURE__ */ ze(ou, [["render", su]]), ru = {
  inheritAttrs: !1
}, uu = /* @__PURE__ */ R({
  ...ru,
  __name: "BDropdownItem",
  props: {
    href: { default: void 0 },
    linkClass: { default: void 0 },
    active: { default: !1 },
    disabled: { default: !1 },
    rel: { default: void 0 },
    target: { default: "_self" },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(u(a, "active")), o = c(u(a, "disabled")), n = to(), r = d(() => [
      a.linkClass,
      {
        active: l.value,
        disabled: o.value,
        [`text-${a.variant}`]: a.variant !== void 0
      }
    ]), i = d(
      () => a.href ? "a" : n.to ? Ne : "button"
    ), f = d(() => ({
      disabled: o.value,
      "aria-current": l.value ? !0 : null,
      href: i.value === "a" ? a.href : null,
      rel: a.rel,
      type: i.value === "button" ? "button" : null,
      target: a.target,
      ...n.to ? { activeClass: "active", ...n } : {}
    })), p = (y) => t("click", y);
    return (y, b) => (g(), _("li", {
      role: "presentation",
      class: N(y.$attrs.class)
    }, [
      (g(), D(le(s(i)), Q({
        class: ["dropdown-item", s(r)]
      }, s(f), { onClick: p }), {
        default: j(() => [
          x(y.$slots, "default")
        ]),
        _: 3
      }, 16, ["class"]))
    ], 2));
  }
}), du = ["disabled"], cu = {
  inheritAttrs: !1
}, fu = /* @__PURE__ */ R({
  ...cu,
  __name: "BDropdownItemButton",
  props: {
    buttonClass: { default: void 0 },
    active: { default: !1 },
    activeClass: { default: "active" },
    disabled: { default: !1 },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(u(a, "active")), o = c(u(a, "disabled")), n = d(() => [
      a.buttonClass,
      {
        [a.activeClass]: l.value,
        disabled: o.value,
        [`text-${a.variant}`]: a.variant !== void 0
      }
    ]), r = (i) => t("click", i);
    return (i, f) => (g(), _("li", {
      role: "presentation",
      class: N(i.$attrs.class)
    }, [
      X("button", {
        role: "menu",
        type: "button",
        class: N(["dropdown-item", s(n)]),
        disabled: s(o),
        onClick: r
      }, [
        x(i.$slots, "default")
      ], 10, du)
    ], 2));
  }
}), vu = { role: "presentation" }, mu = { class: "px-4 py-1 mb-0 text-muted" }, pu = /* @__PURE__ */ R({
  __name: "BDropdownText",
  props: {
    text: { default: "" }
  },
  setup(e) {
    return (t, a) => (g(), _("li", vu, [
      X("p", mu, [
        x(t.$slots, "default", {}, () => [
          ne(J(e.text), 1)
        ])
      ])
    ]));
  }
}), gu = ["id", "novalidate", "onSubmit"], bn = /* @__PURE__ */ R({
  __name: "BForm",
  props: {
    id: { default: void 0 },
    floating: { default: !1 },
    novalidate: { default: !1 },
    validated: { default: !1 }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const a = e, l = c(u(a, "floating")), o = c(u(a, "novalidate")), n = c(u(a, "validated")), r = d(() => ({
      "form-floating": l.value,
      "was-validated": n.value
    })), i = (f) => t("submit", f);
    return (f, p) => (g(), _("form", {
      id: e.id,
      novalidate: s(o),
      class: N(s(r)),
      onSubmit: ct(i, ["prevent"])
    }, [
      x(f.$slots, "default")
    ], 42, gu));
  }
}), bu = { class: "form-floating" }, hu = ["for"], yu = /* @__PURE__ */ R({
  __name: "BFormFloatingLabel",
  props: {
    labelFor: { default: void 0 },
    label: { default: void 0 },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, a) => (g(), _("div", bu, [
      x(t.$slots, "default", {}, () => [
        ne(J(e.text), 1)
      ]),
      X("label", { for: e.labelFor }, [
        x(t.$slots, "label", {}, () => [
          ne(J(e.label), 1)
        ])
      ], 8, hu)
    ]));
  }
}), xa = /* @__PURE__ */ R({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { default: !1 },
    id: { default: void 0 },
    text: { default: void 0 },
    role: { default: void 0 },
    state: { default: void 0 },
    tag: { default: "div" },
    tooltip: { default: !1 }
  },
  setup(e) {
    const t = e, a = c(u(t, "forceShow")), l = c(u(t, "state")), o = c(u(t, "tooltip")), n = d(
      () => a.value === !0 || l.value === !1
    ), r = d(() => ({
      "d-block": n.value,
      "invalid-feedback": !o.value,
      "invalid-tooltip": o.value
    })), i = d(() => ({
      id: t.id,
      role: t.role,
      "aria-live": t.ariaLive,
      "aria-atomic": t.ariaLive ? !0 : void 0
    }));
    return (f, p) => (g(), D(le(e.tag), Q({ class: s(r) }, s(i)), {
      default: j(() => [
        x(f.$slots, "default", {}, () => [
          ne(J(e.text), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), jt = /* @__PURE__ */ R({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(e) {
    return (t, a) => (g(), D(le(e.tag), { class: "row d-flex flex-wrap" }, {
      default: j(() => [
        x(t.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Aa = /* @__PURE__ */ R({
  __name: "BFormText",
  props: {
    id: { default: void 0 },
    inline: { default: !1 },
    tag: { default: "small" },
    text: { default: void 0 },
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, a = c(u(t, "inline")), l = d(() => [
      [`text-${t.textVariant}`],
      {
        "form-text": !a.value
      }
    ]);
    return (o, n) => (g(), D(le(e.tag), {
      id: e.id,
      class: N(s(l))
    }, {
      default: j(() => [
        x(o.$slots, "default", {}, () => [
          ne(J(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Va = /* @__PURE__ */ R({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { default: !1 },
    id: { default: void 0 },
    role: { default: void 0 },
    text: { default: void 0 },
    state: { default: void 0 },
    tag: { default: "div" },
    tooltip: { default: !1 }
  },
  setup(e) {
    const t = e, a = c(u(t, "forceShow")), l = c(u(t, "state")), o = c(u(t, "tooltip")), n = d(
      () => a.value === !0 || l.value === !0
    ), r = d(() => ({
      "d-block": n.value,
      "valid-feedback": !o.value,
      "valid-tooltip": o.value
    })), i = d(() => t.ariaLive ? !0 : void 0);
    return (f, p) => (g(), D(le(e.tag), {
      id: e.id,
      role: e.role,
      "aria-live": e.ariaLive,
      "aria-atomic": s(i),
      class: N(s(r))
    }, {
      default: j(() => [
        x(f.$slots, "default", {}, () => [
          ne(J(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), Bu = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "indeterminate"], $u = ["for"], wu = {
  inheritAttrs: !1
}, hn = /* @__PURE__ */ R({
  ...wu,
  __name: "BFormCheckbox",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledBy: { default: void 0 },
    form: { default: void 0 },
    indeterminate: { default: void 0 },
    name: { default: void 0 },
    id: { default: void 0 },
    autofocus: { default: !1 },
    plain: { default: !1 },
    button: { default: !1 },
    switch: { default: !1 },
    disabled: { default: !1 },
    buttonVariant: { default: void 0 },
    inline: { default: !1 },
    required: { default: void 0 },
    size: { default: void 0 },
    state: { default: void 0 },
    uncheckedValue: { type: [Array, Set, Boolean, String, Object, Number], default: !1 },
    value: { type: [Array, Set, Boolean, String, Object, Number], default: !0 },
    modelValue: { type: [Array, Set, Boolean, String, Object, Number], default: void 0 }
  },
  emits: ["update:modelValue", "input", "change"],
  setup(e, { emit: t }) {
    const a = e, l = Ee(), o = _e(a, "modelValue", t, { passive: !0 }), n = ke(u(a, "id"), "form-check"), r = c(u(a, "indeterminate")), i = c(u(a, "autofocus")), f = c(u(a, "plain")), p = c(u(a, "button")), y = c(u(a, "switch")), b = c(u(a, "disabled")), m = c(u(a, "inline")), h = c(u(a, "required")), $ = c(u(a, "state")), v = We(ko, null), k = M(null);
    je(k, {
      initialValue: i.value
    });
    const w = d(() => !Pe(l.default)), B = d({
      get: () => v !== null ? v.modelValue.value.map((I) => JSON.stringify(I)).includes(JSON.stringify(a.value)) : JSON.stringify(o.value) === JSON.stringify(a.value),
      set: (I) => {
        const C = I ? a.value : a.uncheckedValue;
        t("input", C), o.value = C, Ce(() => {
          t("change", C);
        });
      }
    });
    ce(o, (I) => {
      if (v !== null) {
        if (I === !1) {
          v.remove(a.value);
          return;
        }
        v.set(a.value);
      }
    });
    const T = d(
      () => !!(a.name ?? (v == null ? void 0 : v.name.value)) && (h.value || (v == null ? void 0 : v.required.value))
    ), O = d(() => ({
      plain: f.value || ((v == null ? void 0 : v.plain.value) ?? !1),
      button: p.value || ((v == null ? void 0 : v.buttons.value) ?? !1),
      inline: m.value || ((v == null ? void 0 : v.inline.value) ?? !1),
      switch: y.value || ((v == null ? void 0 : v.switch.value) ?? !1),
      state: $.value || (v == null ? void 0 : v.state.value),
      size: a.size !== void 0 ? a.size : (v == null ? void 0 : v.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant !== void 0 ? a.buttonVariant : (v == null ? void 0 : v.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), A = Xo(O), S = Ko(O), V = Jo(O);
    return (I, C) => {
      var F, E, U;
      return g(), _("div", {
        class: N(s(A))
      }, [
        nt(X("input", Q({ id: s(n) }, I.$attrs, {
          ref_key: "input",
          ref: k,
          "onUpdate:modelValue": C[0] || (C[0] = (q) => kt(B) ? B.value = q : null),
          class: s(S),
          type: "checkbox",
          disabled: s(b) || ((F = s(v)) == null ? void 0 : F.disabled.value),
          required: s(T) ? !0 : void 0,
          name: e.name || ((E = s(v)) == null ? void 0 : E.name.value),
          form: e.form || ((U = s(v)) == null ? void 0 : U.form.value),
          "aria-label": e.ariaLabel,
          "aria-labelledby": e.ariaLabelledBy,
          "aria-required": s(T) ? !0 : void 0,
          value: e.value,
          indeterminate: s(r)
        }), null, 16, Bu), [
          [Mn, s(B)]
        ]),
        s(w) || s(f) === !1 ? (g(), _("label", {
          key: 0,
          for: s(n),
          class: N(s(V))
        }, [
          x(I.$slots, "default")
        ], 10, $u)) : Y("", !0)
      ], 2);
    };
  }
}), ku = ["id"], Su = ["innerHTML"], Cu = ["textContent"], Tu = /* @__PURE__ */ R({
  __name: "BFormCheckboxGroup",
  props: {
    id: { default: void 0 },
    form: { default: void 0 },
    modelValue: { default: () => [] },
    ariaInvalid: { default: void 0 },
    autofocus: { default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { default: !1 },
    disabled: { default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { default: !1 },
    required: { default: !1 },
    size: { default: void 0 },
    stacked: { default: !1 },
    state: { default: void 0 },
    switches: { default: !1 },
    textField: { default: "text" },
    validated: { default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e, l = _e(a, "modelValue", t), o = ke(u(a, "id"), "checkbox"), n = ke(u(a, "name"), "checkbox"), r = c(u(a, "autofocus")), i = c(u(a, "buttons")), f = c(u(a, "disabled")), p = c(u(a, "plain")), y = c(u(a, "required")), b = c(u(a, "stacked")), m = c(u(a, "state")), h = c(u(a, "switches")), $ = c(u(a, "validated")), v = M(null);
    je(v, {
      initialValue: r.value
    }), ot(ko, {
      set: (O) => {
        const A = [...l.value];
        A.push(O), t("input", A), l.value = A, Ce(() => {
          t("change", A);
        });
      },
      remove: (O) => {
        const A = [...l.value];
        A.splice(l.value.indexOf(O), 1), t("input", A), l.value = A, Ce(() => {
          t("change", A);
        });
      },
      modelValue: d(() => l.value),
      switch: h,
      buttonVariant: Ae(u(a, "buttonVariant")),
      form: Ae(u(a, "form")),
      name: n,
      state: m,
      plain: p,
      size: Ae(u(a, "size")),
      inline: d(() => !b.value),
      required: y,
      buttons: i,
      disabled: f
    });
    const k = d(
      () => a.options.map(
        (O, A) => typeof O == "string" || typeof O == "number" ? {
          props: {
            value: O,
            disabled: f.value
          },
          text: O.toString(),
          html: void 0,
          self: Symbol(`checkboxGroupOptionItem${A}`)
        } : {
          props: {
            value: O[a.valueField],
            disabled: O[a.disabledField],
            ...O.props ? O.props : {}
          },
          text: O[a.textField],
          html: O[a.htmlField],
          self: Symbol(`checkboxGroupOptionItem${A}`)
        }
      )
    ), w = d(() => ({
      required: y.value,
      ariaInvalid: a.ariaInvalid,
      state: m.value,
      validated: $.value,
      buttons: i.value,
      stacked: b.value,
      size: a.size
    })), B = Yo(w), T = Zo(w);
    return (O, A) => (g(), _("div", Q(s(B), {
      id: s(o),
      ref_key: "element",
      ref: v,
      role: "group",
      class: [s(T), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      x(O.$slots, "first"),
      (g(!0), _(ue, null, Be(s(k), (S) => (g(), D(hn, Q({
        key: S.self
      }, S.props), {
        default: j(() => [
          S.html ? (g(), _("span", {
            key: 0,
            innerHTML: S.html
          }, null, 8, Su)) : (g(), _("span", {
            key: 1,
            textContent: J(S.text)
          }, null, 8, Cu))
        ]),
        _: 2
      }, 1040))), 128)),
      x(O.$slots, "default")
    ], 16, ku));
  }
}), yn = ["input", "select", "textarea"], _u = yn.map((e) => `${e}:not([disabled])`).join(), xu = [...yn, "a", "button", "label"], Au = "label", Vu = "invalid-feedback", Ou = "valid-feedback", Pu = "description", Eu = "default", Iu = R({
  components: { BCol: _t, BFormInvalidFeedback: xa, BFormRow: jt, BFormText: Aa, BFormValidFeedback: Va },
  props: {
    contentCols: { type: [Boolean, String, Number], default: void 0 },
    contentColsLg: { type: [Boolean, String, Number], default: void 0 },
    contentColsMd: { type: [Boolean, String, Number], default: void 0 },
    contentColsSm: { type: [Boolean, String, Number], default: void 0 },
    contentColsXl: { type: [Boolean, String, Number], default: void 0 },
    description: { type: [String], default: void 0 },
    disabled: { type: [Boolean, String], default: !1 },
    feedbackAriaLive: { type: String, default: "assertive" },
    id: { type: String, default: void 0 },
    invalidFeedback: { type: String, default: void 0 },
    label: { type: String, default: void 0 },
    labelAlign: { type: [Boolean, String, Number], default: void 0 },
    labelAlignLg: { type: [Boolean, String, Number], default: void 0 },
    labelAlignMd: { type: [Boolean, String, Number], default: void 0 },
    labelAlignSm: { type: [Boolean, String, Number], default: void 0 },
    labelAlignXl: { type: [Boolean, String, Number], default: void 0 },
    labelClass: { type: [Array, Object, String], default: void 0 },
    labelCols: { type: [Boolean, String, Number], default: void 0 },
    labelColsLg: { type: [Boolean, String, Number], default: void 0 },
    labelColsMd: { type: [Boolean, String, Number], default: void 0 },
    labelColsSm: { type: [Boolean, String, Number], default: void 0 },
    labelColsXl: { type: [Boolean, String, Number], default: void 0 },
    labelFor: { type: String, default: void 0 },
    labelSize: { type: String, default: void 0 },
    labelSrOnly: { type: [Boolean, String], default: !1 },
    state: { type: [Boolean, String], default: null },
    tooltip: { type: [Boolean, String], default: !1 },
    validFeedback: { type: String, default: void 0 },
    validated: { type: [Boolean, String], default: !1 },
    floating: { type: [Boolean, String], default: !1 }
  },
  setup(e, { attrs: t }) {
    const a = c(u(e, "disabled")), l = c(u(e, "labelSrOnly")), o = c(u(e, "state")), n = c(u(e, "tooltip")), r = c(u(e, "validated")), i = c(u(e, "floating")), f = null, p = ["xs", "sm", "md", "lg", "xl"], y = (S, V) => p.reduce((I, C) => {
      const F = al(C === "xs" ? "" : C, `${V}Align`), E = S[F] || null;
      return E && (C === "xs" ? I.push(`text-${E}`) : I.push(`text-${C}-${E}`)), I;
    }, []), b = (S, V) => p.reduce((I, C) => {
      const F = al(C === "xs" ? "" : C, `${V}Cols`);
      let E = S[F];
      return E = E === "" ? !0 : E || !1, typeof E != "boolean" && E !== "auto" && (E = bs(E, 0), E = E > 0 ? E : !1), E && (C === "xs" ? I[typeof E == "boolean" ? "col" : "cols"] = E : I[C || (typeof E == "boolean" ? "col" : "cols")] = E), I;
    }, {}), m = M(), h = (S, V = null) => {
      if (za && e.labelFor) {
        const I = vo(`#${Zn(e.labelFor)}`, m);
        if (I) {
          const C = "aria-describedby", F = (S || "").split(Dt), E = (V || "").split(Dt), U = (Ra(I, C) || "").split(Dt).filter((q) => !E.includes(q)).concat(F).filter((q, ae, Z) => Z.indexOf(q) === ae).filter((q) => q).join(" ").trim();
          U ? vs(I, C, U) : ms(I, C);
        }
      }
    }, $ = d(() => b(e, "content")), v = d(() => y(e, "label")), k = d(() => b(e, "label")), w = d(
      () => (
        // Determine if the form group will be rendered horizontal
        // based on the existence of 'content-col' or 'label-col' props
        Object.keys($.value).length > 0 || Object.keys(k.value).length > 0
      )
    ), B = d(
      () => (
        // If not a boolean, ensure that value is null
        typeof o.value == "boolean" ? o.value : null
      )
    ), T = d(() => {
      const S = B.value;
      return S === !0 ? "is-valid" : S === !1 ? "is-invalid" : null;
    }), O = d(
      () => ra(t.ariaInvalid, o.value)
    );
    return ce(
      () => f,
      (S, V) => {
        S !== V && h(S, V);
      }
    ), Je(() => {
      Ce(() => {
        h(f);
      });
    }), {
      disabledBoolean: a,
      labelSrOnlyBoolean: l,
      stateBoolean: o,
      tooltipBoolean: n,
      validatedBoolean: r,
      floatingBoolean: i,
      ariaDescribedby: f,
      computedAriaInvalid: O,
      contentColProps: $,
      isHorizontal: w,
      labelAlignClasses: v,
      labelColProps: k,
      onLegendClick: (S) => {
        if (e.labelFor)
          return;
        const { target: V } = S, I = V ? V.tagName : "";
        if (xu.indexOf(I) !== -1)
          return;
        const C = cs(_u, m).filter(ds);
        C.length === 1 && rs(C[0]);
      },
      stateClass: T
    };
  },
  render() {
    const e = this.$props, t = this.$slots, a = ke(), l = !e.labelFor;
    let o = null;
    const n = Me(Au, {}, t) || e.label, r = n ? et("_BV_label_") : null;
    if (n || this.isHorizontal) {
      const O = l ? "legend" : "label";
      if (this.labelSrOnlyBoolean)
        n && (o = ie(
          O,
          {
            class: "visually-hidden",
            id: r,
            for: e.labelFor || null
          },
          n
        )), this.isHorizontal ? o = ie(_t, this.labelColProps, { default: () => o }) : o = ie("div", {}, [o]);
      else {
        const A = {
          onClick: l ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? O : null,
          id: r,
          for: e.labelFor || null,
          tabIndex: l ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": l,
              "col-form-label": this.isHorizontal || l,
              "pt-0": !this.isHorizontal && l,
              "d-block": !this.isHorizontal && !l,
              [`col-form-label-${e.labelSize}`]: !!e.labelSize
            },
            this.labelAlignClasses,
            e.labelClass
          ]
        };
        this.isHorizontal ? o = ie(_t, A, { default: () => n }) : o = ie(O, A, n);
      }
    }
    let i = null;
    const f = Me(Vu, {}, t) || this.invalidFeedback, p = f ? et("_BV_feedback_invalid_") : void 0;
    f && (i = ie(
      xa,
      {
        ariaLive: e.feedbackAriaLive,
        id: p,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => f }
    ));
    let y = null;
    const b = Me(Ou, {}, t) || this.validFeedback, m = b ? et("_BV_feedback_valid_") : void 0;
    b && (y = ie(
      Va,
      {
        ariaLive: e.feedbackAriaLive,
        id: m,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => b }
      // validFeedbackContent
    ));
    let h = null;
    const $ = Me(Pu, {}, t) || this.description, v = $ ? et("_BV_description_") : void 0;
    $ && (h = ie(
      Aa,
      {
        id: v
      },
      { default: () => $ }
    ));
    const k = this.ariaDescribedby = [
      v,
      this.stateBoolean === !1 ? p : null,
      this.stateBoolean === !0 ? m : null
    ].filter((O) => O).join(" ") || null, w = [
      Me(Eu, { ariaDescribedby: k, descriptionId: v, id: a, labelId: r }, t) || "",
      i,
      y,
      h
    ];
    !this.isHorizontal && this.floatingBoolean && w.push(o);
    let B = ie(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && this.floatingBoolean
          }
        ]
      },
      w
    );
    this.isHorizontal && (B = ie(_t, { ref: "content", ...this.contentColProps }, { default: () => w }));
    const T = {
      class: [
        // TODO consider removing this static class when refactored to <template> syntax
        "mb-3",
        this.stateClass,
        {
          "was-validated": this.validatedBoolean
        }
      ],
      id: ke(u(e, "id")).value,
      disabled: l ? this.disabledBoolean : null,
      role: l ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      // Only apply `aria-labelledby` if we are a horizontal fieldset
      // as the legend is no longer a direct child of fieldset
      "aria-labelledby": l && this.isHorizontal ? r : null
    };
    return this.isHorizontal && !l ? ie(jt, T, { default: () => [o, B] }) : ie(
      l ? "fieldset" : "div",
      T,
      this.isHorizontal && l ? [ie(jt, null, { default: () => [o, B] })] : this.isHorizontal || !this.floatingBoolean ? [o, B] : [B]
    );
  }
}), Il = [
  "text",
  "number",
  "email",
  "password",
  "search",
  "url",
  "tel",
  "date",
  "time",
  "range",
  "color",
  "datetime",
  "datetime-local",
  "month",
  "week"
], Fu = R({
  props: {
    ...Qo,
    // debounce: {type: [String, Number], default: 0}, TODO: not implemented yet
    max: { type: [String, Number], default: void 0 },
    min: { type: [String, Number], default: void 0 },
    // noWheel: {type: [Boolean, String] as PropType<Booleanish>, default: false}, TODO: not implemented yet
    step: { type: [String, Number], default: void 0 },
    type: {
      type: String,
      default: "text",
      validator: (e) => Il.includes(e)
    }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { emit: t }) {
    const { input: a, computedId: l, computedAriaInvalid: o, onInput: n, onChange: r, onBlur: i, focus: f, blur: p } = en(e, t), y = M(!1), b = d(() => {
      const $ = e.type === "range", v = e.type === "color";
      return {
        "form-control-highlighted": y.value,
        "form-range": $,
        "form-control": v || !e.plaintext && !$,
        "form-control-color": v,
        "form-control-plaintext": e.plaintext && !$ && !v,
        [`form-control-${e.size}`]: !!e.size,
        "is-valid": e.state === !0,
        "is-invalid": e.state === !1
      };
    }), m = d(
      () => Il.includes(e.type) ? e.type : "text"
    );
    return {
      computedClasses: b,
      localType: m,
      input: a,
      computedId: l,
      computedAriaInvalid: o,
      onInput: n,
      onChange: r,
      onBlur: i,
      focus: f,
      blur: p,
      highlight: () => {
        y.value !== !0 && (y.value = !0, setTimeout(() => {
          y.value = !1;
        }, 2e3));
      }
    };
  }
}), Lu = ["id", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"];
function Nu(e, t, a, l, o, n) {
  return g(), _("input", {
    id: e.computedId,
    ref: "input",
    class: N(e.computedClasses),
    name: e.name || void 0,
    form: e.form || void 0,
    type: e.localType,
    disabled: e.disabled,
    placeholder: e.placeholder,
    required: e.required,
    autocomplete: e.autocomplete || void 0,
    readonly: e.readonly || e.plaintext,
    min: e.min,
    max: e.max,
    step: e.step,
    list: e.type !== "password" ? e.list : void 0,
    "aria-required": e.required ? !0 : void 0,
    "aria-invalid": e.computedAriaInvalid,
    onInput: t[0] || (t[0] = (r) => e.onInput(r)),
    onChange: t[1] || (t[1] = (r) => e.onChange(r)),
    onBlur: t[2] || (t[2] = (r) => e.onBlur(r))
  }, null, 42, Lu);
}
const zu = /* @__PURE__ */ ze(Fu, [["render", Nu]]), Ru = ["id", "checked", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"], Hu = ["for"], Mu = {
  inheritAttrs: !1
}, Bn = /* @__PURE__ */ R({
  ...Mu,
  __name: "BFormRadio",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    form: { default: void 0 },
    id: { default: void 0 },
    name: { default: void 0 },
    size: { default: void 0 },
    autofocus: { default: !1 },
    modelValue: { type: [Boolean, String, Array, Object, Number], default: void 0 },
    plain: { default: !1 },
    button: { default: !1 },
    disabled: { default: !1 },
    buttonVariant: { default: void 0 },
    inline: { default: !1 },
    required: { default: !1 },
    state: { default: void 0 },
    value: { type: [String, Boolean, Object, Number], default: !0 }
  },
  emits: ["input", "change", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = Ee(), o = _e(a, "modelValue", t, { passive: !0 }), n = ke(u(a, "id"), "form-check"), r = c(u(a, "autofocus")), i = c(u(a, "plain")), f = c(u(a, "button")), p = c(u(a, "disabled")), y = c(u(a, "inline")), b = c(u(a, "required")), m = c(u(a, "state")), h = We(So, null), $ = M(null);
    je($, {
      initialValue: r.value
    });
    const v = d(() => !Pe(l.default)), k = d({
      get: () => h !== null ? JSON.stringify(h.modelValue.value) === JSON.stringify(a.value) : JSON.stringify(o.value) === JSON.stringify(a.value),
      set: (S) => {
        const V = S || S === 0 ? a.value : !1;
        t("input", V), o.value = V, Ce(() => {
          t("change", V);
        });
      }
    });
    ce(
      () => h == null ? void 0 : h.modelValue.value,
      (S) => {
        JSON.stringify(S) === JSON.stringify(a.value) !== !0 && (k.value = !1);
      }
    ), ce(o, (S) => {
      h === null || S === !1 || h.set(a.value);
    });
    const w = d(
      () => !!(a.name ?? (h == null ? void 0 : h.name.value)) && (b.value || (h == null ? void 0 : h.required.value))
    ), B = d(() => ({
      plain: i.value || ((h == null ? void 0 : h.plain.value) ?? !1),
      button: f.value || ((h == null ? void 0 : h.button.value) ?? !1),
      inline: y.value || ((h == null ? void 0 : h.inline.value) ?? !1),
      state: m.value || (h == null ? void 0 : h.state.value),
      size: a.size !== void 0 ? a.size : (h == null ? void 0 : h.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant !== void 0 ? a.buttonVariant : (h == null ? void 0 : h.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), T = Xo(B), O = Ko(B), A = Jo(B);
    return (S, V) => {
      var I, C, F;
      return g(), _("div", {
        class: N(s(T))
      }, [
        nt(X("input", Q({ id: s(n) }, S.$attrs, {
          ref_key: "input",
          ref: $,
          "onUpdate:modelValue": V[0] || (V[0] = (E) => kt(k) ? k.value = E : null),
          checked: s(k),
          class: s(O),
          type: "radio",
          disabled: s(p) || ((I = s(h)) == null ? void 0 : I.disabled.value),
          required: s(w) ? !0 : void 0,
          name: e.name || ((C = s(h)) == null ? void 0 : C.name.value),
          form: e.form || ((F = s(h)) == null ? void 0 : F.form.value),
          "aria-label": e.ariaLabel,
          "aria-labelledby": e.ariaLabelledby,
          value: e.value,
          "aria-required": s(w) ? !0 : void 0
        }), null, 16, Ru), [
          [Dn, s(k)]
        ]),
        s(v) || s(i) === !1 ? (g(), _("label", {
          key: 0,
          for: s(n),
          class: N(s(A))
        }, [
          x(S.$slots, "default")
        ], 10, Hu)) : Y("", !0)
      ], 2);
    };
  }
}), Du = ["id"], ju = ["innerHTML"], qu = ["textContent"], Gu = /* @__PURE__ */ R({
  __name: "BFormRadioGroup",
  props: {
    size: { default: void 0 },
    form: { default: void 0 },
    id: { default: void 0 },
    name: { default: void 0 },
    modelValue: { type: [String, Boolean, Array, Object, Number, null], default: null },
    ariaInvalid: { default: void 0 },
    autofocus: { default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { default: !1 },
    disabled: { default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    plain: { default: !1 },
    required: { default: !1 },
    stacked: { default: !1 },
    state: { default: void 0 },
    textField: { default: "text" },
    validated: { default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e, l = _e(a, "modelValue", t), o = ke(u(a, "id"), "radio"), n = ke(u(a, "name"), "checkbox"), r = c(u(a, "autofocus")), i = c(u(a, "buttons")), f = c(u(a, "disabled")), p = c(u(a, "plain")), y = c(u(a, "required")), b = c(u(a, "stacked")), m = c(u(a, "state")), h = c(u(a, "validated")), $ = M(null);
    je($, {
      initialValue: r.value
    }), ot(So, {
      set: (T) => {
        t("input", T), l.value = T, Ce(() => {
          t("change", T);
        });
      },
      modelValue: d(() => l.value),
      buttonVariant: Ae(u(a, "buttonVariant")),
      form: Ae(u(a, "form")),
      name: n,
      button: i,
      state: m,
      plain: p,
      size: Ae(u(a, "size")),
      inline: d(() => !b.value),
      required: y,
      disabled: f
    });
    const v = d(
      () => a.options.map(
        (T, O) => typeof T == "string" || typeof T == "number" ? {
          props: {
            value: T,
            disabled: f.value
          },
          text: T.toString(),
          html: void 0,
          self: Symbol(`radioGroupOptionItem${O}`)
        } : {
          props: {
            value: T[a.valueField],
            disabled: T[a.disabledField],
            ...T.props ? T.props : {}
          },
          text: T[a.textField],
          html: T[a.htmlField],
          self: Symbol(`radioGroupOptionItem${O}`)
        }
      )
    ), k = d(() => ({
      required: y.value,
      ariaInvalid: a.ariaInvalid,
      state: m.value,
      validated: h.value,
      buttons: i.value,
      stacked: b.value,
      size: a.size
    })), w = Yo(k), B = Zo(k);
    return (T, O) => (g(), _("div", Q(s(w), {
      id: s(o),
      ref_key: "element",
      ref: $,
      role: "radiogroup",
      class: [s(B), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      x(T.$slots, "first"),
      (g(!0), _(ue, null, Be(s(v), (A) => (g(), D(Bn, Q({
        key: A.self
      }, A.props), {
        default: j(() => [
          A.html ? (g(), _("span", {
            key: 0,
            innerHTML: A.html
          }, null, 8, ju)) : (g(), _("span", {
            key: 1,
            textContent: J(A.text)
          }, null, 8, qu))
        ]),
        _: 2
      }, 1040))), 128)),
      x(T.$slots, "default")
    ], 16, Du));
  }
}), Wu = ["value", "disabled"], Xa = /* @__PURE__ */ R({
  __name: "BFormSelectOption",
  props: {
    value: { default: void 0 },
    disabled: { default: !1 }
  },
  setup(e) {
    const a = c(u(e, "disabled"));
    return (l, o) => (g(), _("option", {
      value: e.value,
      disabled: s(a)
    }, [
      x(l.$slots, "default")
    ], 8, Wu));
  }
}), Uu = ["label"], $n = /* @__PURE__ */ R({
  __name: "BFormSelectOptionGroup",
  props: {
    label: { default: void 0 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(e) {
    const t = e, a = d(
      () => Ga(t.options, "BFormSelectOptionGroup", t)
    );
    return (l, o) => (g(), _("optgroup", { label: e.label }, [
      x(l.$slots, "first"),
      (g(!0), _(ue, null, Be(s(a), (n, r) => (g(), D(Xa, Q({
        key: r,
        value: n.value,
        disabled: n.disabled
      }, l.$attrs, {
        innerHTML: n.html || n.text
      }), null, 16, ["value", "disabled", "innerHTML"]))), 128)),
      x(l.$slots, "default")
    ], 8, Uu));
  }
}), Xu = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"], Ku = /* @__PURE__ */ R({
  __name: "BFormSelect",
  props: {
    ariaInvalid: { default: void 0 },
    autofocus: { default: !1 },
    disabled: { default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    labelField: { default: "label" },
    multiple: { default: !1 },
    name: { default: void 0 },
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { default: !1 },
    required: { default: !1 },
    selectSize: { default: 0 },
    size: { default: void 0 },
    state: { default: void 0 },
    textField: { default: "text" },
    valueField: { default: "value" },
    modelValue: { default: "" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e, l = _e(a, "modelValue", t), o = ke(u(a, "id"), "input"), n = c(u(a, "autofocus")), r = c(u(a, "disabled")), i = c(u(a, "multiple")), f = c(u(a, "plain")), p = c(u(a, "required")), y = c(u(a, "state")), b = M();
    je(b, {
      initialValue: n.value
    });
    const m = d(() => ({
      "form-control": f.value,
      [`form-control-${a.size}`]: a.size && f.value,
      "form-select": !f.value,
      [`form-select-${a.size}`]: a.size && !f.value,
      "is-valid": y.value === !0,
      "is-invalid": y.value === !1
    })), h = d(() => {
      if (a.selectSize || f.value)
        return a.selectSize;
    }), $ = d(
      () => ra(a.ariaInvalid, y.value)
    ), v = d(() => Ga(a.options, "BFormSelect", a)), k = d({
      get: () => l.value,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set: (w) => {
        t("change", w), l.value = w, t("input", w);
      }
    });
    return (w, B) => nt((g(), _("select", Q({
      id: s(o),
      ref_key: "input",
      ref: b
    }, w.$attrs, {
      "onUpdate:modelValue": B[0] || (B[0] = (T) => kt(k) ? k.value = T : null),
      class: s(m),
      name: e.name,
      form: e.form || void 0,
      multiple: s(i) || void 0,
      size: s(h),
      disabled: s(r),
      required: s(p),
      "aria-required": s(p) ? !0 : void 0,
      "aria-invalid": s($)
    }), [
      x(w.$slots, "first"),
      (g(!0), _(ue, null, Be(s(v), (T, O) => (g(), _(ue, { key: O }, [
        Array.isArray(T.options) ? (g(), D($n, {
          key: 0,
          label: T.label,
          options: T.options
        }, null, 8, ["label", "options"])) : (g(), D(Xa, {
          key: 1,
          value: T.value,
          disabled: T.disabled,
          innerHTML: T.html || T.text
        }, null, 8, ["value", "disabled", "innerHTML"]))
      ], 64))), 128)),
      x(w.$slots, "default")
    ], 16, Xu)), [
      [jn, s(k)]
    ]);
  }
}), Ju = ["id"], wn = /* @__PURE__ */ R({
  __name: "BFormTag",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    disabled: { default: !1 },
    noRemove: { default: !1 },
    pill: { default: !1 },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(e, { emit: t }) {
    const a = e, l = Ee(), o = ke(u(a, "id")), n = c(u(a, "disabled")), r = c(u(a, "noRemove")), i = c(u(a, "pill")), f = d(
      () => {
        var b;
        return ((((b = l.default) == null ? void 0 : b.call(l)[0].children) ?? "").toString() || a.title) ?? "";
      }
    ), p = d(() => `${o.value}taglabel__`), y = d(() => [
      `bg-${a.variant}`,
      {
        "text-dark": ["warning", "info", "light"].includes(a.variant),
        "rounded-pill": i.value,
        disabled: n.value
      }
    ]);
    return (b, m) => (g(), D(le(e.tag), {
      id: s(o),
      title: s(f),
      class: N(["badge b-form-tag d-inline-flex align-items-center mw-100", s(y)]),
      "aria-labelledby": s(p)
    }, {
      default: j(() => [
        X("span", {
          id: s(p),
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          x(b.$slots, "default", {}, () => [
            ne(J(s(f)), 1)
          ])
        ], 8, Ju),
        !s(n) && !s(r) ? (g(), D(Tt, {
          key: 0,
          "aria-keyshortcuts": "Delete",
          "aria-label": e.removeLabel,
          class: "b-form-tag-remove",
          white: !["warning", "info", "light"].includes(e.variant),
          "aria-describedby": s(p),
          "aria-controls": e.id,
          onClick: m[0] || (m[0] = (h) => t("remove", s(f)))
        }, null, 8, ["aria-label", "white", "aria-describedby", "aria-controls"])) : Y("", !0)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
}), Yu = ["id"], Zu = ["id", "for", "aria-live"], Qu = ["id", "aria-live"], ed = ["id"], td = ["aria-controls"], ad = {
  role: "group",
  class: "d-flex"
}, ld = ["id", "disabled", "value", "type", "placeholder", "form", "required"], od = ["disabled"], nd = {
  "aria-live": "polite",
  "aria-atomic": "true"
}, sd = {
  key: 0,
  class: "d-block invalid-feedback"
}, id = {
  key: 1,
  class: "form-text text-muted"
}, rd = {
  key: 2,
  class: "form-text text-muted"
}, ud = ["name", "value"], dd = /* @__PURE__ */ R({
  __name: "BFormTags",
  props: {
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { default: !1 },
    autofocus: { default: !1 },
    disabled: { default: !1 },
    duplicateTagText: { default: "Duplicate tag(s)" },
    inputAttrs: { default: void 0 },
    inputClass: { default: void 0 },
    inputId: { default: void 0 },
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    form: { default: void 0 },
    limit: { default: void 0 },
    limitTagsText: { default: "Tag limit reached" },
    modelValue: { default: () => [] },
    name: { default: void 0 },
    noAddOnEnter: { default: !1 },
    noOuterFocus: { default: !1 },
    noTagRemove: { default: !1 },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { default: !1 },
    required: { default: !1 },
    separator: { default: void 0 },
    state: { default: void 0 },
    size: { default: void 0 },
    tagClass: { default: void 0 },
    tagPills: { default: !1 },
    tagRemoveLabel: { default: void 0 },
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => !0 },
    tagVariant: { default: "secondary" }
  },
  emits: ["update:modelValue", "input", "tag-state", "focus", "focusin", "focusout", "blur"],
  setup(e, { emit: t }) {
    const a = e, l = _e(a, "modelValue", t), o = ke(), n = c(u(a, "addOnChange")), r = c(u(a, "autofocus")), i = c(u(a, "disabled")), f = c(u(a, "noAddOnEnter")), p = c(u(a, "noOuterFocus")), y = c(u(a, "noTagRemove")), b = c(u(a, "removeOnDelete")), m = c(u(a, "required")), h = c(u(a, "state")), $ = c(u(a, "tagPills")), v = M(null), { focused: k } = je(v, {
      initialValue: r.value
    }), w = d(() => a.inputId || `${o.value}input__`), B = M(l.value), T = M(""), O = M(l.value.length > 0), A = M(!1), S = M(""), V = M([]), I = M([]), C = M([]), F = d(() => ({
      [`form-control-${a.size}`]: a.size !== void 0,
      disabled: i.value,
      focus: A.value,
      "is-invalid": h.value === !1,
      "is-valid": h.value === !0
    })), E = d(() => B.value.includes(T.value)), U = d(
      () => T.value === "" ? !1 : !a.tagValidator(T.value)
    ), q = d(() => B.value.length === a.limit), ae = d(() => !U.value && !E.value), Z = d(() => ({
      addButtonText: a.addButtonText,
      addButtonVariant: a.addButtonVariant,
      addTag: de,
      disableAddButton: ae.value,
      disabled: i.value,
      duplicateTagText: a.duplicateTagText,
      duplicateTags: C.value,
      form: a.form,
      inputAttrs: {
        ...a.inputAttrs,
        disabled: i.value,
        form: a.form,
        id: w,
        value: T
      },
      inputHandlers: {
        input: pe,
        keydown: oe,
        change: be
      },
      inputId: w,
      inputType: a.inputType,
      invalidTagText: a.invalidTagText,
      invalidTags: I.value,
      isDuplicate: E.value,
      isInvalid: U.value,
      isLimitReached: q.value,
      limitTagsText: a.limitTagsText,
      limit: a.limit,
      noTagRemove: y.value,
      placeholder: a.placeholder,
      removeTag: L,
      required: m.value,
      separator: a.separator,
      size: a.size,
      state: h.value,
      tagClass: a.tagClass,
      tagPills: $.value,
      tagRemoveLabel: a.tagRemoveLabel,
      tagVariant: a.tagVariant,
      tags: B.value
    }));
    ce(l, (z) => {
      B.value = z;
    });
    const G = (z) => {
      if (i.value) {
        z.target.blur();
        return;
      }
      t("focusin", z);
    }, te = (z) => {
      i.value || p.value || (A.value = !0, t("focus", z));
    }, fe = (z) => {
      A.value = !1, t("blur", z);
    }, pe = (z) => {
      var se, he;
      const ee = typeof z == "string" ? z : z.target.value;
      if (O.value = !1, (se = a.separator) != null && se.includes(ee.charAt(0)) && ee.length > 0) {
        v.value && (v.value.value = "");
        return;
      }
      if (T.value = ee, (he = a.separator) != null && he.includes(ee.charAt(ee.length - 1))) {
        de(ee.slice(0, ee.length - 1));
        return;
      }
      V.value = a.tagValidator(ee) && !E.value ? [ee] : [], I.value = a.tagValidator(ee) ? [] : [ee], C.value = E.value ? [ee] : [], t("tag-state", V.value, I.value, C.value);
    }, be = (z) => {
      n.value && (pe(z), E.value || de(T.value));
    }, oe = (z) => {
      if (z.key === "Enter" && !f.value) {
        de(T.value);
        return;
      }
      (z.key === "Backspace" || z.key === "Delete") && b.value && T.value === "" && O.value && B.value.length > 0 ? L(B.value[B.value.length - 1]) : O.value = !0;
    }, de = (z) => {
      if (z = (z || T.value).trim(), z === "" || E.value || !a.tagValidator(z) || a.limit && q.value)
        return;
      const ee = [...l.value, z];
      T.value = "", O.value = !0, l.value = ee, t("input", ee), k.value = !0;
    }, L = (z) => {
      const ee = B.value.indexOf((z == null ? void 0 : z.toString()) ?? "");
      S.value = B.value.splice(ee, 1).toString(), l.value = B.value;
    };
    return (z, ee) => (g(), _("div", {
      id: s(o),
      class: N(["b-form-tags form-control h-auto", s(F)]),
      role: "group",
      tabindex: "-1",
      onFocusin: G,
      onFocusout: ee[1] || (ee[1] = (se) => t("focusout", se))
    }, [
      X("output", {
        id: `${s(o)}selected_tags__`,
        class: "visually-hidden",
        for: s(w),
        "aria-live": A.value ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, J(B.value.join(", ")), 9, Zu),
      X("div", {
        id: `${s(o)}removed_tags__`,
        role: "status",
        "aria-live": A.value ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + J(e.tagRemovedLabel) + ") " + J(S.value), 9, Qu),
      x(z.$slots, "default", $e(Ve(s(Z))), () => [
        X("ul", {
          id: `${s(o)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (g(!0), _(ue, null, Be(B.value, (se, he) => x(z.$slots, "tag", $e(Q({ key: he }, { tag: se, tagClass: e.tagClass, tagVariant: e.tagVariant, tagPills: s($), removeTag: L })), () => [
            (g(), D(wn, {
              key: se,
              class: N(e.tagClass),
              tag: "li",
              variant: e.tagVariant,
              pill: e.tagPills,
              onRemove: L
            }, {
              default: j(() => [
                ne(J(se), 1)
              ]),
              _: 2
            }, 1032, ["class", "variant", "pill"]))
          ])), 128)),
          X("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${s(o)}tag_list__`
          }, [
            X("div", ad, [
              X("input", Q({
                id: s(w),
                ref_key: "input",
                ref: v,
                disabled: s(i),
                value: T.value,
                type: e.inputType,
                placeholder: e.placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, e.inputAttrs, {
                form: e.form,
                required: s(m),
                onInput: pe,
                onChange: be,
                onKeydown: oe,
                onFocus: te,
                onBlur: fe
              }), null, 16, ld),
              s(ae) ? (g(), _("button", {
                key: 0,
                type: "button",
                class: N(["btn b-form-tags-button py-0", [
                  `btn-${e.addButtonVariant}`,
                  {
                    "disabled invisible": T.value.length === 0
                  },
                  e.inputClass
                ]]),
                style: { "font-size": "90%" },
                disabled: s(i) || T.value.length === 0 || s(q),
                onClick: ee[0] || (ee[0] = (se) => de(T.value))
              }, [
                x(z.$slots, "add-button-text", {}, () => [
                  ne(J(e.addButtonText), 1)
                ])
              ], 10, od)) : Y("", !0)
            ])
          ], 8, td)
        ], 8, ed),
        X("div", nd, [
          s(U) ? (g(), _("div", sd, J(e.invalidTagText) + ": " + J(T.value), 1)) : Y("", !0),
          s(E) ? (g(), _("small", id, J(e.duplicateTagText) + ": " + J(T.value), 1)) : Y("", !0),
          B.value.length === e.limit ? (g(), _("small", rd, "Tag limit reached")) : Y("", !0)
        ])
      ]),
      e.name ? (g(!0), _(ue, { key: 0 }, Be(B.value, (se, he) => (g(), _("input", {
        key: he,
        type: "hidden",
        name: e.name,
        value: se
      }, null, 8, ud))), 128)) : Y("", !0)
    ], 42, Yu));
  }
}), cd = R({
  props: {
    ...Qo,
    noResize: { type: [Boolean, String], default: !1 },
    rows: { type: [String, Number], required: !1, default: 2 },
    wrap: { type: String, default: "soft" }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { emit: t }) {
    const { input: a, computedId: l, computedAriaInvalid: o, onInput: n, onChange: r, onBlur: i, focus: f, blur: p } = en(e, t), y = c(u(e, "noResize")), b = d(() => ({
      "form-control": !e.plaintext,
      "form-control-plaintext": e.plaintext,
      [`form-control-${e.size}`]: !!e.size,
      "is-valid": e.state === !0,
      "is-invalid": e.state === !1
    })), m = d(() => ({
      resize: y.value ? "none" : void 0
    }));
    return {
      input: a,
      computedId: l,
      computedAriaInvalid: o,
      onInput: n,
      onChange: r,
      onBlur: i,
      focus: f,
      blur: p,
      computedClasses: b,
      computedStyles: m
    };
  }
}), fd = ["id", "name", "form", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"];
function vd(e, t, a, l, o, n) {
  return g(), _("textarea", {
    id: e.computedId,
    ref: "input",
    class: N(e.computedClasses),
    name: e.name || void 0,
    form: e.form || void 0,
    disabled: e.disabled,
    placeholder: e.placeholder,
    required: e.required,
    autocomplete: e.autocomplete || void 0,
    readonly: e.readonly || e.plaintext,
    "aria-required": e.required ? !0 : void 0,
    "aria-invalid": e.computedAriaInvalid,
    rows: e.rows,
    style: Le(e.computedStyles),
    wrap: e.wrap || void 0,
    onInput: t[0] || (t[0] = (r) => e.onInput(r)),
    onChange: t[1] || (t[1] = (r) => e.onChange(r)),
    onBlur: t[2] || (t[2] = (r) => e.onBlur(r))
  }, null, 46, fd);
}
const md = /* @__PURE__ */ ze(cd, [["render", vd]]), pd = {
  key: 0,
  class: "input-group-text"
}, gd = ["innerHTML"], bd = { key: 1 }, hd = {
  key: 0,
  class: "input-group-text"
}, yd = ["innerHTML"], Bd = { key: 1 }, $d = /* @__PURE__ */ R({
  __name: "BInputGroup",
  props: {
    append: { default: void 0 },
    appendHtml: { default: void 0 },
    id: { default: void 0 },
    prepend: { default: void 0 },
    prependHtml: { default: void 0 },
    size: { default: void 0 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = d(() => ({
      "input-group-sm": t.size === "sm",
      "input-group-lg": t.size === "lg"
    })), l = d(() => !!t.append || !!t.appendHtml), o = d(() => !!t.prepend || !!t.prependHtml);
    return (n, r) => (g(), D(le(e.tag), {
      id: e.id,
      class: N(["input-group", s(a)]),
      role: "group"
    }, {
      default: j(() => [
        x(n.$slots, "prepend", {}, () => [
          s(o) ? (g(), _("span", pd, [
            e.prependHtml ? (g(), _("span", {
              key: 0,
              innerHTML: e.prependHtml
            }, null, 8, gd)) : (g(), _("span", bd, J(e.prepend), 1))
          ])) : Y("", !0)
        ]),
        x(n.$slots, "default"),
        x(n.$slots, "append", {}, () => [
          s(l) ? (g(), _("span", hd, [
            e.appendHtml ? (g(), _("span", {
              key: 0,
              innerHTML: e.appendHtml
            }, null, 8, yd)) : (g(), _("span", Bd, J(e.append), 1))
          ])) : Y("", !0)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), kn = /* @__PURE__ */ R({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, a) => (g(), D(le(e.tag), { class: "input-group-text" }, {
      default: j(() => [
        x(t.$slots, "default", {}, () => [
          ne(J(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), Ka = /* @__PURE__ */ R({
  __name: "BInputGroupAddon",
  props: {
    isText: { default: !1 }
  },
  setup(e) {
    const a = c(u(e, "isText"));
    return (l, o) => s(a) ? (g(), D(kn, { key: 0 }, {
      default: j(() => [
        x(l.$slots, "default")
      ]),
      _: 3
    })) : x(l.$slots, "default", { key: 1 });
  }
}), wd = /* @__PURE__ */ R({
  __name: "BInputGroupAppend",
  props: {
    isText: { default: !1 }
  },
  setup(e) {
    return (t, a) => (g(), D(Ka, { "is-text": e.isText }, {
      default: j(() => [
        x(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["is-text"]));
  }
}), kd = /* @__PURE__ */ R({
  __name: "BInputGroupPrepend",
  props: {
    isText: { default: !1 }
  },
  setup(e) {
    return (t, a) => (g(), D(Ka, { "is-text": e.isText }, {
      default: j(() => [
        x(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["is-text"]));
  }
}), Sd = /* @__PURE__ */ R({
  __name: "BListGroup",
  props: {
    flush: { default: !1 },
    horizontal: { type: [Boolean, String], default: !1 },
    numbered: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = c(u(t, "flush")), l = c(u(t, "numbered")), o = d(() => {
      const r = a.value ? !1 : t.horizontal;
      return {
        "list-group-flush": a.value,
        "list-group-horizontal": r === !0,
        [`list-group-horizontal-${r}`]: typeof r == "string",
        "list-group-numbered": l.value
      };
    }), n = d(() => l.value === !0 ? "ol" : t.tag);
    return ot(Bo, {
      numbered: l
    }), (r, i) => (g(), D(le(s(n)), {
      class: N(["list-group", s(o)])
    }, {
      default: j(() => [
        x(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Cd = /* @__PURE__ */ R({
  __name: "BListGroupItem",
  props: {
    action: { default: !1 },
    active: { default: !1 },
    button: { default: !1 },
    disabled: { default: !1 },
    href: { default: void 0 },
    tag: { default: "div" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = to(), l = We(Bo, null), o = c(u(t, "action")), n = c(u(t, "active")), r = c(u(t, "button")), i = c(u(t, "disabled")), f = d(() => !r.value && (!!t.href || !!t.to)), p = d(
      () => l != null && l.numbered.value ? "li" : r.value ? "button" : f.value ? Ne : t.tag
    ), y = d(
      () => o.value || f.value || r.value || ["a", "router-link", "button", "b-link"].includes(t.tag)
    ), b = d(() => ({
      [`list-group-item-${t.variant}`]: t.variant !== void 0,
      "list-group-item-action": y.value,
      active: n.value,
      disabled: i.value
    })), m = d(() => {
      const h = {};
      return r.value && ((!a || !a.type) && (h.type = "button"), i.value && (h.disabled = !0)), h;
    });
    return (h, $) => (g(), D(le(s(p)), Q({
      class: ["list-group-item", s(b)],
      "aria-current": s(n) ? !0 : void 0,
      "aria-disabled": s(i) ? !0 : void 0,
      target: s(f) ? e.target : void 0,
      href: s(r) ? void 0 : e.href,
      to: s(r) ? void 0 : e.to
    }, s(m)), {
      default: j(() => [
        x(h.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
}), Td = ["id", "aria-labelledby", "aria-describedby"], _d = ["id"], xd = {
  inheritAttrs: !1
}, Ad = /* @__PURE__ */ R({
  ...xd,
  __name: "BModal",
  props: {
    bodyBgVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTextVariant: { default: void 0 },
    busy: { default: !1 },
    lazy: { default: !1 },
    buttonSize: { default: "md" },
    cancelDisabled: { default: !1 },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { default: !1 },
    contentClass: { default: void 0 },
    dialogClass: { default: void 0 },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerTextVariant: { default: void 0 },
    fullscreen: { type: [Boolean, String], default: !1 },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseWhite: { default: !1 },
    headerTextVariant: { default: void 0 },
    hideBackdrop: { default: !1 },
    hideFooter: { default: !1 },
    hideHeader: { default: !1 },
    hideHeaderClose: { default: !1 },
    id: { default: void 0 },
    modalClass: { default: void 0 },
    modelValue: { default: !1 },
    noCloseOnBackdrop: { default: !1 },
    noCloseOnEsc: { default: !1 },
    noFade: { default: !1 },
    autoFocus: { default: !0 },
    okDisabled: { default: !1 },
    okOnly: { default: !1 },
    okTitle: { default: "Ok" },
    okVariant: { default: "primary" },
    scrollable: { default: !1 },
    show: { default: !1 },
    size: { default: void 0 },
    title: { default: void 0 },
    titleClass: { default: void 0 },
    titleSrOnly: { default: !1 },
    titleTag: { default: "h5" },
    static: { default: !1 },
    autoFocusButton: { default: void 0 }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "ok", "cancel", "close"],
  setup(e, { emit: t }) {
    const a = e, l = Ee(), o = ke(u(a, "id"), "modal"), n = _e(a, "modelValue", t), r = c(u(a, "busy")), i = c(u(a, "lazy")), f = c(u(a, "cancelDisabled")), p = c(u(a, "centered")), y = c(u(a, "hideBackdrop")), b = c(u(a, "hideFooter")), m = c(u(a, "hideHeader")), h = c(u(a, "hideHeaderClose")), $ = c(n), v = c(u(a, "noCloseOnBackdrop")), k = c(u(a, "noCloseOnEsc")), w = c(u(a, "noFade")), B = c(u(a, "autoFocus")), T = c(u(a, "okDisabled")), O = c(u(a, "okOnly")), A = c(u(a, "scrollable")), S = c(u(a, "titleSrOnly")), V = c(u(a, "static")), I = M(null), C = M(null), F = M(null), E = M(null), U = M($.value), q = M(!1), { focused: ae } = je(I, {
      initialValue: $.value && a.autoFocusButton === void 0
    }), { focused: Z } = je(C, {
      initialValue: $.value && a.autoFocusButton === "ok"
    }), { focused: G } = je(F, {
      initialValue: $.value && a.autoFocusButton === "cancel"
    }), { focused: te } = je(E, {
      initialValue: $.value && a.autoFocusButton === "close"
    }), fe = d(() => [
      a.modalClass,
      {
        fade: !w.value,
        show: U.value
      }
    ]), pe = d(
      () => i.value === !1 || i.value === !0 && q.value === !0 || i.value === !0 && $.value === !0
    ), be = d(() => !Pe(l["header-close"])), oe = d(() => [
      a.dialogClass,
      {
        "modal-fullscreen": a.fullscreen === !0,
        [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == "string",
        [`modal-${a.size}`]: a.size !== void 0,
        "modal-dialog-centered": p.value,
        "modal-dialog-scrollable": A.value
      }
    ]), de = d(() => [
      a.bodyClass,
      {
        [`bg-${a.bodyBgVariant}`]: a.bodyBgVariant !== void 0,
        [`text-${a.bodyTextVariant}`]: a.bodyTextVariant !== void 0
      }
    ]), L = d(() => [
      a.headerClass,
      {
        [`bg-${a.headerBgVariant}`]: a.headerBgVariant !== void 0,
        [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== void 0,
        [`text-${a.headerTextVariant}`]: a.headerTextVariant !== void 0
      }
    ]), z = d(() => [
      a.footerClass,
      {
        [`bg-${a.footerBgVariant}`]: a.footerBgVariant !== void 0,
        [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== void 0,
        [`text-${a.footerTextVariant}`]: a.footerTextVariant !== void 0
      }
    ]), ee = d(() => [
      a.titleClass,
      {
        ["visually-hidden"]: S.value
      }
    ]), se = d(() => f.value || r.value), he = d(() => T.value || r.value), xe = (H, ve = {}) => new It(H, {
      cancelable: !1,
      target: I.value || null,
      relatedTarget: null,
      trigger: null,
      ...ve,
      componentId: o.value
    }), W = (H = "") => {
      const ve = xe("hide", { cancelable: H !== "", trigger: H });
      if (H === "ok" && t(H, ve), H === "cancel" && t(H, ve), H === "close" && t(H, ve), t("hide", ve), ve.defaultPrevented || H === "backdrop" && v.value || H === "esc" && k.value) {
        t("hide-prevented");
        return;
      }
      n.value = !1;
    }, re = () => {
      const H = xe("show", { cancelable: !0 });
      if (t("show", H), H.defaultPrevented) {
        n.value = !1, t("show-prevented");
        return;
      }
      n.value = !0;
    }, De = () => {
      B.value !== !1 && (a.autoFocusButton === "ok" ? Z.value = !0 : a.autoFocusButton === "close" ? te.value = !0 : a.autoFocusButton === "cancel" ? G.value = !0 : ae.value = !0);
    }, Ie = () => re(), P = () => {
      U.value = !0, De(), t("shown", xe("shown")), i.value === !0 && (q.value = !0);
    }, K = () => U.value = !1, ge = () => {
      t("hidden", xe("hidden")), i.value === !0 && (q.value = !1);
    };
    return we(I, "bv-toggle", () => {
      $.value ? W() : re();
    }), (H, ve) => (g(), D(La, {
      to: "body",
      disabled: s(V)
    }, [
      ye(Ct, {
        "no-fade": !0,
        "trans-props": { enterToClass: "show" },
        onBeforeEnter: Ie,
        onAfterEnter: P,
        onLeave: K,
        onAfterLeave: ge
      }, {
        default: j(() => [
          nt(X("div", Q({
            id: s(o),
            ref_key: "element",
            ref: I,
            class: ["modal", s(fe)],
            role: "dialog",
            "aria-labelledby": `${s(o)}-label`,
            "aria-describedby": `${s(o)}-body`,
            tabindex: "-1"
          }, H.$attrs, {
            onKeyup: ve[5] || (ve[5] = Ot((me) => W("esc"), ["esc"]))
          }), [
            X("div", {
              class: N(["modal-dialog", s(oe)])
            }, [
              s(pe) ? (g(), _("div", {
                key: 0,
                class: N(["modal-content", e.contentClass])
              }, [
                s(m) ? Y("", !0) : (g(), _("div", {
                  key: 0,
                  class: N(["modal-header", s(L)])
                }, [
                  x(H.$slots, "header", {}, () => [
                    (g(), D(le(e.titleTag), {
                      id: `${s(o)}-label`,
                      class: N(["modal-title", s(ee)])
                    }, {
                      default: j(() => [
                        x(H.$slots, "title", {}, () => [
                          ne(J(e.title), 1)
                        ], !0)
                      ]),
                      _: 3
                    }, 8, ["id", "class"])),
                    s(h) ? Y("", !0) : (g(), _(ue, { key: 0 }, [
                      s(be) ? (g(), _("button", {
                        key: 0,
                        type: "button",
                        onClick: ve[0] || (ve[0] = (me) => W("close"))
                      }, [
                        x(H.$slots, "header-close", {}, void 0, !0)
                      ])) : (g(), D(Tt, {
                        key: 1,
                        ref_key: "closeButton",
                        ref: E,
                        "aria-label": e.headerCloseLabel,
                        white: e.headerCloseWhite,
                        onClick: ve[1] || (ve[1] = (me) => W("close"))
                      }, null, 8, ["aria-label", "white"]))
                    ], 64))
                  ], !0)
                ], 2)),
                X("div", {
                  id: `${s(o)}-body`,
                  class: N(["modal-body", s(de)])
                }, [
                  x(H.$slots, "default", {}, void 0, !0)
                ], 10, _d),
                s(b) ? Y("", !0) : (g(), _("div", {
                  key: 1,
                  class: N(["modal-footer", s(z)])
                }, [
                  x(H.$slots, "footer", {}, () => [
                    x(H.$slots, "cancel", {}, () => [
                      s(O) ? Y("", !0) : (g(), D(wt, {
                        key: 0,
                        ref_key: "cancelButton",
                        ref: F,
                        type: "button",
                        class: "btn",
                        disabled: s(se),
                        size: e.buttonSize,
                        variant: e.cancelVariant,
                        onClick: ve[2] || (ve[2] = (me) => W("cancel"))
                      }, {
                        default: j(() => [
                          ne(J(e.cancelTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"]))
                    ], !0),
                    x(H.$slots, "ok", {}, () => [
                      ye(wt, {
                        ref_key: "okButton",
                        ref: C,
                        type: "button",
                        class: "btn",
                        disabled: s(he),
                        size: e.buttonSize,
                        variant: e.okVariant,
                        onClick: ve[3] || (ve[3] = (me) => W("ok"))
                      }, {
                        default: j(() => [
                          ne(J(e.okTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"])
                    ], !0)
                  ], !0)
                ], 2))
              ], 2)) : Y("", !0)
            ], 2),
            s(y) ? Y("", !0) : x(H.$slots, "backdrop", { key: 0 }, () => [
              X("div", {
                class: "modal-backdrop fade show",
                onClick: ve[4] || (ve[4] = (me) => W("backdrop"))
              })
            ], !0)
          ], 16, Td), [
            [oa, s($)]
          ])
        ]),
        _: 3
      })
    ], 8, ["disabled"]));
  }
});
const Vd = /* @__PURE__ */ ze(Ad, [["__scopeId", "data-v-3fff7a81"]]), Od = /* @__PURE__ */ R({
  __name: "BNav",
  props: {
    align: { default: void 0 },
    cardHeader: { default: !1 },
    fill: { default: !1 },
    justified: { default: !1 },
    pills: { default: !1 },
    small: { default: !1 },
    tabs: { default: !1 },
    tag: { default: "ul" },
    vertical: { default: !1 }
  },
  setup(e) {
    const t = e, a = c(u(t, "cardHeader")), l = c(u(t, "fill")), o = c(u(t, "justified")), n = c(u(t, "pills")), r = c(u(t, "small")), i = c(u(t, "tabs")), f = c(u(t, "vertical")), p = Nt(u(t, "align")), y = d(() => ({
      "nav-tabs": i.value,
      "nav-pills": n.value && !i.value,
      "card-header-tabs": !f.value && a.value && i.value,
      "card-header-pills": !f.value && a.value && n.value && !i.value,
      "flex-column": f.value,
      "nav-fill": !f.value && l.value,
      "nav-justified": !f.value && o.value,
      [p.value]: !f.value && t.align !== void 0,
      small: r.value
    }));
    return (b, m) => (g(), D(le(e.tag), {
      class: N(["nav", s(y)])
    }, {
      default: j(() => [
        x(b.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Pd = /* @__PURE__ */ R({
  __name: "BNavForm",
  props: {
    role: { default: void 0 },
    id: { default: void 0 },
    floating: { default: !1 },
    novalidate: { default: !1 },
    validated: { default: !1 }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const a = e, l = d(() => ({
      floating: a.floating,
      role: a.role,
      id: a.id,
      novalidate: a.novalidate,
      validated: a.validated
    })), o = (n) => t("submit", n);
    return (n, r) => (g(), D(bn, Q(s(l), {
      class: "d-flex",
      onSubmit: ct(o, ["prevent"])
    }), {
      default: j(() => [
        x(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["onSubmit"]));
  }
}), Ed = R({
  components: { BLink: Ne },
  props: {
    ...Ft(vt, ["event", "routerTag"])
  },
  setup(e) {
    return { disabledBoolean: c(u(e, "disabled")) };
  }
}), Id = { class: "nav-item" };
function Fd(e, t, a, l, o, n) {
  const r = eo("b-link");
  return g(), _("li", Id, [
    ye(r, Q({ class: "nav-link" }, e.$props, {
      "active-class": "active",
      tabindex: e.disabledBoolean ? -1 : void 0,
      "aria-disabled": e.disabledBoolean ? !0 : void 0
    }), {
      default: j(() => [
        x(e.$slots, "default")
      ]),
      _: 3
    }, 16, ["tabindex", "aria-disabled"])
  ]);
}
const Ld = /* @__PURE__ */ ze(Ed, [["render", Fd]]), Nd = { class: "nav-item dropdown" }, zd = /* @__PURE__ */ R({
  __name: "BNavItemDropdown",
  props: {
    id: { default: void 0 },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    size: { default: void 0 },
    offset: { default: void 0 },
    autoClose: { type: [Boolean, String], default: void 0 },
    dark: { default: void 0 },
    splitVariant: { default: void 0 },
    noCaret: { default: void 0 },
    variant: { default: "link" },
    modelValue: { default: !1 },
    lazy: { default: void 0 },
    strategy: { default: void 0 },
    floatingMiddleware: { default: void 0 },
    noFlip: { default: void 0 },
    noShift: { default: void 0 },
    dropup: { default: void 0 },
    dropend: { default: void 0 },
    dropstart: { default: void 0 },
    alignStart: { default: void 0 },
    alignEnd: { default: void 0 },
    menuClass: { default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = _e(a, "modelValue", t), o = c(l), n = d({
      get: () => o.value,
      set: (i) => l.value = i
    }), r = d(() => Ft(a, ["modelValue"]));
    return (i, f) => (g(), _("li", Nd, [
      ye(gn, Q({
        modelValue: s(n),
        "onUpdate:modelValue": f[0] || (f[0] = (p) => kt(n) ? n.value = p : null)
      }, s(r), { "is-nav": "" }), {
        "button-content": j(() => [
          x(i.$slots, "button-content")
        ]),
        "toggle-text": j(() => [
          x(i.$slots, "toggle-text")
        ]),
        default: j(() => [
          x(i.$slots, "default")
        ]),
        _: 3
      }, 16, ["modelValue"])
    ]));
  }
}), Rd = { class: "navbar-text" }, Hd = /* @__PURE__ */ R({
  __name: "BNavText",
  props: {
    text: { default: void 0 }
  },
  setup(e) {
    return (t, a) => (g(), _("li", Rd, [
      x(t.$slots, "default", {}, () => [
        ne(J(e.text), 1)
      ])
    ]));
  }
}), Md = /* @__PURE__ */ R({
  __name: "BNavbar",
  props: {
    fixed: { default: void 0 },
    print: { default: !1 },
    sticky: { default: void 0 },
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: !1 },
    dark: { default: !1 },
    variant: { default: void 0 },
    container: { type: [String, Boolean], default: "fluid" }
  },
  setup(e) {
    const t = e, a = c(u(t, "print")), l = c(u(t, "dark")), o = d(
      () => t.tag === "nav" ? void 0 : "navigation"
    ), n = d(
      () => typeof t.toggleable == "string" ? `navbar-expand-${t.toggleable}` : t.toggleable === !1 ? "navbar-expand" : void 0
    ), r = d(
      () => t.container === !0 ? "container" : "container-fluid"
    ), i = d(() => ({
      "d-print": a.value,
      [`sticky-${t.sticky}`]: t.sticky !== void 0,
      "navbar-dark": l.value,
      [`bg-${t.variant}`]: t.variant !== void 0,
      [`fixed-${t.fixed}`]: t.fixed !== void 0,
      [`${n.value}`]: n.value !== void 0
    }));
    return (f, p) => (g(), D(le(e.tag), {
      class: N(["navbar", s(i)]),
      role: s(o)
    }, {
      default: j(() => [
        e.container !== !1 ? (g(), _("div", {
          key: 0,
          class: N(s(r))
        }, [
          x(f.$slots, "default")
        ], 2)) : x(f.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
}), Fl = Ft(vt, ["event", "routerTag"]), Dd = R({
  components: {
    BLink: Ne
  },
  props: {
    tag: { type: String, default: "div" },
    ...Fl
  },
  setup(e) {
    const t = d(() => Pt(e)), a = d(
      () => t.value ? Ne : e.tag
    );
    return {
      computedLinkProps: d(
        () => t.value ? Ha(e, Fl) : {}
      ),
      computedTag: a
    };
  }
});
function jd(e, t, a, l, o, n) {
  return g(), D(le(e.computedTag), Q({ class: "navbar-brand" }, e.computedLinkProps), {
    default: j(() => [
      x(e.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const qd = /* @__PURE__ */ ze(Dd, [["render", jd]]), Gd = /* @__PURE__ */ R({
  __name: "BNavbarNav",
  props: {
    align: { default: void 0 },
    fill: { default: !1 },
    justified: { default: !1 },
    small: { default: !1 },
    tag: { default: "ul" }
  },
  setup(e) {
    const t = e, a = c(u(t, "fill")), l = c(u(t, "justified")), o = c(u(t, "small")), n = Nt(u(t, "align")), r = d(() => ({
      "nav-fill": a.value,
      "nav-justified": l.value,
      [n.value]: t.align !== void 0,
      small: o.value
    }));
    return (i, f) => (g(), _("ul", {
      class: N(["navbar-nav", s(r)])
    }, [
      x(i.$slots, "default")
    ], 2));
  }
}), Ll = (e, t) => e.setAttribute("data-bs-theme", t), Wd = {
  mounted(e, t) {
    Ll(e, t.value);
  },
  updated(e, t) {
    Ll(e, t.value);
  }
}, Ja = (e, t) => {
  const { modifiers: a, arg: l, value: o } = e, n = Object.keys(a || {}), r = typeof o == "string" ? o.split(Dt) : o;
  if (ps(t.tagName, "a")) {
    const i = Ra(t, "href") || "";
    Kn.test(i) && n.push(i.replace(Xn, ""));
  }
  return Array.prototype.concat.apply([], [l, r]).forEach((i) => typeof i == "string" && n.push(i)), n.filter((i, f, p) => i && p.indexOf(i) === f);
}, Ud = (e, t) => {
  Ja(e, t).forEach((l) => {
    const o = document.getElementById(l);
    o !== null && o.dispatchEvent(new Event("bv-toggle"));
  }), setTimeout(() => Sn(e, t), 50);
}, Sn = (e, t) => {
  const a = Ja(e, t);
  let l = !1;
  a.forEach((o) => {
    const n = document.getElementById(o);
    n != null && n.classList.contains("show") && (l = !0), n != null && n.classList.contains("closing") && (l = !1);
  }), t.setAttribute("aria-expanded", l ? "true" : "false");
}, Oa = {
  mounted(e, t) {
    e.__toggle = () => Ud(t, e), e.addEventListener("click", e.__toggle), Sn(t, e), e.setAttribute("aria-controls", Ja(t, e).join(" "));
  },
  unmounted(e) {
    e.removeEventListener("click", e.__toggle), e.removeAttribute("aria-controls"), e.removeAttribute("aria-expanded");
  }
}, Xd = {
  mounted(e, t) {
    const a = ta(t.value, e);
    e.$__state = M({
      ...aa(t, e),
      ...a
    }), tn(e, t);
  },
  updated(e, t) {
    const a = ta(t.value, e);
    e.$__state && (e.$__state.value = {
      ...aa(t, e),
      ...a
    });
  },
  beforeUnmount(e) {
    an(e);
  }
}, Kd = {
  mounted(e, t) {
    const a = ta(t.value, e);
    e.$__state = M({
      ...aa(t, e),
      title: a.title ?? a.content ?? "",
      tooltip: !0
    }), tn(e, t);
  },
  updated(e, t) {
    const a = ta(t.value, e);
    e.$__state && (e.$__state.value = {
      ...aa(t, e),
      title: a.title ?? a.content ?? "",
      tooltip: !0
    });
  },
  beforeUnmount(e) {
    an(e);
  }
}, Jd = /* @__PURE__ */ X("span", { class: "navbar-toggler-icon" }, null, -1), Yd = /* @__PURE__ */ R({
  __name: "BNavbarToggle",
  props: {
    disabled: { default: !1 },
    label: { default: "Toggle navigation" },
    target: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(u(a, "disabled")), o = d(() => ({
      disabled: l.value,
      "aria-label": a.label
    })), n = d(() => ({
      disabled: l.value
    })), r = (i) => {
      l.value || t("click", i);
    };
    return (i, f) => nt((g(), _("button", Q({
      class: ["navbar-toggler", s(n)],
      type: "button"
    }, s(o), { onClick: r }), [
      x(i.$slots, "default", {}, () => [
        Jd
      ])
    ], 16)), [
      [s(Oa), s(l) ? void 0 : e.target]
    ]);
  }
}), Cn = /* @__PURE__ */ R({
  __name: "BOverlay",
  props: {
    bgColor: { default: void 0 },
    blur: { default: "2px" },
    fixed: { default: !1 },
    noCenter: { default: !1 },
    noFade: { default: !1 },
    noWrap: { default: !1 },
    opacity: { default: 0.85 },
    overlayTag: { default: "div" },
    rounded: { type: [Boolean, String], default: !1 },
    show: { default: !1 },
    spinnerSmall: { default: !1 },
    spinnerType: { default: "border" },
    spinnerVariant: { default: void 0 },
    noSpinner: { default: !1 },
    variant: { default: "light" },
    wrapTag: { default: "div" },
    zIndex: { default: 10 }
  },
  emits: ["click", "hidden", "shown"],
  setup(e, { emit: t }) {
    const a = e, l = { top: 0, left: 0, bottom: 0, right: 0 }, o = c(u(a, "fixed")), n = c(u(a, "noSpinner")), r = c(u(a, "noCenter")), i = c(u(a, "noWrap")), f = c(u(a, "show")), p = c(u(a, "spinnerSmall")), y = d(
      () => a.rounded === !0 || a.rounded === "" ? "rounded" : a.rounded === !1 ? "" : `rounded-${a.rounded}`
    ), b = d(
      () => a.variant && !a.bgColor ? `bg-${a.variant}` : ""
    ), m = d(() => f.value ? !0 : null), h = d(() => ({
      type: a.spinnerType || void 0,
      variant: a.spinnerVariant || void 0,
      small: p.value
    })), $ = d(() => ({
      ...l,
      zIndex: a.zIndex || 10
    })), v = d(() => [
      "b-overlay",
      {
        "position-absolute": !i.value || !o.value,
        "position-fixed": i.value && o.value
      }
    ]), k = d(() => [b.value, y.value]), w = d(() => ({
      ...l,
      opacity: a.opacity,
      backgroundColor: a.bgColor || void 0,
      backdropFilter: blur ? `blur(${blur})` : void 0
    })), B = d(
      () => r.value ? l : {
        top: "50%",
        left: "50%",
        transform: "translateX(-50%) translateY(-50%)"
      }
    );
    return (T, O) => (g(), D(le(e.wrapTag), {
      class: "b-overlay-wrap position-relative",
      "aria-busy": s(m)
    }, {
      default: j(() => [
        x(T.$slots, "default"),
        ye(Ct, {
          "no-fade": e.noFade,
          "trans-props": { enterToClass: "show" },
          name: "fade",
          onOnAfterEnter: O[1] || (O[1] = (A) => t("shown")),
          onOnAfterLeave: O[2] || (O[2] = (A) => t("hidden"))
        }, {
          default: j(() => [
            s(f) ? (g(), D(le(e.overlayTag), {
              key: 0,
              class: N(s(v)),
              style: Le(s($)),
              onClick: O[0] || (O[0] = (A) => t("click", A))
            }, {
              default: j(() => [
                X("div", {
                  class: N(["position-absolute", s(k)]),
                  style: Le(s(w))
                }, null, 6),
                X("div", {
                  class: "position-absolute",
                  style: Le(s(B))
                }, [
                  x(T.$slots, "overlay", $e(Ve(s(h))), () => [
                    s(n) ? Y("", !0) : (g(), D(ca, $e(Q({ key: 0 }, s(h))), null, 16))
                  ])
                ], 4)
              ]),
              _: 3
            }, 8, ["class", "style"])) : Y("", !0)
          ]),
          _: 3
        }, 8, ["no-fade"])
      ]),
      _: 3
    }, 8, ["aria-busy"]));
  }
}), Zd = {
  key: 0,
  class: "offcanvas-header"
}, Qd = {
  id: "offcanvasLabel",
  class: "offcanvas-title"
}, ec = { class: "offcanvas-body" }, tc = { key: 1 }, ac = {
  inheritAttrs: !1
}, lc = /* @__PURE__ */ R({
  ...ac,
  __name: "BOffcanvas",
  props: {
    dismissLabel: { default: "Close" },
    modelValue: { default: !1 },
    bodyScrolling: { default: !1 },
    backdrop: { default: !0 },
    noCloseOnBackdrop: { default: !1 },
    noCloseOnEsc: { default: !1 },
    placement: { default: "start" },
    title: { default: void 0 },
    noHeaderClose: { default: !1 },
    noHeader: { default: !1 },
    lazy: { default: !1 },
    id: { default: void 0 },
    noFocus: { default: !1 },
    static: { default: !1 },
    backdropVariant: { default: "dark" }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "esc", "close"],
  setup(e, { emit: t }) {
    const a = e, l = Ee(), o = _e(a, "modelValue", t), n = c(o);
    c(u(a, "bodyScrolling"));
    const r = c(u(a, "backdrop")), i = c(u(a, "noHeaderClose")), f = c(u(a, "noHeader")), p = c(u(a, "noFocus")), y = c(u(a, "noCloseOnBackdrop")), b = c(u(a, "noCloseOnEsc")), m = c(u(a, "lazy")), h = c(u(a, "static")), $ = ke(u(a, "id"), "offcanvas"), v = M(null), { focused: k } = je(v, {
      initialValue: n.value && p.value === !1
    }), w = M(n.value), B = M(!1), T = d(
      () => r.value === !0 && n.value === !0
    ), O = d(
      () => m.value === !1 || m.value === !0 && B.value === !0 || m.value === !0 && n.value === !0
    ), A = d(() => !Pe(l.footer)), S = d(() => [
      // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,
      "offcanvas",
      // Remove when above check is fixed
      `offcanvas-${a.placement}`,
      {
        show: n.value && w.value === !0
      }
    ]), V = (Z, G = {}) => new It(Z, {
      cancelable: !1,
      target: v.value || null,
      relatedTarget: null,
      trigger: null,
      ...G,
      componentId: $.value
    }), I = (Z = "") => {
      const G = V("hide", { cancelable: Z !== "", trigger: Z });
      if (Z === "close" && t(Z, G), Z === "esc" && t(Z, G), t("hide", G), G.defaultPrevented || Z === "backdrop" && y.value || Z === "esc" && b.value) {
        t("hide-prevented");
        return;
      }
      o.value = !1;
    }, C = () => {
      const Z = V("show", { cancelable: !0 });
      if (t("show", Z), Z.defaultPrevented) {
        o.value = !1, t("show-prevented");
        return;
      }
      o.value = !0;
    }, F = () => {
      Ce(() => {
        p.value === !1 && (k.value = !0);
      });
    }, E = () => C(), U = () => {
      w.value = !0, F(), t("shown", V("shown")), m.value === !0 && (B.value = !0);
    }, q = () => w.value = !1, ae = () => {
      t("hidden", V("hidden")), m.value === !0 && (B.value = !1);
    };
    return we(v, "bv-toggle", () => {
      n.value ? I() : C();
    }), (Z, G) => (g(), D(La, {
      to: "body",
      disabled: s(h)
    }, [
      ye(Ct, {
        "no-fade": !0,
        "trans-props": {
          enterToClass: "showing",
          enterFromClass: "",
          leaveToClass: "hiding show",
          leaveFromClass: "show"
        },
        onBeforeEnter: E,
        onAfterEnter: U,
        onLeave: q,
        onAfterLeave: ae
      }, {
        default: j(() => [
          nt(X("div", Q({
            ref_key: "element",
            ref: v,
            "aria-modal": "true",
            role: "dialog",
            class: s(S),
            tabindex: "-1",
            "aria-labelledby": "offcanvasLabel",
            "data-bs-backdrop": "false"
          }, Z.$attrs, {
            onKeyup: G[1] || (G[1] = Ot((te) => I("esc"), ["esc"]))
          }), [
            s(O) ? (g(), _(ue, { key: 0 }, [
              s(f) ? Y("", !0) : (g(), _("div", Zd, [
                x(Z.$slots, "header", $e(Ve({ visible: s(n), placement: e.placement, hide: I })), () => [
                  X("h5", Qd, [
                    x(Z.$slots, "title", {}, () => [
                      ne(J(e.title), 1)
                    ])
                  ]),
                  s(i) ? Y("", !0) : (g(), D(Tt, {
                    key: 0,
                    class: "text-reset",
                    "aria-label": e.dismissLabel,
                    onClick: G[0] || (G[0] = (te) => I("close"))
                  }, null, 8, ["aria-label"]))
                ])
              ])),
              X("div", ec, [
                x(Z.$slots, "default")
              ]),
              s(A) ? (g(), _("div", tc, [
                x(Z.$slots, "footer", $e(Ve({ visible: s(n), placement: e.placement, hide: I })))
              ])) : Y("", !0)
            ], 64)) : Y("", !0)
          ], 16), [
            [oa, s(o)]
          ])
        ]),
        _: 3
      }),
      ye(Cn, {
        variant: e.backdropVariant,
        show: s(T),
        fixed: !0,
        "no-wrap": "",
        "no-spinner": !0,
        onClick: G[2] || (G[2] = (te) => I("backdrop"))
      }, null, 8, ["variant", "show"])
    ], 8, ["disabled"]));
  }
}), oc = 5, Tn = 20, _n = 0, Ue = 3, nc = "ellipsis-text", sc = "first-text", ic = "last-text", rc = "next-text", uc = "page", dc = "prev-text", Nl = (e) => Math.max(tt(e) || Tn, 1), zl = (e) => Math.max(tt(e) || _n, 0), cc = (e, t) => {
  const a = tt(e) || 1;
  return a > t ? t : a < 1 ? 1 : a;
}, fc = R({
  name: "BPagination",
  props: {
    align: { type: String, default: "start" },
    ariaControls: { type: String, default: void 0 },
    ariaLabel: { type: String, default: "Pagination" },
    disabled: { type: [Boolean, String], default: !1 },
    ellipsisClass: { type: [Array, String], default: () => [] },
    ellipsisText: { type: String, default: "â¦" },
    firstClass: { type: [Array, String], default: () => [] },
    firstNumber: { type: [Boolean, String], default: !1 },
    firstText: { type: String, default: "Â«" },
    hideEllipsis: { type: [Boolean, String], default: !1 },
    hideGotoEndButtons: { type: [Boolean, String], default: !1 },
    labelFirstPage: { type: String, default: "Go to first page" },
    labelLastPage: { type: String, default: "Go to last page" },
    labelNextPage: { type: String, default: "Go to next page" },
    labelPage: { type: String, default: "Go to page" },
    labelPrevPage: { type: String, default: "Go to previous page" },
    lastClass: { type: [Array, String], default: () => [] },
    lastNumber: { type: [Boolean, String], default: !1 },
    lastText: { type: String, default: "Â»" },
    limit: { type: Number, default: oc },
    modelValue: { type: Number, default: 1 },
    // V-model prop
    nextClass: { type: [Array, String], default: () => [] },
    nextText: { type: String, default: "âº" },
    pageClass: { type: [Array, String], default: () => [] },
    perPage: { type: Number, default: Tn },
    pills: { type: [Boolean, String], default: !1 },
    prevClass: { type: [Array, String], default: () => [] },
    prevText: { type: String, default: "â¹" },
    size: { type: String, default: void 0 },
    totalRows: { type: Number, default: _n }
  },
  emits: ["update:modelValue", "page-click"],
  setup(e, { emit: t, slots: a }) {
    const l = _e(e, "modelValue", t), o = c(u(e, "disabled")), n = c(u(e, "firstNumber")), r = c(u(e, "hideEllipsis")), i = c(u(e, "hideGotoEndButtons")), f = c(u(e, "lastNumber")), p = c(u(e, "pills")), y = d(
      () => e.align === "fill" ? "start" : e.align
    ), b = Nt(u(y, "value")), m = d(
      () => Math.ceil(zl(e.totalRows) / Nl(e.perPage))
    ), h = d(() => {
      let S;
      return m.value - l.value + 2 < e.limit && e.limit > Ue ? S = m.value - v.value + 1 : S = l.value - Math.floor(v.value / 2), S < 1 ? S = 1 : S > m.value - v.value && (S = m.value - v.value + 1), e.limit <= Ue && f.value && m.value === S + v.value - 1 && (S = Math.max(S - 1, 1)), S;
    }), $ = d(() => {
      const S = m.value - l.value;
      let V = !1;
      return S + 2 < e.limit && e.limit > Ue ? e.limit > Ue && (V = !0) : e.limit > Ue && (V = !!(!r.value || n.value)), h.value <= 1 && (V = !1), V && n.value && h.value < 4 && (V = !1), V;
    }), v = d(() => {
      let S = e.limit;
      return m.value <= e.limit ? S = m.value : l.value < e.limit - 1 && e.limit > Ue ? ((!r.value || f.value) && (S = e.limit - (n.value ? 0 : 1)), S = Math.min(S, e.limit)) : m.value - l.value + 2 < e.limit && e.limit > Ue ? (!r.value || n.value) && (S = e.limit - (f.value ? 0 : 1)) : e.limit > Ue && (S = e.limit - (r.value ? 0 : 2)), S;
    }), k = d(() => {
      const S = m.value - v.value;
      let V = !1;
      l.value < e.limit - 1 && e.limit > Ue ? (!r.value || f.value) && (V = !0) : e.limit > Ue && (V = !!(!r.value || f.value)), h.value > S && (V = !1);
      const I = h.value + v.value - 1;
      return V && f.value && I > m.value - 3 && (V = !1), V;
    }), w = dt({
      pageSize: Nl(e.perPage),
      totalRows: zl(e.totalRows),
      numberOfPages: m.value
    }), B = (S, V) => {
      if (V === l.value)
        return;
      const { target: I } = S, C = new Ke("page-click", {
        cancelable: !0,
        target: I
      });
      t("page-click", C, V), !C.defaultPrevented && (l.value = V);
    }, T = d(() => e.size ? `pagination-${e.size}` : ""), O = d(() => p.value ? "b-pagination-pills" : "");
    ce(l, (S) => {
      const V = cc(S, m.value);
      V !== l.value && (l.value = V);
    }), ce(w, (S, V) => {
      S != null && (V.pageSize !== S.pageSize && V.totalRows === S.totalRows || V.numberOfPages !== S.numberOfPages && l.value > V.numberOfPages) && (l.value = 1);
    });
    const A = d(() => {
      const S = [];
      for (let V = 0; V < v.value; V++)
        S.push({ number: h.value + V, classes: null });
      return S;
    });
    return () => {
      const S = [], V = A.value.map((G) => G.number), I = (G) => G === l.value, C = l.value < 1, F = e.align === "fill", E = (G, te, fe, pe, be, oe) => {
        const de = o.value || I(oe) || C || G < 1 || G > m.value, L = G < 1 ? 1 : G > m.value ? m.value : G, z = { disabled: de, page: L, index: L - 1 }, ee = Me(fe, z, a) || pe || "";
        return ie(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: de,
                "flex-fill": F,
                "d-flex": F && !de
              },
              be
            ]
          },
          // render inner content
          ie(
            de ? "span" : "button",
            {
              class: ["page-link", { "flex-grow-1": !de && F }],
              "aria-label": te,
              "aria-controls": e.ariaControls || null,
              "aria-disabled": de ? !0 : null,
              role: "menuitem",
              type: de ? null : "button",
              tabindex: de ? null : "-1",
              onClick: (se) => {
                de || B(se, L);
              }
            },
            ee
          )
        );
      }, U = (G) => ie(
        "li",
        {
          class: [
            "page-item",
            "disabled",
            "bv-d-xs-down-none",
            F ? "flex-fill" : "",
            e.ellipsisClass
          ],
          role: "separator",
          key: `ellipsis-${G ? "last" : "first"}`
        },
        [
          ie(
            "span",
            { class: ["page-link"] },
            Me(nc, {}, a) || e.ellipsisText || "..."
          )
        ]
      ), q = (G, te) => {
        const fe = I(G.number) && !C, pe = o.value ? null : fe || C && te === 0 ? "0" : "-1", be = {
          active: fe,
          disabled: o.value,
          page: G.number,
          index: G.number - 1,
          content: G.number
        }, oe = Me(uc, be, a) || G.number, de = ie(
          o.value ? "span" : "button",
          {
            class: ["page-link", { "flex-grow-1": !o.value && F }],
            "aria-controls": e.ariaControls || null,
            "aria-disabled": o.value ? !0 : null,
            "aria-label": e.labelPage ? `${e.labelPage} ${G.number}` : null,
            role: "menuitemradio",
            type: o.value ? null : "button",
            tabindex: pe,
            onClick: (L) => {
              o.value || B(L, G.number);
            }
          },
          oe
        );
        return ie(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: o.value,
                active: fe,
                "flex-fill": F,
                "d-flex": F && !o.value
              },
              e.pageClass
            ],
            role: "presentation",
            key: `page-${G.number}`
          },
          de
        );
      };
      if (!i.value && !n.value) {
        const G = E(
          1,
          e.labelFirstPage,
          sc,
          e.firstText,
          e.firstClass,
          1
        );
        S.push(G);
      }
      const ae = E(
        l.value - 1,
        e.labelFirstPage,
        dc,
        e.prevText,
        e.prevClass,
        1
      );
      S.push(ae), n.value && V[0] !== 1 && S.push(q({ number: 1 }, 0)), $.value && S.push(U(!1)), A.value.forEach((G, te) => {
        const fe = $.value && n.value && V[0] !== 1 ? 1 : 0;
        S.push(q(G, te + fe));
      }), k.value && S.push(U(!0)), f.value && V[V.length - 1] !== m.value && S.push(q({ number: m.value }, -1));
      const Z = E(
        l.value + 1,
        e.labelNextPage,
        rc,
        e.nextText,
        e.nextClass,
        m.value
      );
      if (S.push(Z), !f.value && !i.value) {
        const G = E(
          m.value,
          e.labelLastPage,
          ic,
          e.lastText,
          e.lastClass,
          m.value
        );
        S.push(G);
      }
      return ie(
        "ul",
        {
          class: ["pagination", T.value, b.value, O.value],
          role: "menubar",
          "aria-disabled": o.value,
          "aria-label": e.ariaLabel || null
        },
        S
      );
    };
  }
}), vc = {
  inheritAttrs: !1
}, He = /* @__PURE__ */ R({
  ...vc,
  __name: "BPlaceholder",
  props: {
    tag: { default: "span" },
    wrapperTag: { default: "span" },
    width: { default: void 0 },
    cols: { default: 12 },
    variant: { default: void 0 },
    size: { default: void 0 },
    animation: { default: void 0 }
  },
  setup(e) {
    const t = e, a = d(
      () => t.width === void 0 ? void 0 : typeof t.width == "number" ? t.width.toString() : t.width.replace("%", "")
    ), l = d(
      () => t.cols === void 0 ? void 0 : typeof t.cols == "number" ? t.cols.toString() : t.cols
    ), o = d(() => ({
      [`col-${l.value}`]: l.value !== void 0 && a.value === void 0,
      [`bg-${t.variant}`]: t.variant !== void 0,
      [`placeholder-${t.size}`]: t.size !== void 0
    })), n = d(() => ({
      [`placeholder-${t.animation}`]: t.animation !== void 0
    })), r = d(() => ({
      width: a.value === void 0 ? void 0 : `${a.value}%`
    }));
    return (i, f) => (g(), D(le(e.wrapperTag), {
      class: N(s(n))
    }, {
      default: j(() => [
        (g(), D(le(e.tag), Q(i.$attrs, {
          class: ["placeholder", s(o)],
          style: s(r)
        }), null, 16, ["class", "style"]))
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), xn = /* @__PURE__ */ R({
  __name: "BPlaceholderButton",
  props: {
    tag: { default: "div" },
    width: { default: void 0 },
    cols: { default: void 0 },
    variant: { default: "primary" },
    animation: { default: void 0 }
  },
  setup(e) {
    const t = e, a = d(() => ["btn", `btn-${t.variant}`, "disabled"]), l = d(() => ({
      animation: t.animation,
      width: t.width,
      cols: t.cols,
      tag: t.tag
    }));
    return (o, n) => (g(), D(He, Q({ class: s(a) }, s(l)), null, 16, ["class"]));
  }
}), mc = /* @__PURE__ */ R({
  __name: "BPlaceholderCard",
  props: {
    noHeader: { default: !1 },
    headerWidth: { default: 100 },
    headerVariant: { default: void 0 },
    headerAnimation: { default: void 0 },
    headerSize: { default: void 0 },
    noFooter: { default: !1 },
    footerWidth: { default: 100 },
    footerVariant: { default: void 0 },
    footerAnimation: { default: void 0 },
    footerSize: { default: void 0 },
    animation: { default: void 0 },
    size: { default: void 0 },
    variant: { default: void 0 },
    noButton: { default: !1 },
    imgBottom: { default: !1 },
    imgSrc: { default: void 0 },
    imgBlankColor: { default: "#868e96" },
    imgHeight: { default: 100 },
    noImg: { default: !1 }
  },
  setup(e) {
    const t = e, a = c(u(t, "noButton")), l = c(u(t, "noHeader")), o = c(u(t, "noFooter")), n = c(u(t, "noImg")), r = d(() => ({
      width: t.headerWidth,
      variant: t.headerVariant,
      animation: t.headerAnimation,
      size: t.headerSize
    })), i = d(() => ({
      width: t.footerWidth,
      animation: t.footerAnimation,
      size: a.value ? t.footerSize : void 0,
      variant: t.footerVariant
    })), f = d(() => ({
      animation: t.animation,
      size: t.size,
      variant: t.variant
    })), p = d(() => ({
      blank: !t.imgSrc,
      blankColor: t.imgBlankColor,
      height: t.imgSrc ? void 0 : t.imgHeight,
      src: t.imgSrc,
      top: !t.imgBottom,
      bottom: t.imgBottom
    }));
    return (y, b) => (g(), D(fn, { "img-bottom": e.imgBottom }, ao({
      default: j(() => [
        x(y.$slots, "default", {}, () => [
          ye(He, Q({ cols: "7" }, s(f)), null, 16),
          ye(He, Q({ cols: "4" }, s(f)), null, 16),
          ye(He, Q({ cols: "4" }, s(f)), null, 16),
          ye(He, Q({ cols: "6" }, s(f)), null, 16),
          ye(He, Q({ cols: "8" }, s(f)), null, 16)
        ])
      ]),
      _: 2
    }, [
      s(n) ? void 0 : {
        name: "img",
        fn: j(() => [
          x(y.$slots, "img", {}, () => [
            ye(la, $e(Ve(s(p))), null, 16)
          ])
        ]),
        key: "0"
      },
      s(l) ? void 0 : {
        name: "header",
        fn: j(() => [
          x(y.$slots, "header", {}, () => [
            ye(He, $e(Ve(s(r))), null, 16)
          ])
        ]),
        key: "1"
      },
      s(o) ? void 0 : {
        name: "footer",
        fn: j(() => [
          x(y.$slots, "footer", {}, () => [
            s(a) ? (g(), D(He, $e(Q({ key: 1 }, s(i))), null, 16)) : (g(), D(xn, $e(Q({ key: 0 }, s(i))), null, 16))
          ])
        ]),
        key: "2"
      }
    ]), 1032, ["img-bottom"]));
  }
}), Ya = /* @__PURE__ */ R({
  __name: "BTableSimple",
  props: {
    bordered: { default: !1 },
    borderless: { default: !1 },
    borderVariant: { default: void 0 },
    captionTop: { default: !1 },
    dark: { default: !1 },
    hover: { default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    striped: { default: !1 },
    small: { default: !1 },
    tableClass: { default: void 0 },
    tableVariant: { default: void 0 },
    stickyHeader: { default: !1 }
  },
  setup(e) {
    const t = e, a = c(u(t, "captionTop")), l = c(u(t, "borderless")), o = c(u(t, "bordered")), n = c(u(t, "dark")), r = c(u(t, "hover")), i = c(u(t, "small")), f = c(u(t, "striped")), p = c(u(t, "stickyHeader")), y = d(() => [
      "table",
      "b-table",
      {
        "table-bordered": o.value,
        "table-borderless": l.value,
        [`border-${t.borderVariant}`]: t.borderVariant !== void 0,
        "caption-top": a.value,
        "table-dark": n.value,
        "table-hover": r.value,
        "b-table-stacked": typeof t.stacked == "boolean" && t.stacked,
        [`b-table-stacked-${t.stacked}`]: typeof t.stacked == "string",
        "table-striped": f.value,
        "table-sm": i.value,
        [`table-${t.tableVariant}`]: t.tableVariant !== void 0
      },
      t.tableClass
    ]), b = d(() => [
      {
        "table-responsive": t.responsive === !0,
        [`table-responsive-${t.responsive}`]: typeof t.responsive == "string",
        "b-table-sticky-header": p.value
      }
    ]);
    return (m, h) => e.responsive ? (g(), _("div", {
      key: 1,
      class: N(s(b))
    }, [
      X("table", {
        class: N(s(y))
      }, [
        x(m.$slots, "default")
      ], 2)
    ], 2)) : (g(), _("table", {
      key: 0,
      class: N(s(y))
    }, [
      x(m.$slots, "default")
    ], 2));
  }
}), pc = /* @__PURE__ */ R({
  __name: "BPlaceholderTable",
  props: {
    rows: { default: 3 },
    columns: { default: 5 },
    cellWidth: { default: 100 },
    size: { default: void 0 },
    animation: { default: void 0 },
    variant: { default: void 0 },
    headerColumns: { default: void 0 },
    hideHeader: { default: !1 },
    headerCellWidth: { default: 100 },
    headerSize: { default: void 0 },
    headerAnimation: { default: void 0 },
    headerVariant: { default: void 0 },
    footerColumns: { default: void 0 },
    showFooter: { default: !1 },
    footerCellWidth: { default: 100 },
    footerSize: { default: void 0 },
    footerAnimation: { default: void 0 },
    footerVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = yt(u(t, "columns"), { nanToZero: !0, method: "parseInt" }), l = yt(u(t, "rows"), { nanToZero: !0, method: "parseInt" }), o = d(() => t.headerColumns ?? NaN), n = d(() => t.footerColumns ?? NaN), r = yt(o, {
      nanToZero: !0,
      method: "parseInt"
    }), i = yt(n, {
      nanToZero: !0,
      method: "parseInt"
    }), f = d(() => a.value || 5), p = d(() => l.value || 3), y = d(
      () => t.headerColumns === void 0 ? f.value : r.value
    ), b = d(
      () => t.footerColumns === void 0 ? f.value : i.value
    ), m = d(() => ({
      size: t.size,
      variant: t.variant,
      animation: t.animation,
      width: t.cellWidth
    })), h = d(() => ({
      size: t.headerSize,
      variant: t.headerVariant,
      animation: t.headerAnimation,
      width: t.headerCellWidth
    })), $ = d(() => ({
      size: t.footerSize,
      variant: t.footerVariant,
      animation: t.footerAnimation,
      width: t.footerCellWidth
    })), v = c(u(t, "hideHeader")), k = c(u(t, "showFooter"));
    return (w, B) => (g(), D(Ya, null, {
      default: j(() => [
        s(v) ? Y("", !0) : x(w.$slots, "thead", { key: 0 }, () => [
          X("thead", null, [
            X("tr", null, [
              (g(!0), _(ue, null, Be(s(y), (T, O) => (g(), _("th", { key: O }, [
                ye(He, $e(Ve(s(h))), null, 16)
              ]))), 128))
            ])
          ])
        ]),
        x(w.$slots, "default", {}, () => [
          X("tbody", null, [
            (g(!0), _(ue, null, Be(s(p), (T, O) => (g(), _("tr", { key: O }, [
              (g(!0), _(ue, null, Be(s(f), (A, S) => (g(), _("td", { key: S }, [
                ye(He, $e(Ve(s(m))), null, 16)
              ]))), 128))
            ]))), 128))
          ])
        ]),
        s(k) ? x(w.$slots, "tfoot", { key: 1 }, () => [
          X("tfoot", null, [
            X("tr", null, [
              (g(!0), _(ue, null, Be(s(b), (T, O) => (g(), _("th", { key: O }, [
                ye(He, $e(Ve(s($))), null, 16)
              ]))), 128))
            ])
          ])
        ]) : Y("", !0)
      ]),
      _: 3
    }));
  }
}), gc = /* @__PURE__ */ R({
  __name: "BPlaceholderWrapper",
  props: {
    loading: { default: !1 }
  },
  setup(e) {
    const a = c(u(e, "loading"));
    return (l, o) => s(a) ? x(l.$slots, "loading", { key: 0 }) : x(l.$slots, "default", { key: 1 });
  }
}), bc = ["aria-valuenow", "aria-valuemax"], An = /* @__PURE__ */ R({
  __name: "BProgressBar",
  props: {
    animated: { default: !1 },
    label: { default: void 0 },
    labelHtml: { default: void 0 },
    max: { default: void 0 },
    precision: { default: 0 },
    showProgress: { default: !1 },
    showValue: { default: !1 },
    striped: { default: !1 },
    value: { default: 0 },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = We(yo, null), l = c(u(t, "animated")), o = c(u(t, "showProgress")), n = c(u(t, "showValue")), r = c(u(t, "striped")), i = d(() => ({
      "progress-bar-animated": l.value || (a == null ? void 0 : a.animated.value),
      "progress-bar-striped": r.value || (a == null ? void 0 : a.striped.value) || l.value || (a == null ? void 0 : a.animated.value),
      [`bg-${t.variant}`]: t.variant !== void 0
    })), f = d(
      () => typeof t.precision == "number" ? t.precision : Number.parseFloat(t.precision)
    ), p = d(
      () => typeof t.value == "number" ? t.value : Number.parseFloat(t.value)
    ), y = d(
      () => typeof t.max == "number" ? t.max : t.max === void 0 ? void 0 : Number.parseFloat(t.max)
    ), b = d(
      () => t.labelHtml !== void 0 ? t.labelHtml : n.value || a != null && a.showValue.value ? p.value.toFixed(f.value) : o.value || a != null && a.showProgress.value ? (p.value * 100 / (y.value || 100)).toFixed(f.value) : t.label !== void 0 ? t.label : ""
    ), m = d(
      () => a != null && a.max.value ? `${p.value * 100 / (typeof a.max.value == "number" ? a.max.value : Number.parseInt(a.max.value))}%` : t.max ? `${p.value * 100 / (typeof t.max == "number" ? t.max : Number.parseInt(t.max))}%` : typeof t.value == "string" ? t.value : `${t.value}%`
    );
    return (h, $) => (g(), _("div", {
      class: N(["progress-bar", s(i)]),
      role: "progressbar",
      "aria-valuenow": e.value,
      "aria-valuemin": "0",
      "aria-valuemax": e.max,
      style: Le({ width: s(m) })
    }, [
      x(h.$slots, "default", {}, () => [
        ne(J(s(b)), 1)
      ])
    ], 14, bc));
  }
}), hc = /* @__PURE__ */ R({
  __name: "BProgress",
  props: {
    variant: { default: void 0 },
    max: { default: void 0 },
    height: { default: void 0 },
    animated: { default: !1 },
    precision: { default: 0 },
    showProgress: { default: !1 },
    showValue: { default: !1 },
    striped: { default: !1 },
    value: { default: 0 }
  },
  setup(e) {
    const t = e, a = c(u(t, "animated")), l = c(u(t, "showProgress")), o = c(u(t, "showValue")), n = c(u(t, "striped")), r = d(() => ({
      animated: t.animated,
      max: t.max,
      precision: t.precision,
      showProgress: t.showProgress,
      showValue: t.showValue,
      striped: t.striped,
      value: t.value,
      variant: t.variant
    }));
    return ot(yo, {
      animated: a,
      max: Ae(u(t, "max")),
      showProgress: l,
      showValue: o,
      striped: n
    }), (i, f) => (g(), _("div", {
      class: "progress",
      style: Le({ height: e.height })
    }, [
      x(i.$slots, "default", {}, () => [
        ye(An, $e(Ve(s(r))), null, 16)
      ])
    ], 4));
  }
}), Rl = ia("cols", [""], { type: [String, Number], default: null }), yc = R({
  name: "BRow",
  props: {
    tag: { type: String, default: "div" },
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    noGutters: { type: [Boolean, String], default: !1 },
    alignV: { type: String, default: null },
    alignH: { type: String, default: null },
    alignContent: { type: String, default: null },
    ...Rl
  },
  setup(e) {
    const t = c(u(e, "noGutters")), a = Nt(u(e, "alignH")), l = d(() => po(e, Rl, "cols", "row-cols"));
    return {
      computedClasses: d(() => [
        l.value,
        {
          [`gx-${e.gutterX}`]: e.gutterX !== null,
          [`gy-${e.gutterY}`]: e.gutterY !== null,
          "g-0": t.value,
          [`align-items-${e.alignV}`]: e.alignV !== null,
          [a.value]: e.alignH !== null,
          [`align-content-${e.alignContent}`]: e.alignContent !== null
        }
      ])
    };
  }
});
function Bc(e, t, a, l, o, n) {
  return g(), D(le(e.tag), {
    class: N(["row", e.computedClasses])
  }, {
    default: j(() => [
      x(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const $c = /* @__PURE__ */ ze(yc, [["render", Bc]]), Hl = [
  "ar",
  "az",
  "ckb",
  "fa",
  "he",
  "ks",
  "lrc",
  "mzn",
  "ps",
  "sd",
  "te",
  "ug",
  "ur",
  "yi"
].map((e) => e.toLowerCase()), wc = (e) => {
  const t = qt(e).toLowerCase().replace(Jn, "").split("-"), a = t.slice(0, 2).join("-"), [l] = t;
  return Hl.includes(a) || Hl.includes(l);
}, kc = (e) => ls ? ga(e) ? e : { capture: !!e || !1 } : !!(ga(e) ? e.capture : e), Sc = (e, t, a, l) => {
  e && e.addEventListener && e.addEventListener(t, a, kc(l));
}, Cc = (e, t, a, l) => {
  e && e.removeEventListener && e.removeEventListener(t, a, l);
}, Ml = (e, t) => {
  (e ? Sc : Cc)(...t);
}, Ht = (e, { preventDefault: t = !0, propagation: a = !0, immediatePropagation: l = !1 } = {}) => {
  t && e.preventDefault(), a && e.stopPropagation(), l && e.stopImmediatePropagation();
}, Pa = "ArrowDown", Vn = "End", On = "Home", Pn = "PageDown", En = "PageUp", Ea = "ArrowUp", Dl = 1, jl = 100, ql = 1, Gl = 500, Wl = 100, Ul = 10, Xl = 4, Kl = [Ea, Pa, On, Vn, En, Pn], Tc = R({
  props: {
    ariaControls: { type: String, default: void 0 },
    ariaLabel: { type: String, default: void 0 },
    labelIncrement: { type: String, default: "Increment" },
    labelDecrement: { type: String, default: "Decrement" },
    modelValue: { type: Number, default: null },
    // V-model prop
    name: { type: String, default: "BFormSpinbutton" },
    disabled: { type: [Boolean, String], default: !1 },
    placeholder: { type: String, default: void 0 },
    locale: { type: String, default: "locale" },
    form: { type: String, default: void 0 },
    inline: { type: Boolean, default: !1 },
    size: { type: String, default: void 0 },
    formatterFn: {
      type: Function,
      default: void 0
    },
    readonly: { type: Boolean, default: !1 },
    vertical: { type: Boolean, default: !1 },
    repeatDelay: {
      type: [String, Number],
      default: Gl
    },
    repeatInterval: {
      type: [String, Number],
      default: Wl
    },
    repeatStepMultiplier: {
      type: [String, Number],
      default: Xl
    },
    repeatThreshold: {
      type: [String, Number],
      default: Ul
    },
    required: { type: [Boolean, String], default: !1 },
    step: { type: [String, Number], default: ql },
    min: { type: [String, Number], default: Dl },
    max: { type: [String, Number], default: jl },
    wrap: { type: Boolean, default: !1 },
    state: { type: [Boolean, String], default: null }
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = _e(e, "modelValue", t), l = M(!1), o = d(() => 1), n = () => {
      t("change", i.value);
    }, r = M(null), i = d({
      get: () => a.value === null ? r.value : a.value,
      set: (L) => {
        a.value === null ? r.value = L : a.value = L;
      }
    });
    let f, p, y = !1;
    const b = d(() => xt(e.step, ql)), m = d(() => xt(e.min, Dl)), h = d(() => {
      const L = xt(e.max, jl), z = b.value, ee = m.value;
      return Math.floor((L - ee) / z) * z + ee;
    }), $ = d(() => {
      const L = tt(e.repeatDelay, 0);
      return L > 0 ? L : Gl;
    }), v = d(() => {
      const L = tt(e.repeatInterval, 0);
      return L > 0 ? L : Wl;
    }), k = d(
      () => Math.max(tt(e.repeatThreshold, Ul), 1)
    ), w = d(
      () => Math.max(tt(e.repeatStepMultiplier, Xl), 1)
    ), B = d(() => {
      const L = b.value;
      return Math.floor(L) === L ? 0 : (L.toString().split(".")[1] || "").length;
    }), T = d(() => Math.pow(10, B.value || 0)), O = d(() => {
      const { value: L } = i;
      return L === null ? "" : L.toFixed(B.value);
    }), A = d(() => {
      const L = [e.locale];
      return new Intl.NumberFormat(L).resolvedOptions().locale;
    }), S = d(
      () => (
        //todo
        wc(A.value)
      )
    ), V = () => {
      const L = B.value;
      return new Intl.NumberFormat(A.value, {
        style: "decimal",
        useGrouping: !1,
        minimumIntegerDigits: 1,
        minimumFractionDigits: L,
        maximumFractionDigits: L,
        notation: "standard"
      }).format;
    }, I = d(() => e.formatterFn ?? V()), C = d(() => ({
      role: "group",
      lang: A.value,
      tabindex: e.disabled ? null : "-1",
      title: e.ariaLabel
    })), F = d(() => a.value !== null || r.value !== null), E = d(() => ({
      dir: S.value,
      spinId: o.value,
      tabindex: e.disabled ? null : "0",
      role: "spinbutton",
      "aria-live": "off",
      "aria-label": e.ariaLabel || null,
      "aria-controls": e.ariaControls || null,
      "aria-invalid": e.state === !1 || !F.value && e.required ? !0 : null,
      "aria-required": e.required ? !0 : null,
      "aria-valuemin": m.value,
      "aria-valuemax": h.value,
      "aria-valuenow": i.value !== null ? i.value : null,
      "aria-valuetext": i.value !== null ? I.value(i.value) : null
    })), U = (L) => {
      let { value: z } = i;
      if (!e.disabled && z !== null) {
        const ee = b.value * L, se = m.value, he = h.value, xe = T.value, { wrap: W } = e;
        z = Math.round((z - se) / ee) * ee + se + ee, z = Math.round(z * xe) / xe, i.value = z > he ? W ? se : he : z < se ? W ? he : se : z;
      }
    }, q = (L = 1) => {
      i.value === null ? i.value = m.value : U(1 * L);
    }, ae = (L = 1) => {
      i.value === null ? i.value = e.wrap ? h.value : m.value : U(-1 * L);
    }, Z = (L) => {
      const { code: z, altKey: ee, ctrlKey: se, metaKey: he } = L;
      if (!(e.disabled || e.readonly || ee || se || he) && Kl.includes(z)) {
        if (Ht(L, { propagation: !1 }), y)
          return;
        oe(), [Ea, Pa].includes(z) ? (y = !0, z === Ea ? te(L, q) : z === Pa && te(L, ae)) : z === En ? q(w.value) : z === Pn ? ae(w.value) : z === On ? i.value = m.value : z === Vn && (i.value = h.value);
      }
    }, G = (L) => {
      const { code: z, altKey: ee, ctrlKey: se, metaKey: he } = L;
      e.disabled || e.readonly || ee || se || he || Kl.includes(z) && (Ht(L, { propagation: !1 }), oe(), y = !1, n());
    }, te = (L, z) => {
      const { type: ee } = L || {};
      if (!e.disabled && !e.readonly) {
        if (fe(L) && ee === "mousedown" && L.button)
          return;
        oe(), z(1);
        const se = k.value, he = w.value, xe = $.value, W = v.value;
        f = setTimeout(() => {
          let re = 0;
          p = setInterval(() => {
            z(re < se ? 1 : he), re++;
          }, W);
        }, xe);
      }
    };
    function fe(L) {
      return L.type === "mouseup" || L.type === "mousedown";
    }
    const pe = (L) => {
      fe(L) && L.type === "mouseup" && L.button || (Ht(L, { propagation: !1 }), oe(), be(!1), n());
    }, be = (L) => {
      try {
        Ml(L, [document.body, "mouseup", pe, !1]), Ml(L, [document.body, "touchend", pe, !1]);
      } catch {
        return 0;
      }
    }, oe = () => {
      clearTimeout(f), clearInterval(p), f = void 0, p = void 0;
    }, de = (L, z, ee, se, he, xe, W) => {
      const re = ie(ee, {
        props: { scale: l.value ? 1.5 : 1.25 },
        attrs: { "aria-hidden": !0 }
      }), De = { hasFocus: l.value }, Ie = (P) => {
        !e.disabled && !e.readonly && (Ht(P, { propagation: !1 }), be(!0), te(P, L));
      };
      return ie(
        "button",
        {
          class: [{ "py-0": !e.vertical }, "btn", "btn-sm", "border-0", "rounded-0"],
          tabindex: "-1",
          type: "button",
          disabled: e.disabled || e.readonly || xe,
          "aria-disabled": e.disabled || e.readonly || xe ? !0 : null,
          "aria-controls": o.value,
          "aria-label": z || null,
          "aria-keyshortcuts": he || null,
          onmousedown: Ie,
          ontouchstart: Ie
          // 'ref': keyRef,
        },
        [Me(W, De) || re]
      );
    };
    return () => {
      const L = de(
        q,
        e.labelIncrement,
        ie(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-plus",
            viewBox: "0 0 16 16"
          },
          ie("path", {
            d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"
          })
        ),
        "inc",
        "ArrowUp",
        !1,
        "increment"
      ), z = de(
        ae,
        e.labelDecrement,
        ie(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-dash",
            viewBox: "0 0 16 16"
          },
          ie("path", { d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z" })
        ),
        "dec",
        "ArrowDown",
        !1,
        "decrement"
      ), ee = [];
      e.name && !e.disabled && ee.push(
        ie("input", {
          type: "hidden",
          name: e.name,
          form: e.form || null,
          // TODO: Should this be set to '' if value is out of range?
          value: O.value,
          key: "hidden"
        })
      );
      const se = ie(
        // We use 'output' element to make this accept a `<label for="id">` (Except IE)
        "output",
        {
          class: [
            { "d-flex": e.vertical },
            { "align-self-center": !e.vertical },
            { "align-items-center": e.vertical },
            { "border-top": e.vertical },
            { "border-bottom": e.vertical },
            { "border-start": !e.vertical },
            { "border-end": !e.vertical },
            "flex-grow-1"
          ],
          ...E.value,
          key: "output"
          // ref: 'spinner',
        },
        [
          ie(
            "bdi",
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            //@ts-ignore How can we narrow this type down
            F.value ? I.value(i.value) : e.placeholder || ""
          )
        ]
      );
      return ie(
        "div",
        {
          class: [
            "b-form-spinbutton form-control",
            { disabled: e.disabled },
            { readonly: e.readonly },
            { focus: l },
            { "d-inline-flex": e.inline || e.vertical },
            { "d-flex": !e.inline && !e.vertical },
            { "align-items-stretch": !e.vertical },
            { "flex-column": e.vertical },
            e.size ? `form-control-${e.size}` : null
            // this.stateClass //TODO
          ],
          ...C.value,
          onkeydown: Z,
          onkeyup: G
          // We use capture phase (`!` prefix) since focus and blur do not bubble
          // 'focus': onFocusBlur, //TODO
          // 'blur': onFocusBlur, //TODO
        },
        e.vertical ? [L, ee, se, z] : [z, ee, se, L]
      );
    };
  }
}), _c = ["TD", "TH", "TR"], xc = [
  "a",
  "a *",
  // Include content inside links
  "button",
  "button *",
  // Include content inside buttons
  "input:not(.disabled):not([disabled])",
  "select:not(.disabled):not([disabled])",
  "textarea:not(.disabled):not([disabled])",
  '[role="link"]',
  '[role="link"] *',
  '[role="button"]',
  '[role="button"] *',
  "[tabindex]:not(.disabled):not([disabled])"
].join(","), Mt = (e) => {
  if (!e || !e.target)
    return !1;
  const t = e.target;
  if ("disabled" in t && t.disabled || _c.indexOf(t.tagName) !== -1)
    return !1;
  if (tl(".dropdown-menu", t))
    return !0;
  const a = t.tagName === "LABEL" ? t : tl("label", t);
  if (a) {
    const l = Ra(a, "for"), o = l ? fs(l) : vo("input, select, textarea", a);
    if (o && !o.disabled)
      return !0;
  }
  return mo(t, xc);
}, Ac = () => {
  const e = (p, y) => {
    const b = [];
    return !(p != null && p.length) && (y != null && y.length) ? (Object.keys(y[0]).forEach((m) => b.push({ key: m, label: Za(m) })), b) : (Array.isArray(p) && p.forEach((m) => {
      typeof m == "string" ? b.push({ key: m, label: Za(m) }) : ga(m) && m.key && typeof m.key == "string" && b.push({ ...m });
    }), b);
  }, t = M([]), a = (p, y, b, m) => (t.value = Gt(y), "isFilterableTable" in m && m.isFilterableTable.value === !0 && b.filter && (t.value = n(t.value, b.filter, b.filterable)), "isSortable" in m && m.isSortable.value === !0 && (t.value = o(
    p,
    t.value,
    {
      key: b.sortBy,
      desc: m.sortDescBoolean.value
    },
    b.sortCompare
  )), t.value), l = M(void 0), o = (p, y, b, m) => {
    if (!b || !b.key)
      return y;
    const h = b.key;
    return y.sort(($, v) => {
      if (m !== void 0)
        return m($, v, b.key, b.desc);
      const k = (T) => typeof T == "object" ? JSON.stringify(T) : T;
      return k($[h]) > k(v[h]) ? b.desc ? -1 : 1 : k(v[h]) > k($[h]) ? b.desc ? 1 : -1 : 0;
    });
  }, n = (p, y, b) => p.filter(
    (m) => Object.entries(m).filter((h) => {
      const [$, v] = h;
      return !v || $[0] === "_" || b.length > 0 && !b.includes($) ? !1 : (typeof v == "object" ? JSON.stringify(Object.values(v)) : typeof v == "string" ? v : v.toString()).toLowerCase().includes(y.toLowerCase());
    }).length > 0
  );
  return {
    normaliseFields: e,
    mapItems: a,
    internalItems: t,
    updateInternalItems: async (p) => {
      try {
        return t.value = await ba(p), t.value;
      } catch {
        return;
      }
    },
    filterEvent: l,
    notifyFilteredItems: () => {
      l.value && l.value(t.value);
    },
    formatItem: (p, y) => {
      const b = p[y.key];
      return y.formatter && typeof y.formatter == "function" ? y.formatter(b, y.key, p) : p[y.key];
    }
  };
}, Vc = ["title", "abbr", "onClick"], Oc = { class: "d-inline-flex flex-nowrap align-items-center gap-1" }, Pc = { key: 1 }, Ec = ["onClick", "onDblclick", "onMouseenter", "onMouseleave"], Ic = {
  key: 0,
  class: "b-table-stacked-label"
}, Fc = ["colspan"], Lc = ["colspan"], Nc = { class: "d-flex align-items-center justify-content-center gap-2" }, zc = /* @__PURE__ */ X("strong", null, "Loading...", -1), Rc = {
  key: 1,
  class: "b-table-empty-slot"
}, Hc = ["colspan"], Mc = { key: 0 }, Dc = ["title", "abbr", "onClick"], jc = { key: 1 }, qc = { key: 2 }, Gc = { key: 3 }, Wc = /* @__PURE__ */ R({
  __name: "BTable",
  props: {
    align: { default: void 0 },
    caption: { default: void 0 },
    captionTop: { default: !1 },
    borderless: { default: !1 },
    bordered: { default: !1 },
    borderVariant: { default: void 0 },
    dark: { default: !1 },
    fields: { default: () => [] },
    footClone: { default: !1 },
    hover: { default: !1 },
    items: { default: () => [] },
    provider: { default: void 0 },
    sortCompare: { default: void 0 },
    noProvider: { default: void 0 },
    noProviderPaging: { default: void 0 },
    noProviderSorting: { default: void 0 },
    noProviderFiltering: { default: void 0 },
    responsive: { type: [Boolean, String], default: !1 },
    small: { default: !1 },
    striped: { default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    labelStacked: { type: Boolean, default: !1 },
    variant: { default: void 0 },
    sortBy: { default: void 0 },
    sortDesc: { default: !1 },
    sortInternal: { default: !0 },
    selectable: { default: !1 },
    stickySelect: { default: !1 },
    selectHead: { type: [Boolean, String], default: !0 },
    selectMode: { default: "single" },
    selectionVariant: { default: "primary" },
    stickyHeader: { default: !1 },
    busy: { default: !1 },
    showEmpty: { default: !1 },
    perPage: { default: void 0 },
    currentPage: { default: 1 },
    filter: { default: void 0 },
    filterable: { default: void 0 },
    emptyText: { default: "There are no records to show" },
    emptyFilteredText: { default: "There are no records matching your request" }
  },
  emits: ["headClicked", "rowClicked", "rowDblClicked", "rowHovered", "rowUnhovered", "rowSelected", "rowUnselected", "selection", "update:busy", "update:sortBy", "update:sortDesc", "sorted", "filtered"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = Ee(), n = Ac(), r = c(u(l, "footClone")), i = c(u(l, "sortDesc")), f = c(u(l, "sortInternal")), p = c(u(l, "selectable")), y = c(u(l, "stickySelect")), b = c(u(l, "labelStacked")), m = c(u(l, "busy")), h = c(u(l, "showEmpty")), $ = c(u(l, "noProviderPaging")), v = c(u(l, "noProviderSorting")), k = c(u(l, "noProviderFiltering")), w = M(m.value);
    n.filterEvent.value = async (P) => {
      if (C.value) {
        await L();
        return;
      }
      const K = await ba(P);
      a("filtered", K);
    };
    const B = M(/* @__PURE__ */ new Set([])), T = d(() => B.value.size > 0), O = d(() => ({
      [`align-${l.align}`]: l.align !== void 0,
      "b-table-selectable": p.value,
      [`b-table-select-${l.selectMode}`]: p.value,
      "b-table-selecting user-select-none": p.value && T.value,
      "b-table-busy": w.value,
      "b-table-sortable": E.value,
      "b-table-sort-desc": E.value && i.value === !0,
      "b-table-sort-asc": E.value && i.value === !1
    })), A = d(() => ({
      bordered: l.bordered,
      borderless: l.borderless,
      borderVariant: l.borderVariant,
      captionTop: l.captionTop,
      dark: l.dark,
      hover: l.hover,
      responsive: l.responsive,
      striped: l.striped,
      stacked: l.stacked,
      small: l.small,
      tableClass: O.value,
      tableVariant: l.variant,
      stickyHeader: l.stickyHeader
    })), S = d(() => n.normaliseFields(l.fields, l.items)), V = d(
      () => S.value.length + (p.value ? 1 : 0)
    ), I = d(() => l.filter !== void 0 && l.filter !== ""), C = d(() => l.provider !== void 0), F = d(
      () => p.value && (!!l.selectHead || o.selectHead !== void 0)
    ), E = d(
      () => l.fields.filter((P) => typeof P == "string" ? !1 : P.sortable).length > 0
    ), U = d(() => E.value && f.value === !0), q = d(() => {
      const P = C.value ? n.internalItems.value : U.value ? n.mapItems(l.fields, l.items, l, {
        isSortable: E,
        isFilterableTable: I,
        sortDescBoolean: i
      }) : l.items;
      if (l.perPage !== void 0) {
        const K = (l.currentPage - 1) * l.perPage;
        return P.splice(K, l.perPage);
      }
      return P;
    }), ae = (P) => typeof P == "string" ? Qa(P) : P.label !== void 0 ? P.label : typeof P.key == "string" ? Qa(P.key) : P.key, Z = (P, K, ge = !1) => {
      const H = typeof P == "string" ? P : P.key;
      a("headClicked", H, P, K, ge), be(P);
    }, G = (P, K, ge) => {
      a("rowClicked", P, K, ge), de(P, K, ge.shiftKey);
    }, te = (P, K, ge) => a("rowDblClicked", P, K, ge), fe = (P, K, ge) => a("rowHovered", P, K, ge), pe = (P, K, ge) => a("rowUnhovered", P, K, ge), be = (P) => {
      if (!E.value)
        return;
      const K = typeof P == "string" ? P : P.key, ge = typeof P == "string" ? !1 : P.sortable;
      if (E.value === !0 && ge === !0) {
        const H = !i.value;
        K !== l.sortBy && a("update:sortBy", K), a("update:sortDesc", H), a("sorted", K, H);
      }
    }, oe = () => {
      p.value && a("selection", Array.from(B.value));
    }, de = (P, K, ge = !1) => {
      if (p.value) {
        if (B.value.has(P))
          B.value.delete(P), a("rowUnselected", P);
        else if (l.selectMode === "single" && B.value.size > 0 && (B.value.forEach((H) => a("rowUnselected", H)), B.value.clear()), l.selectMode === "range" && B.value.size > 0 && ge) {
          const H = Array.from(B.value).pop(), ve = q.value.findIndex((st) => st === H), me = Math.min(ve, K), fa = Math.max(ve, K);
          q.value.slice(me, fa + 1).forEach((st) => {
            B.value.has(st) || (B.value.add(st), a("rowSelected", st));
          });
        } else
          B.value.add(P), a("rowSelected", P);
        oe();
      }
    }, L = async () => {
      if (!C.value || !l.provider || w.value)
        return;
      w.value = !0;
      const P = new Proxy(
        {
          currentPage: l.currentPage,
          filter: l.filter,
          sortBy: l.sortBy,
          sortDesc: l.sortDesc,
          perPage: l.perPage
        },
        {
          get: (ge, H) => H in ge ? ge[H] : void 0,
          set: () => (console.error("BTable provider context is a read-only object."), !0)
        }
      ), K = l.provider(P, n.updateInternalItems);
      if (K !== void 0) {
        if (K instanceof Promise)
          try {
            const ge = await K;
            return Array.isArray(ge) ? await n.updateInternalItems(ge) : void 0;
          } finally {
            w.value && (w.value = !1);
          }
        try {
          return await n.updateInternalItems(K);
        } finally {
          w.value && (w.value = !1);
        }
      }
    }, z = (P) => {
      P._showDetails = !P._showDetails;
    }, ee = (P) => [
      P.class,
      P.thClass,
      P.variant ? `table-${P.variant}` : void 0,
      {
        "b-table-sortable-column": E.value && P.sortable,
        "b-table-sticky-column": P.stickyColumn
      }
    ], se = (P, K) => [
      P.class,
      P.tdClass,
      P.variant ? `table-${P.variant}` : void 0,
      K != null && K._cellVariants && (K != null && K._cellVariants[P.key]) ? `table-${K == null ? void 0 : K._cellVariants[P.key]}` : void 0,
      {
        "b-table-sticky-column": P.stickyColumn
      }
    ], he = (P) => [
      P._rowVariant ? `table-${P._rowVariant}` : null,
      P._rowVariant ? `table-${P._rowVariant}` : null,
      p.value && B.value.has(P) ? `selected table-${l.selectionVariant}` : null
    ], xe = () => {
      if (!p.value)
        return;
      const P = B.value.size > 0 ? Array.from(B.value) : [];
      B.value = /* @__PURE__ */ new Set([...q.value]), B.value.forEach((K) => {
        P.includes(K) || a("rowSelected", K);
      }), oe();
    }, W = () => {
      p.value && (B.value.forEach((P) => {
        a("rowUnselected", P);
      }), B.value = /* @__PURE__ */ new Set([]), oe());
    }, re = (P) => {
      if (!p.value)
        return;
      const K = q.value[P];
      !K || B.value.has(K) || (B.value.add(K), a("rowSelected", K), oe());
    }, De = (P) => {
      if (!p.value)
        return;
      const K = q.value[P];
      !K || !B.value.has(K) || (B.value.delete(K), a("rowUnselected", K), oe());
    }, Ie = async (P, K, ge) => {
      if (K === ge)
        return;
      const H = (In) => l.noProvider && l.noProvider.includes(In), ve = !["currentPage", "perPage"].includes(P), me = ["currentPage", "perPage"].includes(P) && (H("paging") || $.value === !0), fa = ["filter"].includes(P) && (H("filtering") || k.value === !0), st = ["sortBy", "sortDesc"].includes(P) && (H("sorting") || v.value === !0);
      me || fa || st || (await L(), ve && n.notifyFilteredItems());
    };
    return ce(
      () => l.filter,
      (P, K) => {
        P === K || C.value || P || ba(l.items).then((ge) => a("filtered", ge));
      }
    ), ce(
      w,
      () => w.value !== m.value && a("update:busy", w.value)
    ), ce(
      m,
      () => w.value !== m.value && (w.value = m.value)
    ), ce(
      () => l.filter,
      (P, K) => Ie("filter", P, K)
    ), ce(
      () => l.currentPage,
      (P, K) => Ie("currentPage", P, K)
    ), ce(
      () => l.perPage,
      (P, K) => Ie("perPage", P, K)
    ), ce(
      () => l.sortBy,
      (P, K) => Ie("sortBy", P, K)
    ), ce(
      () => l.sortDesc,
      (P, K) => Ie("sortDesc", P, K)
    ), Je(() => {
      C.value && L();
    }), t({
      selectAllRows: xe,
      clearSelected: W,
      selectRow: re,
      unselectRow: De,
      refresh: L
    }), (P, K) => (g(), D(Ya, $e(Ve(s(A))), {
      default: j(() => {
        var ge;
        return [
          X("thead", null, [
            P.$slots["thead-top"] ? x(P.$slots, "thead-top", { key: 0 }) : Y("", !0),
            X("tr", null, [
              s(F) ? (g(), _("th", {
                key: 0,
                class: N(["b-table-selection-column", {
                  "b-table-sticky-column": s(y)
                }])
              }, [
                x(P.$slots, "select-head", {}, () => [
                  ne(J(typeof e.selectHead == "boolean" ? "Selected" : e.selectHead), 1)
                ])
              ], 2)) : Y("", !0),
              (g(!0), _(ue, null, Be(s(S), (H) => (g(), _("th", Q({
                key: H.key,
                scope: "col",
                class: ee(H),
                title: H.headerTitle,
                abbr: H.headerAbbr,
                style: H.thStyle
              }, H.thAttr, {
                onClick: (ve) => Z(H, ve)
              }), [
                X("div", Oc, [
                  x(P.$slots, "sort-icon", {
                    field: H,
                    sortBy: e.sortBy,
                    selected: H.key === e.sortBy,
                    isDesc: s(i),
                    direction: s(i) ? "desc" : "asc"
                  }, () => [
                    s(E) && H.sortable ? (g(), _("span", {
                      key: 0,
                      class: N(["b-table-sort-icon", {
                        sorted: H.key === e.sortBy,
                        [`sorted-${s(i) ? "desc" : "asc"}`]: H.key === e.sortBy
                      }])
                    }, null, 2)) : Y("", !0)
                  ]),
                  X("div", null, [
                    P.$slots["head(" + H.key + ")"] || P.$slots["head()"] ? x(P.$slots, P.$slots["head(" + H.key + ")"] ? "head(" + H.key + ")" : "head()", {
                      key: 0,
                      label: H.label
                    }) : (g(), _(ue, { key: 1 }, [
                      ne(J(ae(H)), 1)
                    ], 64))
                  ])
                ])
              ], 16, Vc))), 128))
            ]),
            P.$slots["thead-sub"] ? (g(), _("tr", Pc, [
              (g(!0), _(ue, null, Be(s(S), (H) => (g(), _("td", {
                key: H.key,
                scope: "col",
                class: N([H.class, H.thClass, H.variant ? `table-${H.variant}` : ""])
              }, [
                P.$slots["thead-sub"] ? x(P.$slots, "thead-sub", Q({
                  key: 0,
                  items: s(S)
                }, H)) : (g(), _(ue, { key: 1 }, [
                  ne(J(H.label), 1)
                ], 64))
              ], 2))), 128))
            ])) : Y("", !0)
          ]),
          X("tbody", null, [
            (g(!0), _(ue, null, Be(s(q), (H, ve) => (g(), _(ue, { key: ve }, [
              X("tr", {
                class: N(he(H)),
                onClick: (me) => !s(Mt)(me) && G(H, ve, me),
                onDblclick: (me) => !s(Mt)(me) && te(H, ve, me),
                onMouseenter: (me) => !s(Mt)(me) && fe(H, ve, me),
                onMouseleave: (me) => !s(Mt)(me) && pe(H, ve, me)
              }, [
                s(F) ? (g(), _("td", {
                  key: 0,
                  class: N(["b-table-selection-column", {
                    "b-table-sticky-column": s(y)
                  }])
                }, [
                  x(P.$slots, "select-cell", {}, () => [
                    X("span", {
                      class: N(B.value.has(H) ? "text-primary" : "")
                    }, "ð¹", 2)
                  ])
                ], 2)) : Y("", !0),
                (g(!0), _(ue, null, Be(s(S), (me) => (g(), _("td", Q({
                  key: me.key
                }, me.tdAttr, {
                  class: se(me, H)
                }), [
                  e.stacked && s(b) ? (g(), _("label", Ic, J(ae(me)), 1)) : Y("", !0),
                  P.$slots["cell(" + me.key + ")"] || P.$slots["cell()"] ? x(P.$slots, P.$slots["cell(" + me.key + ")"] ? "cell(" + me.key + ")" : "cell()", {
                    key: 1,
                    value: H[me.key],
                    index: ve,
                    item: H,
                    field: me,
                    items: e.items,
                    toggleDetails: () => z(H),
                    detailsShowing: H._showDetails
                  }) : (g(), _(ue, { key: 2 }, [
                    ne(J(s(n).formatItem(H, me)), 1)
                  ], 64))
                ], 16))), 128))
              ], 42, Ec),
              H._showDetails === !0 && P.$slots["row-details"] ? (g(), _("tr", {
                key: 0,
                class: N(he(H))
              }, [
                X("td", { colspan: s(V) }, [
                  x(P.$slots, "row-details", {
                    item: H,
                    toggleDetails: () => z(H)
                  })
                ], 8, Fc)
              ], 2)) : Y("", !0)
            ], 64))), 128)),
            w.value ? (g(), _("tr", {
              key: 0,
              class: N(["b-table-busy-slot", { "b-table-static-busy": s(q).length === 0 }])
            }, [
              X("td", { colspan: s(V) }, [
                x(P.$slots, "table-busy", {}, () => [
                  X("div", Nc, [
                    ye(ca, { class: "align-middle" }),
                    zc
                  ])
                ])
              ], 8, Lc)
            ], 2)) : Y("", !0),
            s(h) && s(q).length === 0 ? (g(), _("tr", Rc, [
              X("td", { colspan: s(V) }, [
                x(P.$slots, "empty", {
                  items: s(q),
                  filtered: s(I)
                }, () => [
                  ne(J(s(I) ? e.emptyFilteredText : e.emptyText), 1)
                ])
              ], 8, Hc)
            ])) : Y("", !0)
          ]),
          s(r) ? (g(), _("tfoot", Mc, [
            X("tr", null, [
              (g(!0), _(ue, null, Be(s(S), (H) => (g(), _("th", Q({
                key: H.key
              }, H.thAttr, {
                scope: "col",
                class: [H.class, H.thClass, H.variant ? `table-${H.variant}` : ""],
                title: H.headerTitle,
                abbr: H.headerAbbr,
                style: H.thStyle,
                onClick: (ve) => Z(H, ve, !0)
              }), J(H.label), 17, Dc))), 128))
            ])
          ])) : P.$slots["custom-foot"] ? (g(), _("tfoot", jc, [
            x(P.$slots, "custom-foot", {
              fields: s(S),
              items: e.items,
              columns: (ge = s(S)) == null ? void 0 : ge.length
            })
          ])) : Y("", !0),
          P.$slots["table-caption"] ? (g(), _("caption", qc, [
            x(P.$slots, "table-caption")
          ])) : e.caption ? (g(), _("caption", Gc, J(e.caption), 1)) : Y("", !0)
        ];
      }),
      _: 3
    }, 16));
  }
}), Uc = /* @__PURE__ */ R({
  __name: "BTbody",
  props: {
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = d(() => ({
      [`thead-${t.variant}`]: t.variant !== void 0
    }));
    return (l, o) => (g(), _("tbody", {
      class: N(s(a))
    }, [
      x(l.$slots, "default")
    ], 2));
  }
}), Xc = ["scope", "colspan", "rowspan", "data-label"], Kc = { key: 0 }, Jc = /* @__PURE__ */ R({
  __name: "BTd",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { default: !1 },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = c(u(t, "stickyColumn")), l = d(() => ({
      [`table-${t.variant}`]: t.variant !== void 0,
      "b-table-sticky-column": a.value,
      "table-b-table-default": a.value && t.variant === void 0
    })), o = d(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, r) => (g(), _("td", {
      scope: s(o),
      class: N(s(l)),
      colspan: e.colspan,
      rowspan: e.rowspan,
      "data-label": e.stackedHeading
    }, [
      e.stackedHeading ? (g(), _("div", Kc, [
        x(n.$slots, "default")
      ])) : x(n.$slots, "default", { key: 1 })
    ], 10, Xc));
  }
}), Yc = /* @__PURE__ */ R({
  __name: "BTfoot",
  props: {
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = d(() => ({
      [`table-${t.variant}`]: t.variant !== void 0
    }));
    return (l, o) => (g(), _("tfoot", {
      class: N(s(a))
    }, [
      x(l.$slots, "default")
    ], 2));
  }
}), Zc = ["scope", "colspan", "rowspan", "data-label"], Qc = { key: 0 }, ef = /* @__PURE__ */ R({
  __name: "BTh",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { default: !1 },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = c(u(t, "stickyColumn")), l = d(() => ({
      [`table-${t.variant}`]: t.variant !== void 0,
      "b-table-sticky-column": a.value,
      "table-b-table-default": a.value && t.variant === void 0
    })), o = d(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, r) => (g(), _("th", {
      scope: s(o),
      class: N(s(l)),
      colspan: e.colspan,
      rowspan: e.rowspan,
      "data-label": e.stackedHeading
    }, [
      e.stackedHeading !== void 0 ? (g(), _("div", Qc, [
        x(n.$slots, "default")
      ])) : x(n.$slots, "default", { key: 1 })
    ], 10, Zc));
  }
}), tf = /* @__PURE__ */ R({
  __name: "BThead",
  props: {
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = d(() => ({
      [`table-${t.variant}`]: t.variant !== void 0
    }));
    return (l, o) => (g(), _("thead", {
      class: N(s(a))
    }, [
      x(l.$slots, "default")
    ], 2));
  }
}), af = /* @__PURE__ */ R({
  __name: "BTr",
  props: {
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = d(() => ({
      [`table-${t.variant}`]: t.variant !== void 0
    }));
    return (l, o) => (g(), _("tr", {
      class: N(s(a))
    }, [
      x(l.$slots, "default")
    ], 2));
  }
}), lf = /* @__PURE__ */ R({
  __name: "BTab",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    active: { default: !1 },
    buttonId: { default: void 0 },
    disabled: { default: !1 },
    lazy: { default: void 0 },
    lazyOnce: { default: void 0 },
    noBody: { type: [Boolean, String], default: !1 },
    tag: { default: "div" },
    titleItemClass: { default: void 0 },
    titleLinkAttributes: { default: void 0 },
    titleLinkClass: { default: void 0 }
  },
  setup(e) {
    const t = e, a = We(bo, null), l = c(u(t, "active")), o = c(u(t, "disabled")), n = c(u(t, t.lazyOnce !== void 0 ? "lazyOnce" : "lazy")), r = M(!1), i = d(() => !!(a != null && a.lazy.value || n.value)), f = d(() => t.lazyOnce !== void 0), p = d(() => l.value && !o.value), y = d(() => {
      const m = i.value && f.value && r.value;
      return p.value || !i.value || m;
    }), b = d(() => ({
      active: l.value,
      show: l.value,
      "card-body": (a == null ? void 0 : a.card.value) && t.noBody === !1
    }));
    return ce(y, (m) => {
      m && !r.value && (r.value = !0);
    }), (m, h) => (g(), D(le(e.tag), {
      id: e.id,
      class: N(["tab-pane", s(b)]),
      role: "tabpanel",
      "aria-labelledby": "profile-tab"
    }, {
      default: j(() => [
        s(y) ? x(m.$slots, "default", { key: 0 }) : Y("", !0)
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), of = ["id", "data-bs-target", "aria-controls", "aria-selected", "onClick"], nf = /* @__PURE__ */ R({
  __name: "BTabs",
  props: {
    activeNavItemClass: { default: void 0 },
    activeTabClass: { default: void 0 },
    align: { default: void 0 },
    contentClass: { default: void 0 },
    card: { default: !1 },
    end: { default: !1 },
    fill: { default: !1 },
    id: { default: void 0 },
    justified: { default: !1 },
    lazy: { default: !1 },
    navClass: { default: void 0 },
    navWrapperClass: { default: void 0 },
    noFade: { default: !1 },
    noNavStyle: { default: !1 },
    pills: { default: !1 },
    small: { default: !1 },
    tag: { default: "div" },
    vertical: { default: !1 },
    modelValue: { default: -1 }
  },
  emits: ["update:modelValue", "activate-tab", "click"],
  setup(e, { emit: t }) {
    const a = e, l = _e(a, "modelValue", t), o = Ee(), n = c(u(a, "card")), r = c(u(a, "end")), i = c(u(a, "fill")), f = c(u(a, "justified")), p = c(u(a, "lazy")), y = c(u(a, "noFade")), b = c(u(a, "noNavStyle")), m = c(u(a, "pills")), h = c(u(a, "small")), $ = c(u(a, "vertical")), v = M(l.value), k = M(""), w = d({
      get: () => v.value,
      set: (C) => {
        v.value = C, B.value.length > 0 && C >= 0 && C < B.value.length ? k.value = B.value[C].buttonId : k.value = "", l.value = C;
      }
    }), B = d(
      () => o.default === void 0 ? [] : ha(o.default, "BTab").map((C, F) => {
        C.props || (C.props = {});
        const E = C.props["button-id"] || et("tab"), U = C.props.id || et(), q = w.value > -1 ? F === w.value : C.props.active === "", ae = C.props["title-item-class"], Z = C.props["title-link-attributes"];
        return {
          buttonId: E,
          contentId: U,
          active: q,
          disabled: C.props.disabled === "" || C.props.disabled === !0,
          navItemClasses: [
            {
              active: q,
              disabled: C.props.disabled === "" || C.props.disabled === !0
            },
            q && a.activeNavItemClass ? a.activeNavItemClass : null,
            C.props["title-link-class"]
          ],
          tabClasses: [
            {
              fade: !y.value
            },
            q && a.activeTabClass ? a.activeTabClass : null
          ],
          target: `#${U}`,
          title: C.props.title,
          titleItemClass: ae,
          titleLinkAttributes: Z,
          onClick: C.props.onClick,
          tab: C,
          //TODO remove this in future since the mapped value does not provide a direct reference to the actual slot component.
          tabComponent: () => ha(o.default, "BTab")[F]
        };
      })
    ), T = d(() => !(B != null && B.value && B.value.length > 0)), O = d(() => ({
      "d-flex": $.value,
      "align-items-start": $.value
    })), A = Nt(u(a, "align")), S = d(() => ({
      "nav-pills": m.value,
      "flex-column me-3": $.value,
      [A.value]: a.align !== void 0,
      "nav-fill": i.value,
      "card-header-tabs": n.value,
      "nav-justified": f.value,
      "nav-tabs": !b.value && !m.value,
      small: h.value
    })), V = (C) => {
      let F = !1;
      if (C !== void 0 && C > -1 && C < B.value.length && !B.value[C].disabled && (w.value < 0 || B.value[C].buttonId !== k.value)) {
        const E = new Ke("activate-tab", { cancelable: !0 });
        t("activate-tab", C, w.value, E), E.defaultPrevented || (w.value = C, F = !0);
      }
      return !F && l.value !== w.value && (l.value = w.value), F;
    }, I = (C, F) => {
      var E;
      V(F), F >= 0 && !B.value[F].disabled && ((E = B.value[F]) != null && E.onClick) && typeof B.value[F].onClick == "function" && B.value[F].onClick(C);
    };
    return V(v.value), ce(l, (C, F) => {
      if (C === F)
        return;
      if (C = Math.max(C, -1), F = Math.max(F, -1), B.value.length <= 0) {
        w.value = -1;
        return;
      }
      const E = C > F;
      let U = C;
      const q = B.value.length - 1;
      for (; U >= 0 && U <= q && B.value[U].disabled; )
        U += E ? 1 : -1;
      if (U < 0) {
        V(0);
        return;
      }
      if (U >= B.value.length) {
        V(B.value.length - 1);
        return;
      }
      V(U);
    }), ce(B, () => {
      let C = B.value.map((F) => F.active && !F.disabled).lastIndexOf(!0);
      C < 0 && (w.value >= B.value.length ? C = B.value.map((F) => !F.disabled).lastIndexOf(!0) : B.value[w.value] && !B.value[w.value].disabled && (C = w.value)), C < 0 && (C = B.value.map((F) => !F.disabled).indexOf(!0)), B.value.forEach((F, E) => F.active = E === C), V(C);
    }), Je(() => {
      if (w.value < 0 && B.value.length > 0 && !B.value.some((C) => C.active)) {
        const C = B.value.map((F) => !F.disabled).indexOf(!0);
        V(C >= 0 ? C : -1);
      }
    }), ot(bo, {
      lazy: p,
      card: n
    }), (C, F) => (g(), D(le(e.tag), {
      id: e.id,
      class: N(["tabs", s(O)])
    }, {
      default: j(() => [
        s(r) ? (g(), _("div", {
          key: 0,
          class: N(["tab-content", e.contentClass])
        }, [
          (g(!0), _(ue, null, Be(s(B), ({ tabComponent: E, contentId: U, tabClasses: q, active: ae }, Z) => (g(), D(le(E()), {
            id: U,
            key: Z,
            class: N(q),
            active: ae
          }, null, 8, ["id", "class", "active"]))), 128)),
          s(T) ? (g(), _("div", {
            key: "bv-empty-tab",
            class: N(["tab-pane active", { "card-body": s(n) }])
          }, [
            x(C.$slots, "empty")
          ], 2)) : Y("", !0)
        ], 2)) : Y("", !0),
        X("div", {
          class: N([e.navWrapperClass, { "card-header": s(n), "ms-auto": e.vertical && s(r) }])
        }, [
          X("ul", {
            class: N(["nav", [s(S), e.navClass]]),
            role: "tablist"
          }, [
            x(C.$slots, "tabs-start"),
            (g(!0), _(ue, null, Be(s(B), ({ tab: E, buttonId: U, contentId: q, navItemClasses: ae, active: Z, target: G }, te) => {
              var fe, pe, be;
              return g(), _("li", {
                key: te,
                class: N(["nav-item", (fe = E == null ? void 0 : E.props) == null ? void 0 : fe["title-item-class"]]),
                role: "presentation"
              }, [
                X("button", Q({
                  id: U,
                  class: ["nav-link", ae],
                  "data-bs-toggle": "tab",
                  "data-bs-target": G,
                  role: "tab",
                  "aria-controls": q,
                  "aria-selected": Z
                }, (pe = E == null ? void 0 : E.props) == null ? void 0 : pe["title-link-attributes"], {
                  onClick: ct((oe) => I(oe, te), ["stop", "prevent"])
                }), [
                  E.children && E.children.title ? (g(), D(le(E.children.title), { key: 0 })) : (g(), _(ue, { key: 1 }, [
                    ne(J((be = E == null ? void 0 : E.props) == null ? void 0 : be.title), 1)
                  ], 64))
                ], 16, of)
              ], 2);
            }), 128)),
            x(C.$slots, "tabs-end")
          ], 2)
        ], 2),
        s(r) ? Y("", !0) : (g(), _("div", {
          key: 1,
          class: N(["tab-content", e.contentClass])
        }, [
          (g(!0), _(ue, null, Be(s(B), ({ tabComponent: E, contentId: U, tabClasses: q, active: ae }, Z) => (g(), D(le(E()), {
            id: U,
            key: Z,
            class: N(q),
            active: ae
          }, null, 8, ["id", "class", "active"]))), 128)),
          s(T) ? (g(), _("div", {
            key: "bv-empty-tab",
            class: N(["tab-pane active", { "card-body": s(n) }])
          }, [
            x(C.$slots, "empty")
          ], 2)) : Y("", !0)
        ], 2))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), sf = /* @__PURE__ */ R({
  __name: "BTooltip",
  setup(e) {
    return (t, a) => (g(), D(Wa, { tooltip: "" }, ao({ _: 2 }, [
      Be(t.$slots, (l, o) => ({
        name: o,
        fn: j((n) => [
          x(t.$slots, o, $e(Ve(n)))
        ])
      }))
    ]), 1024));
  }
}), rf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BAccordion: qi,
  BAccordionItem: Ki,
  BAlert: lr,
  BAvatar: ir,
  BAvatarGroup: rr,
  BBadge: cr,
  BBreadcrumb: gr,
  BBreadcrumbItem: on,
  BButton: wt,
  BButtonGroup: br,
  BButtonToolbar: yr,
  BCard: fn,
  BCardBody: dn,
  BCardFooter: cn,
  BCardGroup: $r,
  BCardHeader: sn,
  BCardImg: la,
  BCardSubtitle: un,
  BCardText: wr,
  BCardTitle: rn,
  BCarousel: Or,
  BCarouselSlide: Lr,
  BCloseButton: Tt,
  BCol: _t,
  BCollapse: ln,
  BContainer: qr,
  BDropdown: gn,
  BDropdownDivider: Xr,
  BDropdownForm: Qr,
  BDropdownGroup: lu,
  BDropdownHeader: iu,
  BDropdownItem: uu,
  BDropdownItemButton: fu,
  BDropdownText: pu,
  BForm: bn,
  BFormCheckbox: hn,
  BFormCheckboxGroup: Tu,
  BFormFloatingLabel: yu,
  BFormGroup: Iu,
  BFormInput: zu,
  BFormInvalidFeedback: xa,
  BFormRadio: Bn,
  BFormRadioGroup: Gu,
  BFormRow: jt,
  BFormSelect: Ku,
  BFormSelectOption: Xa,
  BFormSelectOptionGroup: $n,
  BFormSpinButton: Tc,
  BFormTag: wn,
  BFormTags: dd,
  BFormText: Aa,
  BFormTextarea: md,
  BFormValidFeedback: Va,
  BImg: Ua,
  BInputGroup: $d,
  BInputGroupAddon: Ka,
  BInputGroupAppend: wd,
  BInputGroupPrepend: kd,
  BInputGroupText: kn,
  BLink: Ne,
  BListGroup: Sd,
  BListGroupItem: Cd,
  BModal: Vd,
  BNav: Od,
  BNavForm: Pd,
  BNavItem: Ld,
  BNavItemDropdown: zd,
  BNavText: Hd,
  BNavbar: Md,
  BNavbarBrand: qd,
  BNavbarNav: Gd,
  BNavbarToggle: Yd,
  BOffcanvas: lc,
  BOverlay: Cn,
  BPagination: fc,
  BPlaceholder: He,
  BPlaceholderButton: xn,
  BPlaceholderCard: mc,
  BPlaceholderTable: pc,
  BPlaceholderWrapper: gc,
  BPopover: Wa,
  BProgress: hc,
  BProgressBar: An,
  BRow: $c,
  BSpinner: ca,
  BTab: lf,
  BTable: Wc,
  BTableSimple: Ya,
  BTabs: nf,
  BTbody: Uc,
  BTd: Jc,
  BTfoot: Yc,
  BTh: ef,
  BThead: tf,
  BToast: pn,
  BToastContainer: _a,
  BToastPlugin: Dr,
  BToaster: _a,
  BTooltip: sf,
  BTr: af,
  BTransition: Ct
}, Symbol.toStringTag, { value: "Module" })), uf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  vBColorMode: Wd,
  vBModal: Oa,
  vBPopover: Xd,
  vBToggle: Oa,
  vBTooltip: Kd
}, Symbol.toStringTag, { value: "Module" })), ff = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createBreadcrumb: Wo,
  useBreadcrumb: Uo,
  useColorMode: Pi
}, Symbol.toStringTag, { value: "Module" })), vf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BvCarouselEvent: oo,
  BvEvent: Ke,
  BvTriggerableEvent: It
}, Symbol.toStringTag, { value: "Module" })), mf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), pf = {
  // TODO: use options in the future
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  install(e, t = {}) {
    Object.entries(rf).forEach(([a, l]) => {
      e.component(a, l);
    }), Object.entries(uf).forEach(([a, l]) => {
      a.toLowerCase().startsWith("v") ? e.directive(a.slice(1), l) : e.directive(a, l);
    }), Wo(e);
  }
};
export {
  qi as BAccordion,
  Ki as BAccordionItem,
  lr as BAlert,
  ir as BAvatar,
  rr as BAvatarGroup,
  cr as BBadge,
  gr as BBreadcrumb,
  on as BBreadcrumbItem,
  wt as BButton,
  br as BButtonGroup,
  yr as BButtonToolbar,
  fn as BCard,
  dn as BCardBody,
  cn as BCardFooter,
  $r as BCardGroup,
  sn as BCardHeader,
  la as BCardImg,
  un as BCardSubtitle,
  wr as BCardText,
  rn as BCardTitle,
  Or as BCarousel,
  Lr as BCarouselSlide,
  Tt as BCloseButton,
  _t as BCol,
  ln as BCollapse,
  qr as BContainer,
  gn as BDropdown,
  Xr as BDropdownDivider,
  Qr as BDropdownForm,
  lu as BDropdownGroup,
  iu as BDropdownHeader,
  uu as BDropdownItem,
  fu as BDropdownItemButton,
  pu as BDropdownText,
  bn as BForm,
  hn as BFormCheckbox,
  Tu as BFormCheckboxGroup,
  yu as BFormFloatingLabel,
  Iu as BFormGroup,
  zu as BFormInput,
  xa as BFormInvalidFeedback,
  Bn as BFormRadio,
  Gu as BFormRadioGroup,
  jt as BFormRow,
  Ku as BFormSelect,
  Xa as BFormSelectOption,
  $n as BFormSelectOptionGroup,
  Tc as BFormSpinButton,
  wn as BFormTag,
  dd as BFormTags,
  Aa as BFormText,
  md as BFormTextarea,
  Va as BFormValidFeedback,
  Ua as BImg,
  $d as BInputGroup,
  Ka as BInputGroupAddon,
  wd as BInputGroupAppend,
  kd as BInputGroupPrepend,
  kn as BInputGroupText,
  Ne as BLink,
  Sd as BListGroup,
  Cd as BListGroupItem,
  Vd as BModal,
  Od as BNav,
  Pd as BNavForm,
  Ld as BNavItem,
  zd as BNavItemDropdown,
  Hd as BNavText,
  Md as BNavbar,
  qd as BNavbarBrand,
  Gd as BNavbarNav,
  Yd as BNavbarToggle,
  lc as BOffcanvas,
  Cn as BOverlay,
  fc as BPagination,
  He as BPlaceholder,
  xn as BPlaceholderButton,
  mc as BPlaceholderCard,
  pc as BPlaceholderTable,
  gc as BPlaceholderWrapper,
  Wa as BPopover,
  hc as BProgress,
  An as BProgressBar,
  $c as BRow,
  ca as BSpinner,
  lf as BTab,
  Wc as BTable,
  Ya as BTableSimple,
  nf as BTabs,
  Uc as BTbody,
  Jc as BTd,
  Yc as BTfoot,
  ef as BTh,
  tf as BThead,
  pn as BToast,
  _a as BToastContainer,
  Dr as BToastPlugin,
  _a as BToaster,
  sf as BTooltip,
  af as BTr,
  Ct as BTransition,
  pf as BootstrapVueNext,
  oo as BvCarouselEvent,
  Ke as BvEvent,
  It as BvTriggerableEvent,
  rf as Components,
  ff as Composables,
  uf as Directives,
  mf as Types,
  vf as Utils,
  Wo as createBreadcrumb,
  pf as default,
  Uo as useBreadcrumb,
  Pi as useColorMode,
  mn as useToast,
  Wd as vBColorMode,
  Oa as vBModal,
  Xd as vBPopover,
  Oa as vBToggle,
  Kd as vBTooltip
};
//# sourceMappingURL=bootstrap-vue-next.mjs.map
